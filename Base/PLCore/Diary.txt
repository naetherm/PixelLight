>> 23.03.2013
[NF]
PLFrontendQt:
- PLViewerQt doesn't close now when Escape is pressed but just minimizes.



>> 22.08.2012
[CO]
PLFrontendOS:
- Reviewed commit
  "
    Revision: 6d291f614dc1f37c58a10e9d453ff4f836c1090f
    Author: Stephan Wezel
    Date: 18.08.2012 23:05:03
    Message:
    Fixed frontend lifecycle handling in PLFrontendOS (OnStop wasn't called when the application was closed via Frontend::IsRunning = false)
  "
  in detail because a design goal was to only call e.g. "OnStop()" at a single, well defined place inside the program flow to avoid calling
  it multiple times. It turned out that on Windows, "OnStop()" was now really called twice.
  -> MS Windows: "OSWindowWindows::~OSWindowWindows()" -> "DestroyWindow(m_hWnd)" -> "OSWindowWindows::WndProc()" -> "WM_DESTROY"
  -> Linux: "OSWindowLinux::~OSWindowLinux()" -> "XDestroyWindow(m_pDisplay, m_nNativeWindowHandle)" ... does not result in directly
     processed events as under MS Windows. Events are processed inside "OSWindowLinux::Ping()". Meaning under Linux, "OnPause()" and "OnStop()"
     were not called when terminating the application without closing the window.
  -> "OnStop()" is now called inside "OSWindowLinux::~OSWindowLinux()", which is identical to "OSWindowMacOSX::~OSWindowMacOSX()"
  -> See "AbstractLifecycle" class documentation for more information about the life cycle



>> 17.06.2012
[CO]
- Functor: Added support for FuncGenFunPtr and FuncGenMemPtr
- "Runtime::GetDirectory()" and "Runtime::GetType()" were broken: While Jens Schmer was updating the unit tests it became clear
  that there are inconsistencies across classes, and back then also inside classes, how urls/filenames are represented.
  (with/without "file://" at the beginning, with/without "/" at the end of a directory name) Back then, I tried to heavily comment
  how exactly the result a method is returning looks like, and also tried to have consistency at least inside a class. It
  appears that since then the mentioned methods were broken, had expected nothing else from such changes (that's why I don't
  dare to try to make the filenames/URLs consistent across classes on the fly without having more unit tests).
- Implemented "SystemMacOSX::GetExecutableFilename()"



>> 14.06.2012
[CO]
PLFrontendOS:
- Started Mac OS X Cocoa implementation



>> 02.04.2012
[CO]
PLFrontendOS:
- Android frontend: The virtual keyboard is now opened by using the menu key instead of the search key (which appears to be not that often
  available on mobile devices)



>> 01.04.2012
[CO]
- Reverted change within "FileObject::Assign()" from "10.03.2012" because it was breaking file loading on the Android platform. Can't look
  into detail what's going on on Android right now, so I just reverted and added a comment.



>> 10.03.2012
[SW]
- Regex: Added some comments.
    Added additional functionality to get the result string:
	e.g. RegEx expr("Hal+o");
		 String subject("Hallo World!");
		 if(expr.Match(subject))
		 {
			String result = expr.GetResultMatch(); // returns "Hallo";
		 }



>> 10.03.2012
[CO]
- Within the unit tests, Jens Schmer tried
    PLCore::Directory cDir("testData/FileSystemTest.zip/");
    CHECK(cDir.Exists());
    CHECK(cDir.IsDirectory());
  with the result that "cDir.IsDirectory()" returned "false" although the "FileObject" class documentation stated that this should be "true".
  In case of a directory, "FileObject::Assign()" was removing "/" at the end of the filename without more information why it's done. Also, the
  URL was collapsed which is an expensive operation - we might not do that if it's not absolutely required. The system shouldn't play around too
  much with the given data. Reviewed and changed the behaviour which is now according to the existing documentation and the unit test no longer
  fails. Also tested several existing projects, I hope this doesn't break anything unnoticed.
  -> The "FileObject::GetUrl()"-documentation stated:
     "The URL of a 'FileObject' always contains a filename that never ends with "/"! (so, you can safely use 'Url::GetFilename()' to get the name
      of any file or directory)"
     and
     "e.g.: 'Directory("C:\\test")' and 'Directory("C:\\test\\")' are equal, but
      'GetUrl()' will always return "C:/test"."
     Updated comments according to the made change. This behaviour is now also consistent with the URL-class which preserves "/", in case there
     was one.
- "FileSearchZip::GetNextFile()" was removing "/" at the end of a string without more information why this was done. Looked odd and when playing
  around within the unit tests the behaviour was unexpected.
PLFrontendQt:
- Added "QTableViewWithCopy": A "QTableView" where it's possible to copy the selected content into the clipboard. I was using this widget already
  within my master thesis to be able to copy out data without having to typewrite it from the GUI.
- Added "DockWidgetSceneMeshInformation" for information about the mesh of the currently selected scene node. I was also already using such a thing
  for volume scene nodes within my master thesis. For now it's a basic table, I assume a tree view would be better in here for a better overview -
  but the current first implementation is all I need for now.
- Added helper method "DockWidget::AddDockWidgetAndTabify()"
- Usability: By default, new RTTI dock widget instances are "tabified". Currently I'am working with the RTTI dock widgets all day long and constantly
  have to move around them after hey have been instanced. Finally more comfortable to work with.



>> 08.03.2012
[CO]
- While working on PLUnitTests, Jens Schmer noticed that the "nCount"-behaviour of
    "bool Container<ValueType>::Compare(const Container<ValueType> &lstContainer, uint32 nStart, uint32 nCount) const"
  was inconsistent to the other similar methode like
    "bool Container<ValueType>::Add(const Container<ValueType> &lstContainer, uint32 nStart, uint32 nCount)"
  -> Fixed this (shouldn't break anything)



>> 07.03.2012
[CO]
- "template <class ValueType> ValueType Iterable<ValueType>::Null;" is causing issues within "Bitset" due to "class PLCORE_API Bitset" resulting that
  stuff from the template base classes have now to be exported/imported as well. It's like a virus or a spreading wildfire. Results in
  "Bitset.obj : error LNK2001: unresolved external symbol "public: static bool PLCore::Iterable<bool>::Null" (?Null@?$Iterable@_N@PLCore@@2_NA)"
  within e.g. PLUnitTests. Usually, we don't write something like "class PLCORE_API Bitset" in PixelLight, instead we export/import stuff explicitly in order
  to have full control. As far as I remember, some time ago, this caused issues on a GCC or Clang compiler version within the bitset class (vtable issue).
  Now the issue strikes back within PLUnitTests. I don't have time to check all compilers for whether or not the issue we had earlier still exists, so I go the,
  hopefully safe way, by moving this "Null"-instance from the base into derived classes. E.g. the bitset class can now do the usual export/import and the linker
  issue within PLUnitTests is gone (it's no hack, just a safer approach).



>> 06.03.2012
[JS]
- "PLCore::Tools::Checksum": added new virtual method "Reset()" to clear stored checksums
  -> I spotted a weird behaviour of the Checksum Classes (MD5, CRC32, SHA1) during unit testing. It seemed that every test after the first checksum
     calculation failed. I could locate the Problem in the abstract interface "PLCore::Checksum": it calls the implementation-specific "Update"-Method
     without clearing previous checksums first and that results in corrupted checksums if you calculate more than one checksum on one specific checksum-object.
  -> Fixed that with introducing a new method to the abstract "Checksum"-interface named "Reset". It should reset all previous calculated checksums.
  -> Using the "Reset"-method before calculating anything in the "Checksum"-interfaces "Get"-methods including its overloads fixes this bug.



>> 03.03.2012
[CO]
- "Var::SetInt64()": Disabled the annoying warning (VC 2010)
   "warning C4244: 'argument' : conversion from 'PLCore::int64' to 'PLCore::int32', possible loss of data""
   -> We know that this conversion will introduce a potential loss of data



>> 27.02.2012
[CO]
- The loadable system can now also deal with file formats which don't have any file extension
  -> Personally, I would try to avoid using such file formats because if there are multiple of such file formats, it becomes hard to
     figure out automatically which one should be used *content must be analysed*
- The loadable system can now also deal with file formats like DICOM which load from directories instead of files
  -> Now working since 4 month with DICOM data within my master thesis. Until now I had some uggly hacks within my project and now it's time for
     cleanup. Similar to file formats without an extension, such "directory formats" should not be overused because it becomes hard to
     figure out automatically which one should be used *content must be analysed*.



>> 20.02.2012
[CO]
- Improved "Checksum"/"ChecksumCRC32" usability (I currently use a CRC32 checksum to deal with shader permutations)



>> 19.02.2012
[CO]
PLScriptLua:
- "LuaUserData": Added support for Lua's "__eq" metamethod callback (called when Lua tries to check for equality)



>> 12.02.2012
[CO]
- Feature request "ID: 3486884" (http://sourceforge.net/tracker/?func=detail&aid=3486884&group_id=507544&atid=2063685): Added "MemoryManager::Move()"



>> 11.02.2012
[CO]
PLScriptBindings:
- "SNMScript": In case there's no script instance or no valid update function, we also don't need a constant update
- Now directly storing singleton instances, they will not change over time
PLScriptLua:
- "RTTIObjectMethodPointer::CallDynFunc()" performance optimization: There's no need to perform expensive parameter conversion if a function has no parameters
- "RTTIObjectPointerBase::NewIndexMetamethod()" performance optimization: If possible, no string is used for parameter conversion
- Now using "LuaJIT" by default, classic Lua external packages will still be supported
PLFrontendOS & PLFrontendPLGui:
- Calling "OnUpdate()" is only allowed when the frontend is already fully initialized, everything else would be like a Russian roulette



>> 09.02.2012
[CO]
- Handled bug report "PLCore::String operator <" (http://dev.pixellight.org/forum/viewtopic.php?f=4&t=226)
  "
  PLCore::String s1 = "so";
  PLCore::String s2 = "so1";
  printf("%d %d\n",s1 < s2,s2 < s1);
  "
  -> Result was "0 0", should have been "1 0"
  -> "StringBuffer": "IsLessThan()", "IsLessThan()", "IsGreaterThan()", "IsGreaterThan()" were using the minimum length of both strings when calling e.g. "strncmp".
     When debugging into "strncmp()" and "strcmp()" within Visual Studio, the "strcmp()"-implementation appears to be more simple and now I'am just using "strcmp()"
     instead of "strncmp()" for the lexicographical comparison.
PLScriptLua:
- "RTTIObjectPointer", "RTTIObjectSlotPointer", "RTTIObjectMethodPointer", "RTTIObjectSignalPointer" and "RTTIObjectSignalMethodPointer" instances
  are now managed by "LuaContext" instead of constantly using "new" and "delete" directly. "LuaContext" will cache no longer used instances so that they can be reused
  later on. Before this performance optimization my stress test took 3167 milliseconds, after this change it took 1360 milliseconds.
  -> Added base classes "RTTIObjectPointerBase" and "RTTIObjectSignalPointerBase" to make it possible to use "RTTIObjectPointer" and "RTTIObjectSignalPointer" as fast
     pool elements as well. Removing elements takes now O(1) instead of O(n).
- "Script::Execute()" and "Script::EndCall()" perform an incremental step of garbage collection
  -> For now I don't want to bother the script API user with somethig like garbage collection, so do this automatically
  -> Without doing this, the instance reuse optimization from above has no chance to improve the performance because Lua will not release unused stuff when it's not
     asked to do so
PLFrontendQt:
- "SceneGraphTreeModel::dropMimeData()": Currently, there's a different tree view item drag'n'drop behaviour on Linux and Windows
  -> Linux: If an item is marked to not allow drop onto it, the mouse cursor gets "X" and dropping is impossible (as expected in the first place)
  -> Windows: If an item is marked to not allow drop onto it, the dropped item is inserted in top of or below the
              item we dropped our item onto. When debugging into Qt in order to understand the drag'n'drop behaviour,
              the exlaination for this behaviour can be found within
              "QAbstractItemView::DropIndicatorPosition QAbstractItemViewPrivate::position(const QPoint &pos, const QRect &rect, const QModelIndex &index) const"
               When just looking at this Qt source code, it appears that this has nothing to do with the Windows operation
              system at all. No OS features are used. Interesting that the behaviour under Linux is that different. Maybe
              we should also debug the drag'n'drop procedure under Linux to be able to find the one part were it starts to differ.
              I assume that there are some other relevant parts before "QAbstractItemViewPrivate::position()" is even called.
  -> When searching for this issue in the internet, it appears that there are also other people which have noticed the same thing
  -> For now we have the following hack under Windows, if we don't do this, items will disappear regularly when doing drag'n'drop making is unusable :/
  -> I'am using this drag'n'drop feature regularly when testing stuff from my master thesis and I already had this change locally to not constantly stumble into
     this issue... but it would only have been a matter of time until this local change would have been committed accidentally. So, an error description and OS
     related hack is probably the better way. As for me, I have to focus on none Qt parts in order to be able to accomplish the work I have to get done in a certain time frame.



>> 07.02.2012
[CO]
PLFrontendQt:
- "QModelIndexList - The Return" (see diary entry "31.01.2012"): The new "ModelIndexMimeData" is also using "QModelIndexList" and it appears that 
  this time there's no work around: Data is allocated within our project (debug) and deallocated in Qt (release). Bang! Debugging impossible in Visual Studio.
  Ok, I have to stop some other work to solve this issue because it starting to get annoying. :/
  Updated today from Qt 4.7.0 to Qt 4.8.0. In the new Windows x86 and x64 packages are also debug versions of Qt. The Visual Studio files within the Git repository
  are now using the Qt debug version for the debug version of the projects. This solves this issue within the Git repository, but for the Windows SDK I
  still have to do some more work. We now have to build PLFrontendQt twice. One time as usual in release mode, and one time using PixelLight release version
  and Qt debug version. An ugly mix up, but I'am afraid there's no way around. As mentioned in the diary entry "31.01.2012", adding debug versions
  of everything within the SDK is no option right now because there's no available time to spend on this topic. Other work must be done, which can't be
  delayed.



>> 05.02.2012
[CO]
PLCore:
- Added "Script::Execute()"
PLScriptBindings:
- Added "SNMScript::ScriptExecute"
PLFrontendQt:
- "PLDynVarFlagsTreeItem::PLDynVarFlagsTreeItem()": Now asking the RTTI for the flag value to ensure it's always valid (it's possible that e.g.
  there's no flag with a value of, say "4", but one with a value of "8")



>> 04.02.2012
[SW]
PLCore:
- "Array and ElementManager": Implemented MoveItem Method. With this method an item can be moved within the container "list" (between index 0 and itemcount-1)
PLFrontendQt:
- "SceneRendererDataModel": Implememted internal Drag and Drop support for moving items (only SceneRendererPass items can be moved)
- "DockWidgetSceneRenderer": Activated Drag and Drop with internal move on the tree view
- "SceneGraphTreeModel":  Implememted internal Drag and Drop support for moving items (currently only SceneNode items can be moved)
- "DockWidgetSceneGraph": Activated Drag and Drop with internal move on the tree view



>> 03.02.2012
[SW]
PLFrontendQt:
- "SceneGraphTreeModel": Fixed removing items which were added to model when setting the start SceneNode



>> 03.02.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraph": Added support for the "AddedObject"-broadcast



>> 02.02.2012
[CO]
PLFrontendQt:
- "DockWidgetLog": Usability: Update the Qt plain text edit cursor to in order to reduce the need for manual scrolling



>> 01.02.2012
[SW]
PLFrontendQt:
- "TreeItemBase": Removed the inheritance to QObject. The features of QObject aren't needed for such items. The only thing which was used was the parent<->child relationship management.
  But this management didn't support reordering of child items. So now the TreeItemBase implements an own paren<->child relationship management with some similarity to the management of QObject:
	- The TreeItem takes ownership of an child item. When the TreeItem gest destroyed then also the childs gets destroyed as well.
	- When a child item gets destroyed it removes itself from the parent
	- This management requires that an child element can't be an stack object. The Items must be created on the heap.
- Replaced all model specific header tree items with the generic HeaderTreeItem.
- "SceneGraphMenu::CloneSceneNode": Extended  the Method with an additional parameter to specify the position to which the cloned item should be inserted in the internal child list of an SceneContainer.
- Added "ActionCloned" to SceneGraphMenu::EAction enum. This value is used to add the cloned SceneNode after the source instead of adding it to the end if the child list. 
PLCore:
- "ElementManager": Added GetIndex Method.



>> 01.02.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraphQObject::UpdateTreeView()": Usability: Automatically select the new object
- "DockWidgetSceneGraph::PostSelectObject()": Usability: By default it's ensured that the selection will be visible, the item may
   be on top of our tree view or on the bottom. In case it's e.g. a scene node with expanded scene node modifiers and the selected
  item is placed at the bottom of the widget one has to scroll before it's possible to access a modifier. By asking Qt to place the
  item at the center of the widget the item is always at the same position and it's easier for the eye to quickly find the selection,
  need for scrolling is also reduced.



>> 31.01.2012
[SW]
PLFrontendQt:
- "SceneGraphTreeModel": - enable the hack only on Windows builds. No need to pollute non Windows builds with Windows only hacks/workarounds
                         - Added methods for handling adding/deleting items in the scene graph
- "DockWidgetSceneGraph": - Instead of setting the Scene Root Container to the model it uses now the new methods of the model for handling add/delete actions



>> 31.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager::ShowDockWidget()": Was not calling "show()", "activateWindow()" and "raise()" on a newly created RTTI dock widget.
  After this minor change the "QTreeView::scrollTo()" issue we noticed was completly gone, without changing anything on the system itself
  or on applications using this system. But it may just be luck that it's now working, and the discussed enhancement below should still
  be done to be on the safe side.
- An special issue occured in "DockWidgetSceneGraph::SelectObject()" when using "QTreeView::scrollTo()", resulting in an internal
  discussion showing me that it's appearently not obvious how the RTTI dock widget system works. So, I added the following description
  to "DockWidgetManager" to make it clear how the system is intented to work: ("Pre<method name>" and "Post<method name>" was just
  added as a result of this internal discussion)
  "
     When using the "CallDockWidgetsMethod()"-method to perform a broadcast, the following actions are performed:
    - Calling "Pre<method name>"
    - Calling "<method name>"
    - Calling "Post<method name>" (don't do anything in here which may influence the outside world)

    Just calling directly "<method name>" may not be enough for every broadcast participator due to the near endless
    possibilities what such a participator can actually do when receiving the broadcast. Let's have a more or less
    abstract example to make the background clear:
    For better usability a broadcast participator is calling the Qt method "QTreeView::scrollTo()" to bring something
    into the visible area. "QTreeView::scrollTo()" is using the widget size, which may change during the main-broadcast
    when any broadcast participator is for example opening another dock widget with additional information causing the GUI
    to reduce the hight of our own dock widget. Or changing the size of the main window. Or changing the display resolution.
    Or doing something totally unexpected crazy. So, while "QTreeView::scrollTo()" was correct at the exact time it was called,
    the desired final result visible to the user may not be correct when the main-broadcast has been finished.
    -> This is no problem of the GUI system, a GUI may not even be used at all in certain system constellation
    -> This is no problem of any application using this system, the using application can't know any technical details of
       a certain system constellation, nor what broadcast participators will do

    Let's take "DockWidgetSceneGraph::SelectObject() as a concrete example, even if it may not be used in a certain system
    constellation. In here, the order "issue" from above can't be resolved by simply ensuring that the broadcast receivers
    are in the order required to make the special case "DockWidgetSceneGraph::SelectObject()" behaves correctly. Reasons:
    1. Adding any fixed order would require additional information, which is not available to the system or users of the system
    2. The system itself does not know "DockWidgetSceneGraph::SelectObject()", nor does it know what any broadcast participator do
    3. Another broadcast participator like "Bob::SelectObject()" may require a totally different broadcast receiver order
    4. Another broadcast like "Bob::TakesOverTheWorld()" may require a totally different broadcast receiver order
    5. Any application using this system, can't know what's happening when doing a broadcast, and therefore can't
       add any special hacks to work around issues possible with certain system configurations, which are also not
       known due to the dynamic nature of the system. New plugins can add new dock widget required new special behaviour.
    6. Adding any restrictions to this chaotic system would artificially limit it's use or would add dependencies where no
       dependencies are required
    "
- "SceneGraphTreeModel::GetModelIndexForSceneNode()" is using "QModelIndexList", "QModelIndexList" is causing troubles in Visual
  Studio when mixing release/debug builds. Right now, when debugging, the application will crash when calling the destructor of
  "QModelIndexList" because the elements were allocated within the release build version of Qt, while the elements are destroyed
  by using the debug build version of our project. This is a known issue of Visual Studio and the approach of different release/debug
  versions. When feeding Google with "QModelIndexList crash" I can see that this situation is known. The only solution I found was written by
  clever persons saying "just don't mix release/debug". The ultimate solution. On the other hand, what when this is no option
  because this "solution" would spread like a fire through the complete project and all client projects using the engine? Meaning, we
  can't just change suddenly to a totally other approach just because there's now one part were this would be required for a clean solution.
  Using only debug versions in debug mode would mean that this must be done for all projects. Including external dependencies: Current number
  of build external libraries for all platform combinations multiplicated by two. This means we also have to add such debug
  versions into the SDK. Meaning we have to change the current CMake based debug system to support building the project twice, one in
  release and one in debug build, before creating the SDK installer. As for me, I don't have the time to stop everything for some weeks in
  order to hammer out all the necessary details, testing everything and praying there are no additional side effects. In the end this would
  also mean that when someone is debugging his own PixelLight based application, the debugging would be horrible slow because PixelLight and
  everything is in debug build mode as well. We had tried this long time ago, and it was really painful slow this way, so that debugging an
  own application was not practical any more when this application gets a bit more complex. So, beside the time which would be required to
  do "just don't mix release/debug", there would also be major drawbacks we already know of.
  -> Why I'am writing such a roman, again? I just don't want that someone is telling me that I'am adding ugly hacks without thinking
    following consequences through. Or that I'am going the "complicated way".
  -> Within "SceneGraphTreeModel", overwritten the virtual method "QAbstractItemModel::match()" by using the Qt implementation which is now
     using the same Visual Studio runtime as we're using.
  -> I'am now able to debug again without spending weeks in fuzzing around and adding more issues, while not being able to continue with the
     PixelLight developemnt itself just because of this one single problem in here. We should try to avoid using "QModelIndexList", since working with
     Qt this is the first found issue. If there's a similar issue which can't be solved that easily there's still the option to use debug build
     versions of Qt inside "PLFrontendQt", then using this within a custom application. PixelLight itself does not depend on Qt. But adding a debug
     version of "PLFrontendQt" and Qt within the public SDK isn't that easy as mentioned.
  -> As far as I'am concerned the just reopend, old, release/debug topic is already closed again. Right now there's far to much work to be done
     with required concrete visible results so that there's no time to spend time on this topic. No discussion, please, I'am already far behind my
     time schedule and the reason for this is not that I'am right now writing such detail entries for later analysis. For now, it just has to work.



>> 29.01.2012
[SW]
PLFrontendQt:
- PLTreeItems: Add Tooltip information about the Attributes for the first column.



>> 29.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneGraph::UpdateTreeView()": Ensure that at least the current selection remains
- "SceneGraphTreeModel::SceneGraphNodeModifierTreeItem" needs to be informed about the destruction of it's object



>> 28.01.2012
[SW]
PLFrontendQt:
- SceneGraphTreeModel: Added the Method GetModelIndexForSceneNode to get an QModelIndex from an PLScene::SceneNode instance.
  To find the item in the model the memory address of the PLScene::SceneNode item is currently used for comparison.
  If there is a better way to identify a SceneNode exclusivly without relaying on a memory address then inform me
- Added Helper.h which contains an template class which makes it easier to store an pointer into an QVariant and get the value back.
  (The template class is a copy from http://blog.bigpixel.ro/2010/04/storing-pointer-in-qvariant/)
- DockWidgetSceneGraph: Added the missing part of the SelectObject implementation



>> 25.01.2012
[CO]
- Log enhancements
  - Bugfix: "Log::Write()" as soon as the internal log message backup buffer was full, the log was flushed always with each new entry
  - By default, the log buffers now 1000 instead of just 10 messages, we're not that memory restricted, even on mobile devices :D
  - Added "EventNewEntry"-event
- Added "Queue::Top()"
- Added "Stack::Bottom()"
- "Queue" and "Stack" are now iterable as well
- "ScriptManager" is now also using "ClassManager::EventClassUnloaded"
- Bugfix: "LoadableType" was not destroying it's loaders
- "LoadableManager" is now also using "ClassManager::EventClassUnloaded"
PLFrontendQt:
- Added log dock widget
- Added scene graph context menu



>> 22.01.2012
[SW]
PLFrontendQt:
- Renamed PLDynVarFloatTreeItem to PLDynVarNativNumericTypeTreeItem. This Item now handles more numeric base types (float, double, signed/unsigned integers in 8 16 32 and 64 Bit)
- Extended the Delegate to set proper min/max ranges to the QSpinBox for 8/16 singed/unsigned integers.
	(Note for 64Bit signed/unsinged integers there is no spinbox)
- Added Tree Items for Vector3i/2i and Vector4



>> 21.01.2012
[SW]
PLFrontendQt:
- Renamed SceneNodeInfoDelegate to PLTreeItemsDelegate because this delegate is mainly usefull for models which uses internally PLDynVarTreeItems
- Added PLDynVarVector2TreeItem and PLDynVarEnumTreeItem
- PLDynVarColorTreeItem is now also useable for PLGraphics::Color4
- Extended the Delegate to create a Combobox editor for Enum values



>> 20.01.2012
[CO]
- "Runtime::ScanDirectoryPlugins()" & "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()" no longer search within a "Plugins"-directory.
  Those directories had been removed several month ago because they were just trouble, especially under Linux. In case one really needs such a directory, it's no
  problem to add the one-line-code within the user application.
PLFrontendQt:
- RTTI browser: "ClassInfoAttributeTreeItem": Added "Type" and "Default" information (quite useful e.g. when scripting)
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "IsPaused()" and "Pause()"



>> 19.01.2012
[CO]
PLFrontendQt:
- "DockWidgetSceneRenderer": Added same item delegate as Stephan did in "DockWidgetObject"



>> 19.01.2012
[SW]
PLFrontendQt:
- Reviewed all QObject::eventFilter usage and in all cases we now doesn't filter out events which we handle to add additional handling
- Added setting an ItemDelegate for the TreeView used bei the DockWidgetObject.
  This ItemDelegate adds additional (rudimentary) features when handling edits:
    - Showing a color chooser button for rtti members which represent an Color (currently only when the typ is Color3)
    - Showing a spin edit box when floating point values should be edit with directly setting the value to the rtti member when changing the value in the edit control.



>> 18.01.2012
[CO]
PLScriptBindings:
- "ScriptBinding_PL_Timing": Added "GetTimeScaleFactor()" and "SetTimeScaleFactor()"



>> 17.01.2012
[CO]
- "ObjectBase" is now using a reference counter. I want to be able to create RTTI class instances from within a script to be able to access loose C++ components,
  and when this instance is no longer referenced by the script it has to be destroyed automatically. When I added script support several month ago, I didn't touch
  this because it would have been to many changes at once - also I tried to find another solution without touching "PLCore::ObjectBase". I was unable to find another
  solution not involving several ugly and error prone hacks. This has to be a feature directly implemented within "PLCore::ObjectBase" to keep things simple.
  -> When just using C++, this change is uncritical because it only has an influence in case this reference counting is really used
  -> To be on the safe side, we now have to add a reference whenever we created an RTTI instance, else when passing this object to a script, it would be destroyed by
     the scripted automatically. Because I don't think that we're able to (or want to) add some thousands "AddReference()" without forgetting a single one, "ObjectBase"
     is not directly derived from "RefCount<ObjectBase>". Instead the interface is reimplemented, but with an initial reference count of 1 and the additional method
     "SoftRelease()" releasing a reference without destroying the instance automatically. This way we can use "ObjectBase" as usual, and when creating an RTTI class
     instance we call "SoftRelease()" before we pass the object pointer into the script so that the script is now fully responsible for it's the object.
  -> I'am of course not totally happy with this solution because having an initial reference count of 1 is inconsistent to "RefCount". "SoftRelease()" can also be
     misused. But I'am afraid there's no other solution, except saying "It's impossible to create an RTTI class instance from within a script"... but this solution
     was not acceptable for me either because it's limiting the use of scripting.
PLScriptBindings:
- Added "Object *ScriptBinding_PL_ClassManager::Create(String sClass, String sParameters)" and
  "Object *ScriptBinding_PL_ClassManager::CreateByConstructor(String sClass, String sConstructor, String sConstructorParameters, String sParameters)"
  making it possible to create RTTI class instance via script
PLScriptLua:
- "LuaUserData": Implemented Lua __tostring metamethod callback (called when Lua tries to convert the user data into a string)
- "RTTIObjectPointer" gets now informed when it's assigned object gets destroyed



>> 16.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: Made the windows version of the native OS event handling the same as under linux.
  Because, we don't do a event filtering here, so there is no reason to hide some native OS events from Qt.
  Under windows it seems that for the events WM_ENTERSIZEMOVE/WM_EXITSIZEMOVE it doesn't break something obviously in Qt, but to be an the save side it is better to not hide any native OS events from Qt.
  (Maybe Qt does react on these events to do some "performance" tweaks regarding resizeing the toplevel window by the user)
  We only add additional handling for not Qt components when certain native OS events occures, because Qt itself doesn't provide any useful events for the problem we try to solve here (e.g. the camera spinns around while the user moves/resizes the window).



>> 14.01.2012
[CO]
PLFrontendQt:
- "DockWidgetManager": Exposed "ShowDockWidget()" & "GetFirstDockWidget()" & "HideDockWidgets()" & "DestroyDockWidgets()" to the RTTI



>> 14.01.2012
[SW]
PLFrontendQt:
- FrontendMainWindow: added linux part of an workaround to avoid that the "render window" process mouse move input events while the user moves/resize the toplevel window.
  Added also a workaround for the same problem when the user drags an DockWidget. The only thing which can't be worked around is that the "render window" processes mouse input events while the user resize a DockWidget.
  This is nearly impossible to solve, because in this case no widget gets an focus in/out event. A solution might be to disable processing the mouse input
  events from the main mouse pointer (also used by the windowing system) by PLInput when the mouse cursor leaves the area of the render window (leave event).



>> 12.01.2012
[CO]
- Added "Script::GetAssociatedFilenames()" and implemented the method within the Lua backend
PLFrontendQt:
- "FrontendMainWindow": Do only start the timer when the initialization phase is over
- "FrontendMainWindow::~FrontendMainWindow()": Stop the timer at once, safe is safe
- Added "FrontendMainWindow::SetUpdateInterval()"



>> 08.01.2012
[CO]
- "LoadableManager": Added "GetTypesByExtension()" and "GetLoadersByExtension()"
- "LoadableType": Added "GetLoadersByExtension()"
- Fixed confusing path style inconsistencies within "ApplicationContext"
  -> "GetAppDirectory()": The documentation stated that this method returns "C:\MyApplication", while it was acutally "file://C:/MyApplication"
      and e.g. "GetExecutableFilename()" returned a native path style
  -> "ApplicationContext": "SetStartupDirectory()", "SetLogFilename()" and "SetConfigFilename()" have to ensure that native path style is stored internally
     as the documentation states
- "ApplicationContext": "GetAppDirectory()" points to the application directory, e.g. "C:\MyApplication" on Windows. This single method was fine when
  we only supported 32 bit. Back then this was equal to the directory the executable was in. When adding 64 bit support there was need to put the binaries,
  including the executable, within a separate directory to be able to switch between 32/64 bit while still sharing the same data. Now, "GetAppDirectory()"
  points to e.g. "C:\MyApplication" while for 32 bit the executable is e.g. within "C:\MyApplication\x86". But its also possible that there are situations
  were both point to one and the same directory. This means that there's need for another method explicitly returning the directory the executable is in.
  -> Added "GetExecutableDirectory()"
-> When writing the unit tests for this class, Jens Schmer noticed those confusing inconsistencies and partly missing documentation about path style etc.
- "CoreApplication::OnInitPlugins()" & "FrontendApplication::OnInitPlugins()": There's no guarantee that the application executable directory is the same
  as the application startup directory
  -> If the application executable directory is not the same as the application startup directory, do also scan the application startup directory
  -> This behaviour is quite useful because it allows development of plugins which can be tested within e.g. PLViewer without copying files around,
     just set the current directory to your plugin directory when launching the viewer application
PLFrontendQt:
- "SceneGraphTreeModel": Do not show scene nodes or scene node modifiers with a set "Automatic"-flag within a GUI (yes, this all way planned over years *g*)
- "DockWidgetSceneRenderer" & "DockWidgetObject": Usability: Resize the first tree view column given to the size of its contents



>> 08.01.2012
[SW]
PLFrontendQt:
- Added FilterWidgetWithFilterTypSelector
- Added fallback icon für the filter type selector icon
- Renamed ClassListSortAndFilterModel to TreeSortAndFilterProxyModel, because this proxy model is useable for all Tree like models/views
- In the DockWidgetSceneGraph the tree can now be filtered with the new FilterWidgetWithFilterTypSelector either bei SceneNode name oder class name



>> 07.01.2012
[CO]
PLFrontendQt:
- Sadly, it appears that Qt's signal/slot mechanisms can't be used without QObject/Q_OBJECT. But we don't want to do a multiple inheritance
  like "class DockWidgetSceneGraph : public QObject, public DockWidgetScene" either because this can cause serious casting issues. Casting may
  work in simple cases... but I just had one of those situations were I wondered for a second why my "DockWidgetSceneGraph" data was messy, tried
  to remove the multiple inheritance at once and the issue was gone. So, we need to add another class just to be able to use Qt's signal/slot mechanisms.
  We can't use an embedded class for this either because Qt's MOC doesn't like this. :/
  -> Added "DockWidgetSceneGraphQObject" and "DockWidgetSceneRendererQObject"
- "DockWidgetSceneGraph": Added "SetSceneContainer"-broadcast
- "DockWidgetSceneGraph" is now asking his colleagues via "GetSceneContainer()" whether or not one of them knows the currently used scene container



>> 06.01.2012
[SW]
- PLFrontendQt: Added ClassListWidget which adds an filter line on top of the data view.
  The used filter widget is a copy of the FilterWidget class used by the Qt designer, with some minor modification.



>> 06.01.2012
[CO]
- "RegEx::Match()": Added early escape test: In case we try matching when we are already at the end of the string, we know the result without doing any matches
PLFrontendQt:
- There's no longer need to tell new instanced RTTI dock widgets about current states they might be interested in. They are autonomously communicating with each
  other and asking their fellows for required information. This way we can add new features without e.g. touching PLViewerQt.



>> 05.01.2012
[SW]
- PLFrontendQt: the items in the ClassInfoModel now shows a proper Tooltip



>> 05.01.2012
[CO]
- Added "Object::SignalDestroyed"-signal which is emitted when the object is destroyed. This means 8 additional bytes per "PLCore::Object"-instance on a 32 bit machine,
  but I was unable to think of any other decent way for this. There are situations were one needs to know when an RTTI object has been killed. An example for such a
  situation is "PLFrontendQt::DockWidgetObject" were the GUI has to be informed about the murder of it's fosterling.
  -> At first I tried the following solution:
    - Within "ClassManager" added
          Event<const Object*> EventObjectCreated;    /**< An object has been created (do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
          Event<const Object*> EventObjectDestroyed;  /**< An object has been destroyed (the object may already be invalid, do not destroy the given instance), if you have another option, don't use this event to get this information in order to keep the internal overhead to a minimum */
    - Within "Object" constructor/destructor added
      Object::Object()
      {
          ClassManager::GetInstance()->EventObjectCreated(this);
      }
      Object::~Object()
      {
          ClassManager::GetInstance()->EventObjectDestroyed(this);
      }
    - This way, the "PLCore::Object"-instance would not have gained 8 bytes more weight... but I assume the runtime overhead would have run faster out of control as I could have
      sayed "bad idea".
- Fixed invalid cast within
  SimpleList<ValueType>::SimpleList(const Container<ValueType> &lstSource, uint32 nStart, uint32 nCount)
  -> GCC found it
- When using "StringBuffer::GetNumOfBytes()" one has now to specify the internal string format. The previous approach was highly dangerous leading in worst case
  bug combination within a buffer overflow.
PLFrontendQt:
- Replaced the "SelectSceneNode" broadcast by the more generic "SelectObject"
- "DockWidgetSceneGraph::QtSlotTreeViewDoubleClicked()" now also reacts on selected scene node modifier
- "DockWidgetObject" supports now the generic "SelectObject" broadcast
- Removed "DockWidgetSceneNode" because there's currently no difference to the more generic "DockWidgetObject"
- "DockWidgetObject" is now using the new "PLCore::Object::SignalDestroyed"-signal
- "DockWidgetSceneRenderer" is now using the new "PLScene::SceneRenderer::EventDestroyed"-event
- "DockWidgetSceneRenderer": When the encapsulated Qt dock widget gets shown, there's a scene renderer refresh when required
- "DockWidgetManager::ShowDockWidget()": "pQDockWidget->raise();" was missing, now the Qt dock widget comes into foreground as indented



>> 04.01.2012
[SW]
- Implemented linux part of System::GetModuleFilenameByMemoryAddress(). It is using the glibc extension dladdr. On a short search it seems that this method
  exists also under Android 2.2 and up and Mac OS X 10.3 and up. Due lack of devel environment for those platform i can't check if this is true
- PLFrontendQt: moved the ClassInfoItemRoles enum back to the header
    The ClassInfoWidget now hides tabs for class items which are empty. And the Items in the tabs are now sorted.
    Fixed adding items for Properties
    Added MOdel items for Constructor and Methods (currently they return the signature given by the GetSignature Method for testing as tooltip)



>> 04.01.2012
[CO]
- "ClassManager": Renamed "GetModule()" into "GetModuleByID()"
- "ClassManager": Added "GetModuleByName()"
- "Module::GetFilename()" now returns a native style path, documented this behaviour
- Added "System::GetModuleFilenameByMemoryAddress()": We give this method a pointer to a memory address located in a certain shared library
  or executable, and we want to know the absolute filename of this shared library or executable.
- "ClassManager::RegisterModule()": Changed signatur parameter "uint32 nModuleID" into "const uint32 *pnModuleID". This way we have the module
  ID as well as a memory address inside the shared library or executable the module is implemented ("memory anchor"). We can now use this memory
  address together with the new "System::GetModuleFilenameByMemoryAddress()" to get the module filename.
  -> At least on Windows, "Module::GetFilename()" no longer returns an empty string for modules directly loaded at program start by the operation system
  -> Currently, the Linux implementation just returns a null pointer (nothing highly dramatical, I have no time to check this on another platform)
- "Frontend": Renamed "SetPositionSize()" into "SetWindowPositionSize()" to make clear that this is about the window, not the client area we're usually
  interested in
- "Frontend": Added "GetWindowPositionSize()", the counterpart of "SetWindowPositionSize()"
PLFrontendQt:
- Review of "ClassInfoModel", "ClassListModel", "HeaderTreeItem": Only the usual code combing to enable my eyes to locate code faster by jumping to usual places,
  no change in functionality
- "ClassInfoModel", "ClassListModel": Fixed Visual Studio 2010 compiler warnings like
    "warning C4482: nonstandard extension used: enum 'PLCore::EMemberType' used in qualified name"
- Added "ClassInfoWidget" & "RTTIBrowserWidget" from an RTTI browser example Stephan Wezel gave me, those are reusable GUI building blocks
- Added "DockWidgetRTTIBrowser" which is just a tiny helper class making it possible to create an RTTI browser dock widget instance at once
    -> WOW, Stephans RTTI browser works like a charm. By using it, it's finally possible (again) to browse through the RTTI in order to see which classes,
       attributes etc. are available. This information is quite useful when manipulating scene files within a text editor, adding user properties within 3ds Max,
       writing scripts... it's a kind of interactive realtime documentation. :D
- RTTI browser: Best to show and work only with class names including namespaces (unique names, this way we also don't have to explain to the user
  technical stuff when to use a namespace and when not, for the user it's just a name :)
- RTTI browser: Everything is derived from "PLCore::Object", expand this level by default when showing the class hierarchy
- "DockWidgetSceneGraph": Send broadcast when double clicked, not clicked. Same behaviour as in RTTI browser or PLViewerQt 3D viewport.
- General GUI titles: It's probably common to use something like "Scene Graph" instead of "Scene graph"
- RTTI browser: Module view: Added module filename within the tooltip (important information so one can see exactly where this modules comes from)
- "Frontend": Methods like "GetMousePositionX()" are now using the central widget of the Qt main window instead of the Qt main window itself. This way there are
  no issues when adding dock widgets to the Qt main window because the frontend itself is only concerned about the central widget and is not interested in the
  GUI stuff around it.



>> 03.01.2012
[SW]
PLFrontendQt:
- Added models for RTTI "browsing"



>> 03.01.2012
[CO]
PLFrontendQt:
- Added project description
- Added PixelLight RTTI dock widget manager
- "DockWidget": By default, when someone is closing the dock widget Qt hides instead of deletes it
  -> We could write
         setAttribute(Qt::WA_DeleteOnClose);	// Delete the dock widget instead of hiding it when someone is closing it
     to change this behaviour, but when "reopening" the previously made changes to the widget layout would be gone and
     we don't want this. So, long story short conclusion, don't change the default behaviour in here.
- "DockWidgetManager": Implemented dock widget broadcast by mirroring the "PLCore::Object"-interface. This is a quite universal way for a communication
  with and between the dock widgets... and e.g. scripts like Lua can participate in the communication...
- Dock widgets: Added first broadcast "SelectSceneNode": A RTTI method which is called when a scene node is selected
- "DockWidget": Added the same communication interface as in "DockWidgetManager", but the emitting dock widget is excluded and one does not have to make
  a dock widget manager test in order to broadcast something. This communication infrastructure is important, so, it has to be as easy to use and robust as
  possible.
- "DockWidgetSceneGraph" & "DockWidgetSceneNode" must take into account that the used scene node can be destroyed at any time
- "SceneGraphNodeTreeItem" (within "SceneGraphTreeModel.cpp"): We must take into account that the used scene node can be destroyed at any time. For now
  I tried to make as few changes as possible to remove the crash in this situation. Added the following comment within "SceneGraphNodeTreeItem::OnDestroy()":
      "Review this situation when the scene node get's killed, update the tree view. Maybe we don't need
       to have an own event handler for each and every tree item and a single one for the whole tree is enough.
       (maybe we just need to know that an item is now invalid due to removal, then rebuild the tree?)"
  so it can be seen what's going on. Currently this results in empty tree view entries, but better than a crash because we can see what happend.



>> 31.12.2011
[CO]
PLFrontendQt:
- "DataModels::SceneGraphTreeModel::GetQImage()": For some reason, "QImage" appears to be BGR instead of RGB although the documentation states otherwise
  (maybe a little/big endian thing?). Double checked "PLGraphics::Image" to ensure it's no bug, and I can't imagine that it's a Qt bug either. Now the icons
  look correct.
- Added "DockWidgetSceneRenderer"
- "DockWidget": Delete the dock widget instead of hiding it when someone is closing it
- "FrontendMainWindow::mousePressEvent(QMouseEvent *)": [HACK] As soon as there's a Qt dock widget there are focus issues?
  -> Central widget has the focus, click in dock widget, click back in central widget and no focus change?
     Even when destroying the dock widget the focus is now completely messed up?
  -> When adding "setFocus()", all those issues are gone... but why is there such an issue in the first
     place? I was unable to find anything in the Qt documentation and other approaches didn't work either. :/
  -> Spend some hours in trying to figure out what's going on, but I finally have to go on and so this current solution must do the job until someone else has
     a better solution or an explanation for this behaviour. Can be tested in "PLViewerQt".
- Another funny Qt dock widget behaviour: Central widget has the focus, moving the mouse to the docked dock widget and dragging it out so that it is floating and
  while doing so the central widget has still the focus, when stopping the action the focus jumps to the dock widget. Why hasn't the dock widget the focus at
  once when clicking with the mouse onto it in order to start the floating step? I'am starting to remember why I don't like to work with GUI stuff. :/



>> 30.12.2011
[CO]
PLFrontendQt:
- Added abstract PixelLight RTTI class "DockWidget" encapsulating a Qt dock widget. While PLFrontendQt already offers several basic building blocks one can use
  within a Qt project, the goal of those RTTI dock widgets is to provide something high level. One can imagine those guys as ready-to-be-used components which
  just need to be instanced to add new dockable features to a Qt main window. A RTTI dock widget has to be as simple as possible in it's usage and e.g. has to
  provide a decent default behaviour. That's why I talked about "high level", they take away a certain amount of freedom, but give you something to see usable
  results at once in a generic way. By writing e.g.
    const PLCore::Class *pClass = PLCore::ClassManager::GetInstance()->GetClass("PLFrontendQt::DockWidgetSceneGraph");
    if (pClass)
        pClass->Create(PLCore::Params<PLCore::Object*, QWidget*>(pQtMainWindow)));
  one has at once a new dock widget within the Qt main window which can be used to work with the default application scene graph. Due to the PixelLight RTTI
  new RTTI dock widgets can be added easily and then e.g. automatically be used within PLViewerQt. For example, within my master thesis I'am going to need
  special GUI elements to e.g. manipulate transfer function. Now, all I have to do is implementing such a new RTTI dock widget and I'am ready-to-go within
  PLViewerQt... and can also reuse those new RTTI dock widgets in other applications as well... :D
  I'am sure that in the end some RTTI dock widgets have to interact with each other. Similar to the intends of Android. Shouldn't be a problem by using the
  PixelLight RTTI, but that's for the next implementation step. For now it was only important to have the fundamental idea up and running to see whether or not it can work.
  Right now it looks like it's working pretty well without being complex... the PixelLight RTTI and Qt are doing all the hard work as well as the basic building
  blocks Stephan Wezel already wrote.
- Added "DockWidgetObject", "DockWidgetScene", "DockWidgetSceneNode" and "DockWidgetSceneGraph" dock widget RTTI classes to have something to start with. Currently
  the interface is quite basic and will be enhanced. I'am sure a lot more of those fellows will follow over time.



>> 30.12.2011
[SW]
PLFrontendQt:
- When setting the start SceneNode for the SceneGraphTreeModel the user can now specify if the start node should be hidden. The same parameter is also added to QPLDebugDialog::SetContext



>> 29.12.2011
[CO]
- "Frontend": The "GetImpl()"-method needs to be public because it might be required to e.g. access the Qt frontend
PLFrontendQt:
- Added missing "ressources.qrc" processing within the Visual Studio project file
- "FrontendMainWindow": To make it possible to add e.g. a menu bar, it's required to render only into the "central widget". By default there's no central widget -
  added "FrontendRenderWindow" for the actual render window and embedded it into "FrontendMainWindow" as central widget.
- "QPLRenderWindow" is now derived from "FrontendRenderWindow"
- "FrontendMainWindow::timerEvent()": When performing the update step, we need to check whether the frontend is still valid and running, if not we have to shut
  down our application
- Added static helper class "ConstructFileFilter" for constructing file filters for "QFileDialog"



>> 28.12.2011
[CO]
PLFrontendOS:
- "FrontendAndroid": "GetX()", "GetY()", "GetWidth()" and "GetHeight()": Lookout! We need to use the current content rectangle of the window, not the window surface
  because the OS may add something like a virtual back-key to the window surface. If we directly use the window surface something like the FPS display on the bottom
  of the screen might be cut off.



>> 25.12.2011
[CO]
- Over the last past days, Stephan reported some issues with RTTI classes being instanced multiple times. A known issue. Added Stephans patches adding some more
  compiler checks and finally did the export/import refactoring discussed some time ago. The required compiler/definition checks are getting more complex
  as we add support for more platforms and compiler versions. PLCore now defines "PL_GENERIC_API_EXPORT" and "PL_GENERIC_RTTI_EXPORT" for export as
  well as "PL_GENERIC_API_IMPORT" and "PL_GENERIC_RTTI_IMPORT" for import. Instead of performing the compiler/definition check in every project, those
  projects should now use this new definitions. Updated the projects performing export/import and removed no longer required files:
    - "PLDatabase": Removed "PLDatabaseLinux.h" & "PLDatabaseWindows.h"
    - "PLMath": Removed "PLMathLinux.h" & "PLMathWindows.h"
    - "PLGraphics": Removed "PLGraphicsLinux.h" & "PLGraphicsWindows.h"
    - "PLInput": Removed "PLInputLinux.h" & "PLInputWindows.h"
    - "PLGui": Removed "PLGuiLinux.h" & "PLGuiWindows.h"
    - "PLRenderer": Removed "PLRendererLinux.h" & "PLRendererWindows.h"
    - "PLMesh": Removed "PLMeshLinux.h" & "PLMeshWindows.h"
    - "PLScene": Removed "PLSceneLinux.h" & "PLSceneWindows.h"
    - "PLEngine": Removed "PLEngineLinux.h" & "PLEngineWindows.h"
    - "PLPhysics": Removed "PLPhysicsLinux.h" & "PLPhysicsWindows.h"
    - "PLSound": Removed "PLSoundLinux.h" & "PLSoundWindows.h"
    - "PLIRC": Removed "PLIRCLinux.h" & "PLIRCWindows.h"
    - "PLJabber": Removed "PLJabberLinux.h" & "PLJabberWindows.h"
    - "PLParticleGroups": Removed "PLParticleGroupsLinux.h" & "PLParticleGroupsWindows.h"
    - "PLSPARK_PL": Removed "PLSPARK_PLLinux.h" & "PLSPARK_PLWindows.h"
    - "PLlibRocket": Removed "PLlibRocketLinux.h" & "PLlibRocketWindows.h"
    - "PLCompositing": Removed "PLCompositingLinux.h" & "PLCompositingWindows.h"
    - "PLGuiXmlText": Removed "PLGuiXmlTextLinux.h" & "PLGuiXmlTextWindows.h"
    - "PLFrontendPLGui": Removed "PLFrontendPLGuiLinux.h" & "PLFrontendPLGuiWindows.h"
    - "PLDatabaseSQLite": Removed "PLDatabaseSQLiteLinux.h" & "PLDatabaseSQLiteWindows.h"
    - "PLDatabaseMySQL": Removed "PLDatabaseMySQLLinux.h" & "PLDatabaseMySQLWindows.h"
    - "PLDatabaseNull": Removed "PLDatabaseNullLinux.h" & "PLDatabaseNullWindows.h"
    - "PLDatabasePostgreSQL": Removed "PLDatabasePostgreSQLLinux.h" & "PLDatabasePostgreSQLWindows.h"
    - "PLScriptV8": Removed "PLScriptV8Linux.h" & "PLScriptV8Windows.h"
    - "PLScriptPython": Removed "PLScriptPythonLinux.h" & "PLScriptPythonWindows.h"
    - "PLScriptNull": Removed "PLScriptNullLinux.h" & "PLScriptNullWindows.h"
    - "PLScriptLua": Removed "PLScriptLuaLinux.h" & "PLScriptLuaWindows.h"
    - "PLScriptAngelScript": Removed "PLScriptAngelScriptLinux.h" & "PLScriptAngelScriptWindows.h"
    - "99TestPlugin": Removed "99TestPluginLinux.h" & "99TestPluginWindows.h"



>> 20.12.2011
[CO]
- "String"-class: Added "String &Insert(char nCharacter, uint32 nPos)" and "String &Insert(wchar_t nCharacter, uint32 nPos)" (there were already such
  "Replace()"-method variants)
- Bugfix within script implementation "PLScriptLua::RTTIObjectPointer::NewIndexMetamethod()": We can't just use "lua_tostring(pLuaState, 3)" because Lua
  will give us e.g. for a boolean type just an empty string, meaning that within a Lua script something intuitive like "MyRTTIObject.MyBooleanAttribute = true"
  would not work. Handled this Lua behaviour.



>> 15.12.2011
[CO]
- "Url": Added more examples within the documentation in order to be able to understand what the URL-class will do with provided data
- "System::GetCurrentDir()": Enhanced documentation to make it possible to understand it's behaviour
- When Thomas Mühsam worked on PLInstall, he noticed that the behaviour is different across multiple methods dealing with filenames and
  paths. I finally took the time to have a look into it by documenting behaviour of some methods in more detail and adding more examples.
  One typical confusion is whether there's a "/" at the end of a path - this is usually up to the user and e.g. the "Url"-class will not force
  a certain approach onto the user. Another confusion is whether not not there has to be a "file://" for every local path. This is another thing
  handled by the "Url"-class. For example "Url::CutFilename()" will omit the protocol for a local path (e.g. the result will not be
  "file://C:/Programs/App/"). I was unable to find an explanation for this within the documentation or diary, but I'am sure there's a good
  reason for this. Changing the behaviour of such a fundamental class on the fly is a no go, so I don't touch this right now. The overall
  URL handling in PixelLight is determined by the "Url"-class and other components of PixelLight should not try to break with "Url"-class behaviour.
- Reviewed the relatively new "Runtime"-class and ensured that the different methods return the paths in the same format
- "Runtime": The "Data"-methods no longer have a "/" at the end to have a similar behaviour across this class
- "LogFormatterText::Open()": Reverted the change from "19.10.2011", UTF8 within logs is trouble we best avoid... there are tools out there still
  having issues with UTF8 and UTF8 is in general more complex and for a simple text log those additional efforts and troubles are not justifiable. Wrote
  a hint into the first log line so that no one wonders when a cryptic Unicode character from a none English language doesn't show up correctly.



>> 10.12.2011
[CO]
- "MemoryManager": Made the methods inline in order to give the compiler a chance to optimize out function calls. Of course, for this it's required to include
  "standard"-headers into PixelLight headers which is potentially dangerous when it comes to cross-platform because usually this makes at least on one platform
  problems in a certain header include combination. But these memory operations are totally basic building blocks, same topic as in PLMath diary entry "15.11.2011"
  regarding to the "PLMath::Math"-class with fundamental math building blocks. So, this must be worth the rest. It's still better then directly using the
  "standard"-function because in case there are serious issues on a platform in the future, it's quite easy to resolve them because only this one header has to
  be touched. I added as usual a long comment explaining why this header is including "standard"-headers and also a long dirary entry so everyone can see that
  this isn't an inline-mood. :D
-> By the way, the first PixelLight diary, this one, just reached 10.000> lines... sure, there are spaces and one could play around with the line size, but hey,
   10.000> lines. Took just 9> years...
- Reviewed commit 1786dd0e5be679c566891d5aae62a6c38771df50 (see PLCore diary entry "03.12.2011")
  -> Looks fine in general, except that "PLCore::System" is already providing the required information, removed "ARCHITEXTUREANDBITSIZE_STRING" definition
  -> "LinuxCommon.cmake" was using "CMAKETOOLS_TARGET_ARCH" while it should have used "CMAKETOOLS_TARGET_ARCHBITSIZE"
  -> "PLCore::Systen::GetPlatformArchitecture()" returns for instance 'x86', 'x64', 'armeabi', 'armeabi-v7a' and so on (as extensively documented). Yes, the
     technical proper name for x64 would be "x86 architecture with 64 bit extensions", but that's far to technical and something like "x86_64" is more difficult
     to read and name during a conversation as the marketing term "x64". That's why e.g. the runtime subdirectory is named "x64", not "x86_64".



>> 07.12.2011
[CO]
- "SystemAndroid": Added "GetAndroidApp()" and "SetAndroidApp()"
- "SystemAndroid": Made some methods inline



>> 06.12.2011
[CO]
- While adding more unit tests, Jens Schmer found another bug within the container classes. When down resizing an full array, the number of elements within
  the array was not the new maximum number of elements, it was the new maximum number of elements -1. Interessting that this never caused any problems. Cool
  that we now have someone testing thru the classes in detail via unit tests. :D
- The implementation of "Class::GetDerivedClasses()" was
	const List<const Class*> Class::GetDerivedClasses() const
	{
		// Get list of derived classes
		List<const Class*> lstClasses;
		ClassManager::GetInstance()->GetClasses(lstClasses, m_pClassImpl->GetClassName(), NonRecursive, NoBase, IncludeAbstract);
		return lstClasses;
	}
  -> This is clearly quite ineffective, especially because it's a linked listed. Changed the signature of this comfort method into
     "void GetDerivedClasses(List<const Class*> &lstClasses) const"
     meaning that there is no longer a temporary coping around and such a signature is not totally unusual.
  -> Within PixelLight itself, this method is never used, so, no other updates were necessary



>> 03.12.2011
[SW]
- The GetRegistryDirectory Method checks if the path read from the "registry" exists and returns an empty string if not.
  Under linux added ARCHITEXTUREANDBITSIZE_STRING define which holds the architecture and bitsize string (e.g. x86 for 32bit x86 code or x64 for 64bit x86 code).
  The string from this define gets appended to the standard install paths of pixellight.



>> 03.12.2011
[CO]
- More inline within PLCore: "String", "Class", "ClassImpl", "ClassManager", "MemberDesc", "Module", "DynEvent", "EventDesc", "EventHandlerDesc", "ConstructorDesc",
 "FuncDesc", "ParamsParser", "ParamsParserXml", "VarDesc", "ApplicationContext", "CoreApplication", "Config", "Frontend", "FrontendApplication", "FrontendContext",
 "FrontendImpl", "Log", "LogFormatter", "LogFormatterHtml", "Buffer", "Connection", "Host", "Socket", "SocketAddress", "HttpClient", "HttpHeader", "Registry",
 "ScriptManager", "Runtime", "Pipe", "Process", "Chunk", "CommandLine", "CommandLineOption", "HTMLParser", "Loadable", "LoadableManager", "LoadableType", "Loader",
 "Localization", "LocalizationGroup", "LocalizationText", "ProfileGroupElement", "Time", "Version", "XmlAttribute", "XmlBase", "XmlComment", "XmlDeclaration",
 "XmlDocument", "XmlElement", "XmlNode", "XmlText", "XmlUnknown"



>> 30.11.2011
[CO]
- PLFrontendOS: Added empty "OSWindowMacOSX"-class as start point for the Cocoa (Objective-C API) port (X11 can be used on Mac OS X, but it's best to avoid using it
  to avoid compatibility trouble)
- PLFrontendOS: Renamed "XDnDFileDropHelper" into "Linux_XDnDFileDropHelper" to make clear that this helper class is Linux related



>> 29.11.2011
[CO]
- Feature request "ID: 3443487" (http://sourceforge.net/tracker/index.php?func=detail&aid=3443487&group_id=507544&atid=2063685): Added critical section support to
  the mutex implementation. This is a Windows specific thingy:
  - "Mutex":            Lock/unlock across multiple processes
  - "Critical Section": Lock/unlock only inside the same process
  -> Default has to be "Mutex" to be on the safe universal side
- PLFrontendQt: Visual Studio project file: Disabled annoying "warning C4127: conditional expression is constant"-warning, it's within the Qt
  headers were we can't change anything in there :/
- Added "CriticalSection"-class, a simple comfort class derived from mutex
- "FileObject", "File", "Directory", "Url", "System", "DynLib", "Mutex", "Semaphore", "Thread", "FileSearch", "Timing", "Tokenizer", "RegEx": Everything reasonable
  to be inline is now inline to give the compiler a chance to optimize out expensive function calls. I'am sure that over the time more of such changes will follow.



>> 26.11.2011
[CO]
- As feared yesterday, my "Socket::GetNumOfWaitingBytes()"-method wasn't really correct. As mentioned, my network topic experience is near to zero and to be honest,
  I don't have the time to get into it in detail because I already have to manage all other topics at once. Sadly, my day has only 24 hours - so, we have to rely on
  teamwork to get everything done. That's why I'am totally happy that within the bug tracker there's response (ID: 3442166) pointing me into the right direction. :D
  -> Renamed "Socket::GetNumOfWaitingBytes()" into "Socket::IsDataWaiting()"
- Bugfix (ID: 3442054 - http://sourceforge.net/tracker/index.php?func=detail&aid=3442054&group_id=507544&atid=2063682 ): "PLCore::Connection::Receive()" called
 "PLCore::Connection::OnReceive()" with the fixed buffer size, instead of with the number of received bytes
    -> Also reviewed this class and checked whether or not the comments are detailed enough
- While working on PLUnitTests, Jens Schmer noticed several issues and inconsistencies. I asked him to mark everything he's noticing, not only real bugs, but also
  usability stuff like when a method behaves another way as expected when reading the method name and documentation. I try to have a look at each point, one
  after another without, hopefully, breaking anything or introducing new issues.
  -> "Container"-class: Have a look at the following methods:
    virtual ValueType &Add() = 0;
    virtual ValueType &Add(const ValueType &Element) = 0;
    virtual ValueType &AddAtIndex(int nIndex) = 0;
    virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;
    The last one has another return value as the other methods. That's definitly unexpected. Changed "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;"
    into "virtual bool AddAtIndex(const ValueType &Element, int nIndex) = 0;". As far as I can see, this method is never used, so, it should be safe to make this change.
  -> "Container"-class: Making a container to a copy of an empty container didn't work, the result has to be a empty container
  -> "Container"-class: Using the "Compare()"-method with two empty containers returned 'false' instead of 'true'



>> 25.11.2011
[CO]
- There's a first feature request at http://sourceforge.net/tracker/?group_id=507544&atid=2063685 "Socket::IsArrivalData() - ID: 3439371"
  -> I waited several days to give other team members the option to handle the request, but I'am sure that it's no good idea to have such open minor feature
     requests for several weeks...
  -> Added "Socket::GetNumOfWaitingBytes()" returning the number of bytes waiting to be received (non-blocking request)
  -> I have only a little bit of experience in network related topics, so, if I totally messed it up please tell me :D
- "PLFrontendOS::FrontendAndroid()": It's now required to provide the constructor with a frontend context instance. This way, it's e.g. possible to tell
  the frontend about the RTTI class name of the application to start.



>> 24.11.2011
[CO]
- Bugfix: "PLCoreLinux.cpp": The implementation of "wcscasecmp" and "wcsncasecmp" was broken (Mac OS X or Android don't have such primitive "standard" functions)
  -> "wcscasecmp": http://linux.die.net/man/3/wcscasecmp states
     "The wcscasecmp() function returns zero if the wide-character strings at s1 and s2 are equal except for case distinctions. It returns a positive integer if s1
      is greater than s2, ignoring case. It returns a negative integer if s1 is smaller than s2, ignoring case"



>> 16.11.2011
[CO]
PLScriptBindings:
- Exposed "PLCore::ClassManager::ScanPlugins"-feature to scripts
- Exposed "PLCore::System::GetPlatformArchitecture"-feature to scripts
PLScriptLua:
- Bugfix: "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Boolean and string values were not handled correctly



>> 13.11.2011
[CO]
- Thomas Mühsam noticed that "System::GetCurrentDir()" returned, unlike many other methods, a native style instead path of an uniform style path and also sayed that
  this makes directly comparing paths impossible (this resulted in a discussion about interfaces :). It's first required to check in which form the given path is,
  and then converting them into an universal form so they can be compared. Searched the PLCore diary for the reason why this method is returning a native
  style path... it turns out that over the years, this had been changed multiple times:
  - "17.04.2008": I changed it from native to uniform with the argument now also Thomas Mühsam mentioned
  - "03.08.2010": Stefan Buschmann changed it from uniform to native form, I wasn't able to find an explanation for the change, but I'am sure there's a good one
    (no offence, I just try to understand changes in order to avoid a continues back and forth change and questions over the years)
  -> Because there were now issues and discussions, again, about the representation of paths, I reviewed the topic. The change from "03.08.2010" was probably done
     to keep everything as "close-to-metal" as possible, to avoid dozens back and forth conversion. While "it's always uniform across all platforms" would be nice
     for the API user, it wouldn't be that good in respect of the overal performance and the user wouldn't have a chance to influence this. Were not already done,
     documented the methods "passing thru" native style path.
- "SystemWindows::GetCurrentDir()" & "SystemLinux::GetCurrentDir()" were using "Url(sDir).GetNativePath()" while other similar methods directly returnd the OS style
  path wihouth touching it, changed it
- Linux port: Added several "String::FromUTF8()" when passing an OS "char"-String through the interface to don't loose Unicode data. Would be nice if someone could
  review this and similar places to ensure that we never convert an Linux UTF8 string into an ASCII string by accident...



>> 12.11.2011
[CO]
- "PLScriptV8" & "PLScriptAngelScript" & "PLScriptPython" & "PLFrontendMozilla" & "PLFrontendActiveX": Updated x64 Visual Studio project settings



>> 11.11.2011
[CO]
- "PLFrontendQt" & "PLFrontendPLGui" & "PLFrontendNull" & "PLScriptBindings" & "PLScriptNull" & "PLScriptLua": Updated x64 Visual Studio project settings



>> 04.11.2011
[CO]
- Fixed bug 3433006 (http://sourceforge.net/tracker/?func=detail&aid=3433006&group_id=507544&atid=2063682): The return value of "FileObject::GenericMove()"
  and "FileObject::GenericCopy()" was always "false"
- I had to add "GetInstance()" and "HasInstance()" to the interfaces of singleton implementations. This solution enhances the compability with legacy compilers
  like GCC 4.2.1 used on Mac OS X 10.6.
  -> The C++11 feature "extern template" (C++11, see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates) can only be used on modern compilers like GCC 4.6
  -> We can't break legacy compiler support, especially when only the singletons are responsible for the break
  -> See PLCore::Singleton for more details about singletons
- Removed the "compiler, please keep my symbols"-hacks (see e.g. PLCore diary entry 23.10.2011), after the change from above, they are no longer required



>> 02.11.2011
[CO]
- "System"-class: Added "GetPlatformArchitecture()"
- String implementation: "ResetLocaleToC()": In case the current set locale is already "C" (the default if no one has messed around with the current set
  locale), we don't have to do anything



>> 01.11.2011
[CO]
- "Runtime"-class: Added "SetDirectory()" and "GetPLCoreSharedLibraryDirectory()", made "GetPLCoreSharedLibraryName()" public



>> 31.10.2011
[CO]
- "NULL_HANDLE" and "INVALID_HANDLE" are no longer classic definitions, instead they are now constants of the type "PLCore::handle" to give the compiler
  the chance to perform a type check
- Fixed bug 3431174 (http://sourceforge.net/tracker/index.php?func=detail&aid=3431174&group_id=507544&atid=2063682): Within the "PLCore::System"-constructor,
  the main thread was created incorrectly. Also reviewed the thread constructors.
- "System"-constructor cleanup: Removed "[HACK] Force the linker to keep the "Profiling"-class (don't strip it away)" because it's now within "PLCore.cpp"
  together with the rest of the same issues (see PLCore diary entry 23.10.2011)



>> 27.10.2011
[CO]
- "System": Added "GetSharedLibraryPrefix()" and "GetSharedLibraryExtension()"
- Added "SystemMacOSX" which is derived from "SystemLinux"
- "SystemWindows::GetPlatform()" now returns "Windows" instead of "Win32"/"Win64" to make it similar to "Linux", "Android" and "MacOSX". I try to avoid
  such breaking changes, but this one was necessary do deal with all the supported platforms in an uniform way.
- "System": Added "GetPlatformBitArchitecture()"
-> It's hightly recommended to make a clean build of PixelLight in order to avoid issues when using plugin files from before this change



>> 26.10.2011
[CO]
- "SystemLinux::GetPlatform()" & "SystemLinux::GetOS()": Added Mac OS X handling (it's not worth to derive an own class, yet)
- "ScriptManager::CreateFromFile()": Enhanced the method documentation in order to avoid problems like the one at
  http://dev.pixellight.org/forum/viewtopic.php?f=6&t=103



>> 25.10.2011
[CO]
- "Runtime::GetSystemDirectory()": We really need to check for the registry, first: When building for Linux, there are fixed build in locations like
  "/home/bob/pixellight/cmakeout/Base/PLCore/" and build executables will link against those shared libraries -> You'll receive
  "/home/bob/pixellight/cmakeout/Base/PLCore/" as PL system directory, not e.g. "/home/bob/pixellight/Bin-Linux/Runtime/x86" as expected.



﻿>> 23.10.2011
[CO]
- Interesting, just tried to build PixelLight on MS Windows by using CMake to create the Visual Studio projects files and then, as usually build PL with VC...
  but within PLMath the linker told me that a few "PLCore::Log" singleton symbols were missing. They were stripped way... I double checked the compiler
  settings, but they look the same, meaning the one created by CMake and the one within the Git repository I'll use during the development. Interesting,
  same compiler, same settings, but different results (maybe it's the order in which the files are compiled? :). Added the "usual hack" within "PLCore.cpp"
  to force the compiler to keep the required symbols.
- Implemented "DynLibLinux::GetAbsPath()"



>> 22.10.2011
[CO]
- "EventDesc::GetSignal()" & "EventHandlerDesc::GetSlot()" & "VarDesc::GetAttribute()": Gave in a null pointer into the not documented
  pointer parameter and got a crash. This should never happen. Changed the pointer parameter into a reference parameter.
- "VarDesc": Added "GetDefault()"-method to make it possible to request the default value of an attribute without the need to have an attribute
  instance in order to get this information
- "Object": Added "SetAttribute(const String &sName, const DynVar *pVar)". This is a comfort method allowing to write e.g.
    pFirstObject->SetAttribute("MyAttribute", pSecondObject->GetAttribute("MyAttribute"));
  instead of
    DynVar *pDynVar = pSecondObject->GetAttribute();
    if (pDynVar)
      pFirstObject->SetAttribute("MyAttribute", *pDynVar);
    In case there's no such attribute in "pSecondObject", nothing happens at all.



>> 21.10.2011
[CO]
- More Unicode related issues within the PixelLight forum: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=91
  -> The next scheduled PixelLight release is in two days, so no big complete refactoring of for example the tokenizer.
     Only implementation completion and minor required updates.
  -> "BufferedReader": Added "GetStringFormat()"
  -> "BufferedReaderFile::ReadFromStream()": Implemented Unicode support
  -> "BufferedReader": "GetChar()" & "ReadChar()" now return "int" instead of "char" (identical to "File::GetC()")
  -> "Tokenizer::GetNextToken()": Implemented Unicode support
  -> Optimization: "Tokenizer::StreamIsChar()" read again from the string, although the current character was already available.
     Removed this function.



>> 20.10.2011
[CO]
- Exposed "ApplicationContext" to the RTTI
- "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()": On Android, those are empty strings and just writing e.g.
    cApplicationContext.GetAppDirectory() + "/Data"
  resulted within "/Data", which was not correct. When working on the Android port, I catched this case and used e.g. "Data" in
  case the application directory was empty. Now that the Android port is working, I'am cleaning up and removing situations resulting
  in to many stuff to take into account when using the PixelLigth API. In case "System::GetCurrentDir()" & "ApplicationContext::GetAppDirectory()"
  have internally an emtpy string, '.' is returned meaning that
    cApplicationContext.GetAppDirectory() + "/Data"
  will result in "./Data" which is fine.



>> 19.10.2011
[CO]
- "FileWindows::PutS()" didn't take Unicode into account (... as well as some other functions in this class...)
- "File::Open()": Added string encoding format parameter
- Text based log formatter implementations are now using UTF-8 instead of ASCII
- "File::GetContentAsString()": Removed string encoding format parameter because it's now defined by "File::Open()"
- "File::GetContentAsString()": Added UTF8 support
- "LoadableManager::OpenFile()": Added string encoding format parameter
- "ScriptManager::CreateFromFile()": Added string encoding format parameter
- Fixed spelling error: "LogFormater" -> "LogFormatter"



>> 16.10.2011
[CO]
- "Socket": Fixed "warning C4244: 'initializing' : conversion from 'SOCKET' to 'int', possible loss of data" when compiling for 64 bit



>> 15.10.2011
[CO]
- "Object::SetAttribute(const String &sName, const DynVar *pVar)" & "DynVar::SetVar(const DynVar *pValue)" & "Type<T>::ConvertFromVar(const DynVar *pValue)":
  It was not documented whether or not "pValue" can be a null pointer, in case one passed into a null pointer it just crashed. This is not obvious to
  the API user. Changed it into a reference to make clear that it must be valid.
- "ClassReal::~ClassReal()" & "ClassReal::DeInitClass()" & "ClassManager::~ClassManager()": The class manager may have already been destroyed (random static
  de-initialization order), we need to take this situation into account



>> 14.10.2011
[CO]
- The extern template related changes I did yesterday solved my linker issue on Mac OS X. It turns out that on the Linux port, the extern
  template usage was not correct and caused multiple template instances all over PLCore. Tested it on Linux and Mac OS X as well as Windows, no
  more issues. :D
- New platform, new data type issues: "handle" was defined by using "unsigned long" on Linux and "unsigned int" on MS Windows. Now it's
  "unsigned __int32" on 32 bit, "unsigned __int64" on 64 bit, on all platforms. I hope this is causing less issues across multiple platforms and
  bit sizes.
- "Thread::GetID()" now returns "handle" instead of "uint32" (e.g. on MS Windows, "HANDLE" is a pointer... so 32 bit might not do the job)



>> 13.10.2011
[CO]
- When linking PLCore on Mac OS X, the linker complains about multiple symbols for "Singleton<Log>" and fails to link.
  After a day of stumbling around on the unfamiliar Mac OS X, I had no real glue what's going on... because the Apple GCC 4.2 is heavily
  out-of-date I compiled GCC 4.6.1 for the used system, and supected that the out-of-date Apple ld linker caused this problem (so I played
  around with GNU binutils etc). After talking with Stephan Wezel about the observed issues, he gave me the tip to check whether the "extern"
  in front of "template class" is really there when compling the source code under Mac OS X. So, I first read some more stuff about C++11
  extern template, looked how it's currently used... and the usage looked wrong. Under Linux (the Mac OS X port is just reusing the
  Linux port :), when compiling PLCore, there was no "extern" in front of "template class", and I guess that this means that everywhere this
  header was included, a new singleton template instance was created (just inside PLCore!) - this would at least explain why the Apple linker
  complained about multiple instances. Changed it. At this time, the changes are only tested on MS Windows. Tomorrow I'll do more tests and
  really hope that this solves the issue.



>> 11.10.2011
[CO]
- Yesterday, a fellow student had isses to get PixelLight up and running - as it turns out, there were PixelLight runtime configuration issues, again.
  Just like within the forum post http://dev.pixellight.org/forum/viewtopic.php?f=6&t=68 the MS Windows PATH environment variable was set correctly... but
  the registry key was missing. So, while the MS Windows PATH environment variable is usually no big deal and there's not really a way around it, this
  mandatory registry key on the other hand is a constant source of errors and frustration. So, I had a look into it.
  As it turned out, I already had a solution at "18.08.2011" but didn't see at this time that this also could be used to make the mandatory registry key
  only optional. The "Runtime::GetSystemDirectory()"-method is now also using the PLCore shared library in order to find the PixelLight runtime directory.
  Only when using a static version of PLCore, we have to use the registry key as last available option. Usually the dynamic shared library of PLCore is used,
  and so there's usually no need for this registry key and no problem in case it's not there.



>> 07.10.2011
[CO]
- "Runtime::ScanDirectoryPluginsAndData()" & "Frontend::Run()": In case of a total failure, there's now also the hint
    "Is the PixelLight runtime registered correctly? (see e.g. "PixelLightBuild.pdf" for details)"
  within the message to give at least a hint what's usually wrong when this failure happens. Of course, this means that an end-user will see this message as well... but
  on the other side, when delivering an application, the PixelLight runtime is usually directly put in the same directory as the executable so that everything can be found
  (= no chance that this message can occure).



>> 05.10.2011
[CO]
- Loadable: Renamed "Load()"-method using a filename into "LoadByFileame()"
- Loadable: Renamed "Save()"-method using a filename into "SaveByFileame()"
- Loadable: Renamed "Load()"-method using a file into "LoadByFile()"
- Loadable: Renamed "Save()"-method using a file into "SaveByFile()"
-> This change was necessary to make it possible to expose this methods to the RTTI (method names must be unique for this)
-> I fist thought about just renaming the file versions, but in the end I decided to be consiquent even if the method is now a little bit longer... but therefore one
   can guess what the method expects as parameters (and it's consitent to "GetByIndex()" & "GetByName()" and so on).
- PLFrontendOS: Added Android frontend (still some details to hammer out)



>> 04.10.2011
[CO]
- Windows: PLFrontendQt includes simplification: "Include\Qt" instead of "Include\Qt\Qt" (when building Qt, an additional install step was required to make real Qt headers,
  not headers just redirecting into the "src"-directory)
- "ClassReal::InitClass()" and "ClassDummy::InitClass()" didn't register the properties of the base class as expected. While all methods and so on from the base class and
  the base class of the base class and so on were registered, only the "own" properties of the base class were added to a derived class. Meaning that a derived class was missing
  properties of the base class it's base class was derived from. This looks like a bug (if it's no bug, it's a odd behaviour). Fixed it.
  (noticed it when implementing "PLAssimp::MeshLoader" and "PLAssimp::SceneLoader")



>> 27.09.2011
[CO]
- More fine tuning on "PLFrontendOS" & "PLFrontendQt" & "PLFrontendPLGui": When making the window visible, it's now also made active at once. If this is not done, debugging
  in Visual Studio doesn't make that much fun because the frontend window appears, a breakpoint is reached - but Visual Studio doesn't automatically come into foreground and
  gets the focus, the frontend window is still on the top and you may even not notice that you've reached a breakpoint. I think, when implementing the frontends, I delayed
  the window activation until everything is initialized so e.g. input controls are correctly activated/deactivated when the window gets active/inactive. Due to the progress
  in frontend fine tuning, this delay is no longer required.
- "DynLibLinux::Load()": If a shared libarary failed to load in dynamically, the application completly shut down. Fixed that.



>> 26.09.2011
[CO]
- "LoadableManager::OpenFile()" now resolves "./" because we always want to work with absolute paths so the user can easily figure out the absolute path later on by using "cFile.GetUrl()"
- "FrontendApplication::OnInitData()" & "CoreApplication::OnInitData()": The application and current directories should have the highest priority of all base directories because the application data is
  most likly in those directories



>> 16.09.2011
[CO]
- Added "ConsoleAndroid" which is derived from "ConsoleLinux" and just overrides the "Print()"-implementation. Even on Android, it's possible to write into the console, meaning "stdout"... but it's somewhat
  complicated to "see" this output when starting an apk file (meaning: not starting an native application via shell). In this console implementation, messages are not only written into the console,
  the Android in-kernel log buffer is used as well (use Androids "logcat" utility to access this system log).
- "SystemAndroid" now also overrides "GetConsole()" in order to make it possible to toggle the used console implementation ("ConsoleAndroid"/"ConsoleLinux")



>> 14.09.2011
[CO]
- Android port: Added "FileSearchAndroid" implementation
- Bugfix (Linux): "PLFrontendOS::OSWindowLinux::GetX()" & "PLFrontendOS::OSWindowLinux::GetY()" were not returning the window position correctly (window decoration issue). Tested it now several times,
  and when restarting an application, the previous window position and size is now restored correctly (even when using two monitors).



>> 13.09.2011
[CO]
- Bugfix: "PLFrontendOS::OSWindowWindows::SetPositionSize()": The MS Windows function "MoveWindow()" sets the window size, not the window client area size
  -> We have to calculate this window size basing on the given client area size
- Bugfix: "PLFrontendPLGui" was not returning and setting the window size correctly (the window border must be ignored)
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "Frontend::Run()": By default, this method is now allowed to show an urgent message to the user in case of a failure (see also dirary entry "23.08.2011")
- Android port: "SystemLinux::UrgentMessage()" writes into the Android kernel log buffer
- Added "SystemAndroid" which is derived from "SystemLinux". In here, an "AAssetManager"-instance can be set for example by the Android frontend and received
  for instance by a special Android file implementation.
- Added "FileAndroid" using the Android asset manager (implementation is not yet tested)



>> 12.09.2011
[CO]
- "String"-class: Do never ever pass a null pointer into "strdup" because the behaviour isn't specified in POSIX (http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html)
  -> On MS Windows and Linux a null pointer will be returned, on Android it just crashes...
- "Log"-class Android: In verbose mode, messages are not written into the console (there isn't easy access to it on Android), instead the Android in-kernel log buffer is used (use Androids "logcat"
  utility to access this system log)



>> 06.09.2011
[CO]
- Android port related: The Android NDK has no support for "mbtowc()", added the implementation from http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbtowc.c
  http://bsd.unixdev.net/4.5BSD/src/usr.libexec/dictd/mbrtowc.c



>> 05.09.2011
[CO]
- The Intel C++ compiler has no support for nullptr + fixed some issues detected by this compiler
- Fixed "warning #82: storage class is not first"-warnings of the Intel C++ compiler when using warn level 4



>> 04.09.2011
[CO]
- When building with CMake, it's now possible to disable the ZIP support in order to remove the zlib external dependency. Please note that it's *not* recommended to disable the ZIP
  support and this option does only exist to make it easier to create minimal builds which are really helpful when starting with a new platform support. In such a situation, it can
  be really frustrating to deal with external dependencies when you just want to make the first step and want to see "anything" - but just can't because you first have to compile
  the external dependencies and pray that you did everything correct: Correct compiler & linker settings, e.g. correct ARM architecture and so on. If e.g. any linker issue occur,
  and you don't use any external dependency at all (in theory, at this very moment there's still the libpcre external depencency, at least at the moment) - you know that the problem
  is somewhere within your project and not within an external dependency. :D



>> 31.08.2011
[CO]
- Android port related: "MutexLinux::TryLock()":  There's no implementation of "pthread_mutex_timedlock()" within the Android NDK, even if the function is listed within the headers.
  Depending on the API level, it's defined out, meaning no compiler error when using API level 8, but a compiler error when using API level 9 (some sources stating this is an error
  within the shipped "pthread.h"-header). For Android, we have to fallback to "pthread_mutex_lock()" (right now, I don't want to spend hours to find a work around).



>> 30.08.2011
[CO]
- Android port related: Even if there's a "wchar.h"-header, wchar_t is officially not supported by Android (no problem, wchar_t is for Windows, UTF-8 for Linux and the string
  class handles both as well as ASCII). Added a "wcscasecmp()" & "wcsncasecmp()" implementation within "PLCoreLinuxWrapper.h" & "PLCoreLinux.cpp" used when compiling for Android.
- Android port related: "PLCoreLinux.cpp": The Android NDK has no support for "wcstof()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstof.c
  with minor adjustments to make it compile (no time to reimplement something on my one, and it's also not worth it, there's other stuff to do instead of reimplementing
  the c standard library...).
- Android port related: The Android NDK has no support for "wcstoumax()". Added the implementation from http://www.opensource.apple.com/source/Libc/Libc-320/locale/FreeBSD/wcstoumax.c
  with minor adjustments to make it compile.
- Android port related: "PLCore/ConsoleLinux.cpp": The Android NDK has no "term.h", but "termios.h" works (validating Linux build next time when I switch the OS, but not at this very
  moment and not for every minor change, even when a change breakes something under Linux for a short period)
- Android port related: "PLCore::ThreadLinux::Terminate()": "pthread_cancel()" is not supported by the Android NDK. "android-ndk-r6/docs/system/libc/OVERVIEW.html" states:
  "pthread_cancel() will *not* be supported in Bionic, because doing this would involve making the C library significantly bigger for very little benefit."



>> 29.08.2011
[CO]
- "Core/MemoryManager.cpp": For "memcpy()" etc. "string.h" has to be included when compiling for Android (wow, now I'm glad that we even encapsulated such primitive functions,
   else there would be more than just this file to update...)
- Android port related: "ConsoleLinux::ClearScreen()" in here, we don't need to use the curses library and can go a more portable way
- Android port related: "ConsoleLinux::GetCursorPosition()" & "ConsoleLinux::SetCursorPosition()": There's no native curses library on Android, and compiling one
  just for this usually never used function would be overkill. So, right now, those two methods are not supported when using the Android port (already spend far too much
  time on this curses library issue!).



>> 23.08.2011
[CO]
- Qt: It appears that there's going something funny on in here... The PixelLight Linux external packages of Qt Stephan Wezel created, don't need the "src" because the includes
  are real includes and not just references. When downloading the Qt sources and looking into e.g. "Qt\4.7.1\include\QtCore\qvector.h" I see "#include "../../src/corelib/tools/qvector.h".
  When now building Qt on MS Windows using the options
    "configure -platform win32-msvc2010 -release -opensource -fast -sse -sse2 -no-qt3support -no-scripttools -no-stl -nomake examples -nomake demos -no-openssl -no-webkit -no-phonon -no-style-motif -no-style-cde -no-style-cleanlooks -no-style-plastique -no-sql-sqlite -qt-style-windowsvista -D NOMINMAX -D VC_EXTRA_LEAN -D WIN32 -D _WINDOWS -D _CRT_NONSTDC_NO_WARNINGS -D _CRT_SECURE_NO_WARNINGS -D _CRT_SECURE_NO_DEPRECATE -D _CRT_NONSTDC_NO_DEPRECATE -D _ATL_SECURE_NO_DEPRECATE -D _CRT_NON_CONFORMING_SWPRINTFS -D STRSAFE_NO_DEPRECATE -D _UNICODE -D UNICODE"
  I still see the same within the include files, and no new, modified includes appeared. I can copy out the files from "Qt\4.7.1\src\" - but this seems odd. If this would be the
  preferred way to use Qt, why is there an include directory in the first place? Did I messed up with the Qt compile configuration? Does the Qt build system handles things in another
  way under Linux? Maybe the includes are handled during "install" on Linux? So, until it's clear what's going on, we need to use OS dependent handling. :/
  (no time right now to spend hours with this issue)
- "System": Added "UrgentMessage()"-method for a primitive way (e.g. by using a message box) to be able to tell the user that something went terrible wrong
- "Runtime::ScanDirectoryPluginsAndData()": By default, this method shows an urgent message to the user in case of a failure



>> 21.08.2011
[CO]
- Renamed "PLCore::CoreGeneralConfig" into "PLCore::CoreConfig"
- "Frontend": Added "GetX()" & "GetY()"
- "Frontend": Added "SetPositionSize()". "Frontend::SetPositionSize()" will do the rest of the job like checking for minimal size, ensuring that the frontend is always within
  the screen when using this method and so on.
- "FrontendApplication": By default, this application implementation will automatically restore the frontend position and size of the previous session. Although an application
  shouldn't care about the frontend, from the usability point of view, it's handy when the applications window is at the same position and size of the previous program
  execution. Because the frontend layer itself should be slim and shouldn't come with it's own configuration file, the only option I was able to think of was to make this to a
  task of an application.
- The frontend implementations now delay making the window visible until "Redraw()" or "SetPositionSize()" was called or the initialization was completed. This gives e.g.
  "FrontendApplication" an opportunity to set the frontend position and size before the window gets visible. If this is not done, the frontend window will be shown at first at a
  default position and then jumps to the position and size of the previous session. I was of course aware of this issue when designing the system, but didn't found a compact solution
  for this and therefore decided to have a look into it when the rest is up and running. This doesn't look&feel good, but at the point the frontend window is created there's no
  information available were to e.g. place the window. On the other hand, the frontend window should become visible as soon as possible after the program started so that the
  user can see that the application is now really running. So, in my humble opinion this solution is ok because the frontend implementation has to decide how to deal with this.
- "Frontend": Added "GetTitle()" & "SetTitle()"



>> 19.08.2011
[CO]
- "Frontend": Added "IsMouseOver()"
- "Frontend": Added "GetMousePositionX()" & "GetMousePositionY()"
- "PLFrontendOS::OSWindowWindows" fine-tuning: As soon as the MS Windows function "ShowWindow()" is called, the window gets visible at once... with a nasty white content which is
  somewhat blending when you're working in a dark room. It's like a flash. I did some research but didn't found an answer how to avoid drawing at all... I can remember that previous
  Windows versions just did draw nothing when provinding a null-brush in the window class resulting in the untouchen window background. The only solution that worked for me is to
  just give the window class a black brush and then after the window was made visible within WM_CREATE just catch the WM_ERASEBKGND in order to avoid overdraw (= flickering). Another
  solution might have been to just delay the window show until the render loop starts... but this would mean that, after the user started the application, he would see no reaction at
  all... even if it's just for a few milliseconds, but even then one might start the application again because it feld like the application didn't started at all.
- Removed "AbstractFrontend::OnDisplayMode()". For e.g. "PLRenderer::RendererApplication" it's the same as "OnFullscreenMode()" and I can't think of a real difference - this method just
  says "something related to fullscreen mode has been changed".
- "Frontend": Added "RefreshFullscreen()"



>> 18.08.2011
[CO]
- Renamed the "Core"-class into "Runtime" because it's all about the runtime (even the version information)
- "Runtime"-class: Added "IsDebugVersion()" returning whether or not a debug version of PixelLight is used
- "Runtime"-class: Added "GetType()" detecting automatically the type of the currently used PixelLight runtime installation. Every PixelLight based project using the PixelLight
  runtime needs at least the dynamic "PLCore"-library (the static library is not really within the runtime, it's for developers only). So, in order to automatically detect whether it's a local
  or a system-installed runtime, I just load in the PLCore module and check whether or not it's within the same directory as the running process ("System::GetExecutableFilename()" :).
- Renamed "Runtime::GetDirectory()" into "Runtime::GetSystemDirectory()" and renamed "Runtime::GetDataDirectory()" into "Runtime::GetSystemDataDirectory()" to make clear that this is the
  system installed runtime (there can be a local and system runtime at the same time, although this is not recommended)
- "Runtime"-class: Added "GetLocalDirectory()" and "GetLocalDataDirectory()", the counterparts to "GetSystemDirectory()" and "GetSystemDataDirectory()"
- "Runtime"-class: Added "GetDirectory()" and "GetDataDirectory()", et voila, there are those two methods, again. But unlike the previous implementation, those two guys return the
  PixelLight runtime used by the running process. This means, those methods "automatically" detect the "correct" PixelLight runtime. While it's still possible to explicitly request the
  directory of the local or system PixelLight runtime, it's hightly recommended to only use the automatic PixelLight runtime detection to avoid using possibly incompatible binaries.
- "Runtime"-class: Added a directory parameter to "ScanDirectoryPlugins()" and "ScanDirectoryData" to make it possible to use for example the result of "GetDirectory()", "GetLocalDirectory()"
  or "GetSystemDirectory()". If an empty string is provided, the result of "GetDirectory()" will be used, resulting in an "autodetection".
- "Runtime"-class: Added comfort method "ScanDirectoryPluginsAndData()". In case you don't care about technical details and just want the stuff runnable, then just call this method and be happy.
  The PixelLight runtime to use is detected automatically, all available compatible plugins are registered as well as compatible data.
- "Frontend::Run()": This was a complex one... answering the question who's responsible to initialize the important PixelLight runtime related stuff. Until now, this was only done
  within "CoreApplication::OnInitPlugins()" and "CoreApplication::OnInitData()" - but the frontend stuff is above this application process and is also already using PixelLight runtime
  features like dynamically loaded frontend implementation plugins. Yesterday I experimented with several possible solutions, but one was more complex as the next one. Until now, there
  was also the configuration setting "CoreGeneralConfig::UsePixelLightRuntime", but the configuration system is already using the RTTI (and I still think that this solution is really cool
  and unique compared to other, definitely more complex configuration systems) to let the user decide from the outside whether or not to use the PixelLight runtime. I don't know why, but
  until a few hours ago I didn't really realize that this option is somewhat pointless - because the configuration system is already using this information in order to load in this
  information. Also, this approach, having this option, was quite error prone because when deploying an application it's "really" easy to forget to set this option to 0 to avoid conflicts
  with an installed PixelLight SDK. On the other hand, when starting an application, the OS is in fact deciding for us which PixelLight runtime to use. When the PLCore shared library etc.
  are in the same directory as the executable, those shared libraries are used instead of the ones of an installed PixelLight SDK (I know that there are variations over different OS, but
  even under Linux we have configured the binares this way so one can "just" extract a package and start it at once without configuring the whole system). The only problem was the dynamic
  loading of plugins... which wasn't a problem after all because the OS decides for us whether to use a "local PixelLight runtime" or an installed "system PixelLight runtime". We just have
  to detect which type of PixelLight runtime was chosen by the OS and then load plugins from this PixelLight runtime. Only from this one. So, by creating a package and putting everything
  into it one needs in order to execute the application without any installed PixelLight SDK, one already sayed that a "local" runtime has to be used. No need to confirm this decision again
  by manipulation the "CoreGeneralConfig::UsePixelLightRuntime"-option. Mixing different PixelLight runtimes would be evil anyway. Long story, minor changes:
  -> Removed "Runtime::ScanDirectoryPlugins()" within "Frontend::Run()" (had a [TODO])
  -> "pl_module_application"- and "pl_module_application_frontend"-macros: Added "Runtime::ScanDirectoryPluginsAndData()" right after "PLMain", before anything else is done
  -> Added "Runtime::ScanDirectoryPluginsAndData()" at some other places as well ("Runtime::ScanDirectoryPlugins()" was already used several times, so this change isn't something new)
- Removed "CoreGeneralConfig::DelayedPluginLoading"-option (by default, this feature is always active)
- Removed "CoreGeneralConfig::UsePixelLightRuntime"-option (now done automatically and due to delayed plugin loading the required time is no longer worth talking about)
- "FrontendApplication": This application class reimplements "OnInitPlugins()" & "OnInitData()" because in here, the PixelLight runtime initialization is the job of a higher being
- Bugfix: "ClassManager::LoadModuleDelayed()" was setting no "Name", "Vendor", "License" and "Description" information
- Bugfix: "ClassManager::RegisterClass()": When a dummy class of a dummy module is replaced by a real class, the (previously) dummy class has to be removed from the dummy module because
  a class can only be within one module at the same time
- "CoreApplication"-constructor: In here, the default application data subdir was set to
    m_sAppDataSubdir = System::GetInstance()->GetDataDirName(m_sName);
  While this looks logically at first, it becomes somewhat annoying (otherwise I wouldn't have had noticed and touched it!) after working with it for some time and e.g. doing several experiments.
  Let me explain it in detail: Take the "50RendererTriangle"-sample for instance, by default the application data subdir for my debug version is "C:\Users\COfenberg\AppData\Roaming\50RendererTriangleD"
  and for the release version it's "C:\Users\COfenberg\AppData\Roaming\50RendererTriangle". Now create some more experimental applications to play around with PixelLight by using
  as few instructions as possible in order to figure out how everything works... after a while, one may find the "AppDataSubdir"-option and when looking into the "Roaming"-directory
  one may notice that it's full spam like "50RendererTriangle", "50RendererTriangleD", "XTest", "123Test" and so on... and it is now probably a little bit hard to figure out what's trash and
  what's from an important none PixelLight application. Also, each and every PixelLight sample application had "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" in
  it and such stuff may be confusing when just starting to get into PixelLight based development.
  -> For those reasons, I decided to make "SetAppDataSubdir(System::GetInstance()->GetDataDirName("PixelLight"))" to the default setting. This way, the samples are even more compact
     (yes, just one row and x nested method calls, but as mentioned, those may be confusing for beginners) but more important, if one "forgets" to set this to an individual setting, everything
     will be thrown into the "PixelLight"-directory. Later on, it's probably easier to remember that something was "PixelLight"-based and easier to find and remove spam-files... by e.g.
     just removing the one single "PixelLight"-directory completely.



>> 17.08.2011
[CO]
- The frontend stuff is working quite well and solves some prior design issues. This approach also answers the question how to use the application framework within e.g. the Qt based
  editor in order to manage the PixelLight part while the Qt editor does all the rest like main loop and window handling. The PixelLight editor kickoff was on 10.08.2011, primarily
  to see what's required for the tool. It will certainly take some time until this tool is usable, so, the goal wasn't to have a ready-to-use-editor in PL 0.9.8. Until now, e.g.
  PLFrontendQt had to reimplement a lot of application framework features because the application framework was heavily tied to PLGui and also did stuff like the main loop internally.
  (this is still possible, but derived application classes like the renderer application now follow another approach)
  As seen within the PixelLight editor project, it's now possible to just write a thin layered frontend implementation working as a kind of gate between the Qt framework primarily used
  within the editor, and the PixelLight framework, primarily used in PixelLight *g*. Each side shouldn't concern too much about the other one - in fact, Qt doesn't know anything about
  PixelLight and verce versa.
  Now that it's clear that the frontend design is the way to go, time to complete the system.
- Added "FrontendContext"-class. This class is derived from "ApplicationContext" and adds frontend related stuff. The parameters of the "Frontend::Run()"-method were just an overkill
  and there was another issue as well: To be flexible, the frontend system already is using the RTTI and when e.g. PLFrontendPLGui open it's window, the standard data packages must
  already be registered. Also, a frontend may want to set a windows position and size to the one used during the previous seasson, meaning it needs to be able to use a configuration.
  During the frontend initialization, errors may occur, so, log is required as well. Sadly, all those stuff is handled within "PLCore::CoreApplication" which is still ok for applications
  not using the frontend stuff at all... but "PLCore::FrontendApplication" has to hand over the control over this important infrastructure features to the frontend. The frontend itself
  hands over this stuff to the "FrontendContext"-class which is instanced and filled outside the frontend system and is just passed into the system.
  Of course, some information is now stored within two distinct systems (frontend and application), but I in my humble opinion that's ok for this system. Take "PLCore::FrontendApplication"
  for example, as the name of this class indicates, this is the base class for applications running within a frontend (the application host). The main loop as well as other logic is handed
  over to a host in order to become passive. Although a frontend application is always running within a frontend, it shouldn't care about the frontend. Just write our application as if there
  wouldn't be any "outer world". By following this philosophy as close as possible and only accessing frontend features when really neccessary, you enhance the chance that your application
  can be embedded within other applications like browsers such as MS Internet Explorer or Mozilla Firefox without problems. So, in order to get e.g. the executable filename, one just asks
  the application framework for it, not the frontend system feeding this information into the embedded application.
- "FrontendContext::Run()" now has just a frontend context as parameter
- Removed "FrontendContext::Run()" versions with traditional C-arguments. It has shown that those version are not required. For e.g. QApplication of Qt using this traditional C-arguments,
  one can reconstruct them out of the universal form... no, it's not a performance problem nor intricate. It's intricate to have 3 method versions to be implemented all over the place and
  in case of e.g. the Qt base editor, one doesn't use the "FrontendContext::Run()"-method at all.
- "FrontendContext" has a name which is used as default whenever a name is required (log, configuration, window title and so on). When using the macro "pl_module_application" or
  "pl_module_application_frontend" this name is automatically set to the module name of the executable. "FrontendApplication" is using this name to set the default application name ("SetName()")
  and default application title ("SetTitle()"). This name is often sufficient - removed "SetName()" & "SetTitle()" usage within e.g. the sample applications.
- PLFrontendPLGui: PLGui requires some images stored within "Standard.zip", it's the responsibility of this frontend to ensure it has all it needs



>> 16.08.2011
[CO]
- Added abstract context class "AbstractContext". All over PixelLight, "context"-classes are used in order to group important information or components. This abstract context
  class was introduced to make it easier to identify such context classes.



>> 15.08.2011
[CO]
- "ApplicationContext::SetExecutableFilename()": The default (meaning you can choose another way if you want to) application directory layout now looks as follows:
  - "Application Directory"
    - "Data" (put all data you need in here)
    - "x86" (put all x86 executables and binaries in here)
    - "x64" (put all x64 executables and binaries in here)
  ... I worked with such a layout for years within other projects and never had real problems to use x86 & x64 together during development. With this layout it should
  also be absolutly clear that the executables and binares are decoupled from the data. In PixelLight release 0.9.8 there are several structual changes, so, it's probably
  better do to this "64 bit support"-related one in this release as well so that the next released don't have so many structural changes.



>> 14.08.2011
[CO]
- "PLFrontendOS::OSWindowWindows" & "PLFrontendOS::OSWindowLinux" & "PLFrontendPLGui::Frontend" & "PLFrontendQt::FrontendMainWindow" are now calling "AbstractFrontend::OnSize()"



>> 13.08.2011
[CO]
- "PLFrontend::OSWindowWindows" & "PLFrontend::OSWindowLinux" now react on AltGr-Return as well (same behavior across all frontend implementations)
- "Frontend": Added "IsMouseVisible()" and "SetMouseVisible()" ("PLFrontendOS::OSWindowLinux" part not yet implemented)
- "Frontend": Added "SetTrapMouse()"
- "AbstractFrontend": Added "OnDrop()" ("PLFrontendOS::OSWindowLinux" part not yet implemented). I'am not going to reimplement PLGui as frontend, but this feature is another
  useful one and I reduce it's usage to simple strings (for more complex stuff one has to use a GUI system!).



>> 12.08.2011
[CO]
- "CoreApplication::Run()" now implements the lifecycle as well
- "PLFrontendMozilla" & "PLFrontendActiveX" now also call the "OnRun()"-method (for none embedded frontends this is done automatically within "PLCore::Frontend::Run()")
- The program entry point "PLMain" is now ignored when the definition "_WINDLL" and/or "_USRDLL" is set... this should make it more comfortable to deliver an application as shared
  library (easier to embedd into other applications) instead of an executable. Those two definitions are MS Windows definitions, as far as I know, Linux has no equivalent...
  but we need something to test against... so I just defined those two definitions within "CMakeTools_Apps.cmake" for Linux as well (I was just to lazy to invent totally
  new definition names).



>> 11.08.2011
[CO]
- String: Sadly, we can't use uint16 in order to let the compiler decide whether to use a whar_t or a uint16 version of a method. For instance, when using PixelLight within the
  Qt Creator (without changing all used default settings!), whar_t is defined as unsigned short. :/



>> 08.08.2011
[CO]
- "Frontend": Added virtual "OnRun()"-method. This method is called just before the frontend calls it's run-method in order to enter it's main-loop. Use this method for instance
  to pre-process command line arguments.
- "FrontendPixelLight" is now using the new "OnRun()"-method in order to fill the application context just like "CoreApplication::Run()" does
- "Frontend": Exposed the class to the RTTI
- "Class": Added "Create()"-method creating an object by using a given constructor name and typeless constructor parameters
- Implemented frontend arguments... I'am not really happy with the current solution because it just looks complicated. I tried some other approaches but this one was the best one.
  Maybe I find another, better solution later on - but for now it works and is quite flexible. I'am really happy that I introduced the "pl_module_application" & "pl_module_application_frontend"
  macros because they're hiding the complex frontend run call. Within the samples the frontend call is only done once within "45ScriptApplication" without this "standard use case"-macros.
[SW]
- "PLFrontendOS": added toggle fullscreen support and and setting window icon to linux X11 part
- "PLFrontendQt": added support for setting the application/window icon



>> 07.08.2011
[CO]
- Updated "PLFrontendQt::QPLRenderWindow". Drawing and updating states are now two distinct things for the frontend & application framework, so, "PLFrontendQt::QPLRenderWindow"
  has now only care about drawing.
- Moved the "PLCore::Timing"-update from "FrontendApplication::OnUpdate()" into the frontend implementations. "PLCore::Timing" can limit the update rate to a fixed one like
  60, meaning that the update process doesn't run more than 60 times per second. An application (the slave) shouldn't care about such a topic and the frontend (the master) should
  have control over this one as well. Please note that it is allowed that the logic update and draw update have different intervalls (but again, the application side doesn't care
  about this :).
- "Frontend": Added fullscreen mode support and implemented it for "PLFrontendOS::OSWindowWindows" (implementations for the other frontends will follow)
- "PLFrontendPLGui": Implemented fullscreen mode support
- "PLFrontendQt": Implemented fullscreen mode support
- "FrontendApplication::GetFrontend()" now returns a reference instead of a pointer. An "FrontendApplication"-instance is always running within a frontend, else the system becomes
  artificially complex. Therefore, the result of "GetFrontend()" must always be valid and there's no need for null pointer tests trashing the code.



>> 06.08.2011
[CO]
- Linux: Changed the type of "handle" from "int" to "unsigned long" (shouldn't really be a difference in the used bit length... even on 64 bit "long" is usually only 32 bit long...)
- Added "Core::ScanRuntimeDirectoryPlugins()" because the same stuff was done in "CoreApplication::OnInitPlugins()", "PLCore::Frontend::CreateInstance()", the sample "40ScriptHelloWorld"
  not using the application framework at all, "PLFrontendQt::Application::InitCore()" and so on.
- Added "Core::ScanRuntimeDirectoryData()", more stuff not only useful for "CoreApplication::OnInitData()"
- MS Windows: "PLFrontendOS" is now using the standard PixelLight icon for the main window of this frontend
- MS Windows: If a process has an own icon, "PLFrontendOS" is now using it instead of the standard PixelLight icon
- "PLFrontendQt": Removed unused "Application::ScanFSArchives()"-method
- Added "AbstractFrontend", same purpose as "AbstractLifecycle" => one and the same interface for the same task
- "AbstractFrontend": Added "OnUpdate()"-method. Drawing and updating states are now two distinct things for the frontend & application framework.



>> 05.08.2011
[CO]
- "Frontend": Added versions of the "Run()"-method using traditional C-arguments (char/wchar_t). Some frontends, like the Qt one, want to have the original C-arguments or someone
  may want to run a frontend by providing it with traditional C-arguments.
- "Frontend": Made a clear distinction between "Redraw()" and "Ping()"
- "Frontend": Added "RedrawAndPing()"-method first calling "Redraw()", then "Ping()"... probably an important use case... :D
PLFrontendQt:
- Implemented correct application lifecycle and "Ping()"-method (by the way, just noticed Qt's "QCoreApplication", so, "PLCore::CoreApplication" is probably really a decent name)
- Instead of performing an immediate hard-coded repainting of the frontend within "FrontendMainWindow::timerEvent()", Qt is now asked politly to update (and repaint) the widget.
  This way, the main window stays always responsive - but now I had "white flickering" due to some Qt overdraw. After using same settings as in Qt's QGLWidget, the "white flickering"
  had gone... but now there's "black flickering" from time to time. When debugging, it's clear that Qt still draws something into the window. After over a hour of research
  I wasn't able to figure out what's going on. The concept is ok, drawing only within Qt's "paintEvent()" and a redraw-timer only asks Qt politly to update (and repaint) the widget
  instead of directly draw (which wasn't working that well, messed up Qt's event processing). Time to stop working on this "detail" for now in order to finish the frontend work.
- ... I wasn't able to stop thinking about the "black flickering"-issue... and found a solution:
  -> Set "Qt::WA_OpaquePaintEvent"-attribute
  -> Overwrite "QPaintDevice::paintEngine()"-method and just return a null pointer
  ... the flickering is now gone and the whole main window is responding and behaving quite fine...



>> 04.08.2011
[CO]
- Renamed "ConsoleApplication" into "CoreApplication" so that one can guess the name of this class by just knowing the component name it's in
  (it's also the base/core class of the application framework, so "core" maybe more suitable then "console")
- "AbstractFrontendLifecycle" really solved some nasty design issues when it comes to application lifecyle control. Time that also "CoreApplication"
  is using this interface so that frontends can control the applications in a proper way (e.g. deactivating input control as soon as the application gets
  paused because it e.g. lost the focus). For this, renamed "AbstractFrontendLifecycle" into "AbstractLifecycle".
- Derived "CoreApplication" from "AbstractLifecycle". When possible, I try to avoid using multi-inheritance but in this case I see no other decent option -
  sadly C++ has no Java like "implements". :/
  -> Renamed "CoreApplication::Init()" into "CoreApplication::OnStart()", the "AbstractLifecycle" equivalent called as soon as something is started (not same as instanced)
  -> Renamed "CoreApplication::DeInit()" into "CoreApplication::OnStop()", the "AbstractLifecycle" equivalent called as soon as something is stopped (not same as destroyed)
- "FrontendPixelLight" is now calling all "AbstractLifecycle"-methods of it's petted application
- "Frontend": Added "Ping()"-method to give the frontend a chance to process OS messages. There are situations (like current load screen implementations) were an application
  may do some heavy work without letting the frontend a chance to process OS messages. In such situations, it may be wise to call this method from time to time to give the
  frontend a chance to do some message processing. Whenever possible, don't use this method, do heavy work within e.g. threads.
PLFrontendPLGui:
- Moved "ModTrapMouse", "PreviewWidget", "RenderWidget", "RenderWindow" and "WindowConnection" from "PLEngine" into "PLFrontendPLGui"
- Implemented correct application lifecycle and "Ping()"-method
PLFrontendOS:
- The application lifecycle is now handled within the OS dependent implementation (e.g. "OSWindowWindows") instead of within "Frontend"... I hope this way the order is
  always correct... hopefully... eventually... *g*
- When moving/sizing the window, the application will also be paused during this period (WM_EXITSIZEMOVE/WM_ENTERSIZEMOVE MS Windows events)... it's just annyoing when you move
  or size a window and the controlled scene camera is spinning around while you do so...



>> 03.08.2011
[CO]
PLFrontend:
- "PLFrontendNull", "PLFrontendOS", "PLFrontendPLGui", "PLFrontendQt" and "PLFrontendActiveX" (testing it within the MS Internet Explorer) are now up and running
  ("PLFrontendMozilla" is still broken)
- Added "PLFrontend::Frontend::Run()" to start an application inside a frontend. This is only required for executables and not if an application is running e.g. within
  a browser. When using it, it looks like this:
    int PLMain(const PLCore::String &sFilename, const PLCore::Array<PLCore::String> &lstArguments)
    {
        return PLFrontend::Frontend::Run("PLFrontendOS::Frontend", "Application", sFilename, lstArguments);
    }
- When the work on the frontend stuff is complete, PixelLight applications are usually "frontendless", meaning when compiling it as an executable, you as application developer
  choose the frontend to use (or not if you just don't care about GUI). Additionally, in the future it should be possible to just recompile the application as shared library in
  order to be able to embed it within other applications like a browser. To make this as easy as possible, I added the macro "pl_module_application_frontend" (yeah, too long
  name, again... but it's only required once within a project and therefore a speaking name is fine) and when using it, the main C++ file usually looks like this:
    #include <PLFrontend/FrontendMain.h>
    pl_module_application_frontend("50RendererTriangle", "Application", "PLFrontendPLGui::Frontend")
        pl_module_vendor("Copyright (C) 2002-2012 by The PixelLight Team")
        pl_module_license("GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version")
        pl_module_description("PixelLight triangle sample")
    pl_module_end
  ... should be quite handy to use ("pl_module" is usually already used, so not much additional work, it's even less work!). :D
  There's also a shorter macro:
    "pl_module_application("50RendererTriangle", "Application")
  Which will use the frontend "PLFrontendOS::Frontend" as default. This totally primitive frontend is sufficient for many applications.
PLFrontend<>PLCore
- Merged PLFrontend into PLCore... another new project which didn't make it long on it's own. :D
  Just like PLScript, PLFrontend was started as a separate project to see whether or not the idea/concept is working and then to see how it's integrating into the system as a whole.
  The PLFrontend concept turned out to be the key in making PixelLight really easy runnable within other applications like browsers. As such, it feels just right to put it directly
  into PLCore - it doesn't introduce new dependencies and is also not really a huge component.



>> 02.08.2011
[CO]
PLFrontend:
- Added "FrontendApplication" & "AbstractFrontendLifecycle" and started on the frontend design
PLFrontendPLGui:
- Moved "SNGui" from "PLEngine" to "PLFrontendPLGui" because it's using PLGui



>> 01.08.2011
PLFrontend:
[CO]
- Started the PLFrontend project (kind of "PLPlugin"-project successor)... now that scripting is working, it's finally time to attack another big design task.
  When we started the development of the PixelLight engine on 16 September 2002, we just had one single project: "PLEngine"
  This project just used a quite simple OS window to render stuff into it. Back then, the world was more simple regarding to required supported platforms.
  Providing support to be able to render into multiple OS windows was really a cool feature because most engines were just able to render into a single
  OS window. Over the years, the GUI stuff was moved into an own, platform independent, GUI library called PLGui. All other PixelLight projects were build
  on the top of it. PLGui is currently already within it's third (!) reincarnation.
  In the last past 9 years, the world has dramatically evolved regarding to the platforms one should really support and the current PixelLight design regarding
  to GUI handling does no longer really completely satisfies the changed needs. Now those are the requirements to be fulfilled:
  -> Be able to have absolutely no GUI at all, e.g. for server side applications or applications rendering just into a buffer *currently there's always a PLGui dependency*
  -> A quite primitive OS window for applications requiring no GUI handling, except for the OS window it's running in *PLGui is an overkill for this use case*
  -> "PLGui": PixelLight own GUI system (OS & ingame) perfectly integrated into the complete system, stuff like scripting doesn't need wrappers, it just works out of the box *currently used way*
  -> Be able to just use third party GUI systems like Qt for front-ends *currently there's always a PLGui dependency*
    -> The PixelLight editor will be Qt based because getting PLGui to the point were it's possible to write such an complex editor is just impossible with a team of two
       active spare-time developers (we already tried it years ago *PixelLab* and it was a total failure :/)
  -> Be able to embed an PixelLight application into another application, meaning another GUI system has the control and we're just a slave
    -> Be able to run in a web browser (e.g. by using "Java Web Start"/"JNLP" or/and by writing special browser plugins)
    -> Be able to run on mobile devices, e.g. Android based
    -> Be able to use ActiveX under MS Windows to embed 3D stuff into e.g. a MFC dialog (we already had to do this for a project some years ago)
    ... scripting is especially useful for the first two mentioned embed-points. This way, an application developer doesn't need to care about the target platform and is just
        writing some scripts...
  Ok, as you can see, a whole bunch of new requirements since the start of the PixelLight engine. In "Docs\Diagrams\PixelLight_PackageDiagram.png" I outlined how it will probably
  look when PLFrontend is up and running.
  Please note that the PLFrontend approach doesn't mean that I abandon the PLGui project, but having the whole system be dependent of a GUI system is not working any more with
  the changed requirements. Also, while the third reincarnation of Stefans PLGui is really cool and can be used for OS and ingame and has, by using the PL RTTI, automatic support
  for scripting and therefore integrates itself perfectly into the whole system... PLGui is still missing some features and fine-tuning. Sadly, such a GUI system is a huge task
  and currently, as already mentioned, there are only two active spare-time developers. Personally, I finally want to get PixelLight to the point were it's possible to create
  simple prototype applications in a matter of minutes by using e.g. a Lua script to load in a scene and adding some interaction - and then be able to run this on multiple
  platforms/targets. So, my focus is on that instead of taking over the development of Stefans PLGui (I already ruined the previous second reincarnation and don't want to repeat
  this experience). I really hope that in the future there's someone continuing the development of PLGui because especially the scripting-argument is a really cool argument for PLGui!
  (connecting e.g. libRocket or Qt to the PL RTTI and scripting system will be probably lot of work while it's no work at all with PLGui!)
  ... enough introduction and explanation why there's need for the PLFrontend project. Let's go to work...
- Added the (currently empty) frontend plugins
  - "PLFrontendNull": The usual dummy project doing nothing at all
  - "PLFrontendOS": Just a totally primitve OS window
  - "PLFrontendPLGui": PLGui connection
  - "PLFrontendQt": Qt connection (the new "PLQt")
  - "PLFrontendActiveX": ActiveX connection (the new "PLPluginActiveX")
  - "PLFrontendMozilla": Mozilla connection  (the new "PLPluginMozilla")
  ... while "PLFrontendNull", "PLFrontendOS", "PLFrontendActiveX" and "PLFrontendMozilla" are intended to be 100% loose dynamic plugins, "PLFrontendPLGui" and "PLFrontendQt" are
  of course also such plugins, but one is usually going to also use those libraries directly within an application (meaning linking aginst them).
- Copied the diaries of "PLPlugin", "PLPluginActiveX" and "PLPluginMozilla" into this diary because PLFrontend will be the successor of the "PLPlugin"-project... which is not limited
  to "PixelLight application as a plugin for e.g. a browser" but will also cover the "PixelLight application as executable" use case. Meaning, in the future it will be possible to just
  recompile a C++ PixelLight as shared library and then be able to use it in any available frontend.
- Using "PLPlugin::Plugin" as start point for the class "Frontend"
- Renamed "PLPluginActiveX" (still working, just tested it :) into "PLFrontendActiveX"
- Renamed "PLQt" into "PLFrontendQt"
- Renamed "PLPluginMozilla" into "PLFrontendMozilla", when testing it with Firefox 5.0 the browser didn't want to load it (sayed something about corrupt... before I did the changes...)...
  I'll check it later when PLFrontend is working as a whole...
- Removed "PLPlugin", it's been replaced by "PLFrontend"



>> 02.07.2011
[CO]
PLQt:
- Added empty project "PLQt". In the next steps, PLQt (https://sourceforge.net/projects/pixellight/) from Stephan Wezel will be integrated directly into the PixelLight
  Git repository and SDK because e.g. the editor will be Qt based. I currently use Qt 4.7.0 and I know that there's already a newer version available... but I already
  had Qt 4.7.0 compiled for VisualStudio 2010 (to avoid using VC 2008 within the PL SDK) a while ago and right now I don't want to spend time in recompiling Qt, again.
- Moved "QtStringAdapter" from PLGeneral into PLQt
- Integrated PLQt, I'am sure it's not yet final and that over time, there will be multiple simplifications



>> 31.07.2011
[CO]
- Exposed "ConsoleApplication::Exit()" to the RTTI



>> 30.07.2011
[CO]
- "PLScriptLua::RTTIObjectSignalMethodPointer::EventCallback": "TypeRef" was missing



>> 27.07.2011
[CO]
- Using PLCore to check whether or not "override" from C++0x (see e.g. http://www2.research.att.com/~bs/C++0xFAQ.html#override) will cause any problems
  -> By using "override", the compiler found the following: "Constructor" implemented the virtual method "GetDesc()" and a comment stated that it's a
     "DynFunc"-method. Ok, the name is a "DynFunc"-method, but the signature is "const FuncDesc *DynFunc::GetDesc() const" while the other signature is
     "const ConstructorDesc *Constructor::GetDesc()". "ConstructorDesc" is not derived from "DynFunc". To be fair, to the compiler would also have found it without "override"
     if "Constructor::GetDesc()" would have been declared as constant as well, but it wasn't. So, "override" really did the trick and exactly such errors are the reason
     why I'am so interested in this language feature in the first place. I'am sure that there are some more of such errors in the hundred thousends lines of code... :D
     If I'am not totally wrong and missed something, "Constructor::GetDesc()" is a dead method. Removed it.
  -> In the dungeon demo, I found at once an error using this new language feature: The "Application::LoadScene" signature had changed, but the dungeon demo wasn't updated...
     I'am starting to really like "override" :D
- PixelLight was already using "extern templates" which are part of C++0x (http://www2.research.att.com/~bs/C++0xFAQ.html#extern-templates)... added comments to avoid confusion...



>> 26.07.2011
[CO]
- "LoadableType::AddLoader()" fixed log messages ("[Info]: Loader 'PLAssimp::SceneLoader3DGameStudio': Format 'mdl' is already used by loader 'PLAssimp::SceneLoader3DGameStudio")
- "Loadable::Load()"/"Loadable::Save()": Moved the "IsDerivedFrom()" security check into "LoadableManager::RegisterClasses()"
- Renamed "LoadableType::GetLoader(uint32 nIndex)" into "LoadableType::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableType::GetLoader(const String &sExtension)" into "LoadableType::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetLoader(uint32 nIndex)" into "LoadableManager::GetLoaderByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetLoader(const String &sExtension)" into "LoadableManager::GetLoaderByExtension(const String &sExtension)"
- Renamed "LoadableManager::GetType(uint32 nIndex)" into "LoadableManager::GetTypeByIndex(uint32 nIndex)"
- Renamed "LoadableManager::GetType(const String &sName)" into "LoadableManager::GetTypeByName(const String &sName)"
- Added "LoadableType::GetLoaderForLoadingByFile()" which currently is using, as before, just the filename extension to find the proper loader
- "LoadableType::GetLoaderForLoadingByFile()": If there's no loader for the given file extension, the complete file extension is checked as well (file format extensions like
  "mesh.xml" can now be used as well)
- Added "System::GetSeparator()" returning the directory separator used by the operation system (e.g. '/' on Linux, '\' on Windows)... interesting that such a method was still
  missing...
- Added "File::CFileModeToAccessFlags" translating a given C file mode ("r", "r+", "w", "w+", "a", "a+", "t", "r+t" etc. used for e.g. "fopen") into access flags



>> 25.07.2011
[CO]
- "Url": "GetTitle()" and "GetExtension()": For a filename like "archive.tar.gz" the method "GetTitle()" returns "archive.tar" and "GetExtension()" returns "gz". While this is
  ok/standard for some use cases, there are also situations were "archive" as title and "tar.gz" as extension is desired/standard. I checked other libraries/frameworks like Qt
  in order to see how they deal with this topic. In Qt, they offer the following methods:
    "QFileInfo::baseName()"="archive"
    "QFileInfo::completeBaseName()"=archive.tar"
    "QFileInfo::suffix()"="gz"
    "QFileInfo::completeSuffix()"="tar.gz"
  This naming convention sounds reasonable and at least "suffix()" is handled the same way as PL's "GetExtension()".
  -> Added some more comments to avoid confusion (or at least reduce it) when dealing with filenames like "archive.tar.gz"
  -> Renamed "GetTitle()" into "GetCompleteTitle()" returning "archive.tar"
  -> Added "GetTitle()" returning "archive"
  -> Added "GetCompleteExtension()" returning "tar.gz" and also added "CutCompleteExtension()"



>> 21.07.2011
[CO]
- PLGeneral->PLCore - done



>> 19.07.2011
[CO]
- Merged PLGeneral (started before 25.11.2003) into PLCore (started: 05.02.2008) because both are completely fundamental and it's not that clear which project was for which
  components. When looking e.g. at the PixelLight component diagram one can see that every other project is already using PLCore and not even the most primitive sample within
  the SDK is using just PLGeneral. This may be a sign that this is in fact one component which was just splitted into two projects. A year ago or so, there were already
  discussions whether or not e.g. the log should be part of PLGeneral and PLCore. In the end, the log was moved into PLGeneral although the log formater classes are in fact
  loose dynamic plugins, but were now not able to be implemented in this way because the RTTI was introduced within PLCore. Of course, that's nothing dramatic, but on the other
  hand it would be cool to e.g. write a special log formater within a loose plugin and then select it within a configuration file. While modulation is a really useful thing,
  PixelLight now consists of 13 of primary modules and loose plugins and when looking at user feedback it looks like that some people have some issues with this. I'am not going to
  merge everything into a single "PixelLight"-project as seen in several engines out there. There was a reason for this individual modules: To make everything as flexible as
  possible which is especially nowadays really important due to the mass of available target platforms. But it seems to be reasonable to simplify PixelLight were ever possible
  to avoid comments like "PixelLight is a monster" in the future. This was one reason why I moved weeks ago the 100% dynamic plugin projects into the "Plugins"-directory so everyone
  can see at once that those are optional and nothing build in. The core of PixelLight is in fact slim and most features are just plugged-in! (which may be one of the reasons why
  there are people thinking that PixelLight is really complicated because they seem to be used to have everything thrown statically together in one huge blob)
  -> The PixelLight base now consists of 12 modules as well as 38 optional modules aka plugins aka extensions aka addons, this should still be more then enough modularisation.
  -> Due to the current examines at university, I'am pretty sure that I will need several days to update the rest of PixelLight...



>> 10.07.2011
[CO]
- Moved PLIRC and PLJabber from the PLNetwork directory into the PLPlugins directory because it's nothing the PixelLight core is
  using and in fact, until now it isn't used at all. So, this is definitively a plugin/extension/addon.
- Removed PLNetwork project. It has now been empty since "23.10.2009" and there are no signs that this will change in the near feature.
  The basic stuff like sockets were already within the PLGeneral project and even some more hight level constructs like server-client
  classes. Since the public release of PixelLight, there were several user questions asking why PLNetwork is empty, and why there's an empty
  project at all. So, to avoid this confused (but understandable) question in the future, PLNetwork is now gone. If there's really
  need for an individual network component in the future, the project can be added in no time.
-> Moved the entries of the PLNetwork diary into the PLGeneral diary



>> 03.07.2011
[CO]
PLCore:
- Within "Rtti.h", "__NT__" ("#define __NT__	PLCore::NullType") was defined... which usually stands for "Windows NT" in system headers. Until now, there were
  no problems with that, but today this changed when using Qt to compile something under Linux.
  Within the Qt header file "qglobal.h" there's the following line
    "#elif !defined(SAG_COM) && (defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__))"
  ... and now, when including a PixelLight header using the RTTI before a Qt header is included, Windows headers are included inside Qt. I thought about renaming
  "#define __NT__	PLCore::NullType" into "_PLNT_" or so, but on the other hand, maybe there's an OS header using "_PLNT_" or another definition as well? To avoid
  any further troubles in here, I just removed this definition.



>> 02.07.2011
[CO]
- Moved "QtStringAdapter" from PLGeneral into PLQt



>> 27.06.2011
[CO]
PLCore:
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": Added some quotation mark checks. If the string content is "Name="Bob"" the resulting parameter
  string will be "Param0="Name="Bob""" and the parser will have troubles with it and will take "Name=" instead of "Name="Bob"" for the value of "Param0". After this change,
  the resulting parameter string is now "Param0='Name="Bob"'".



>> 21.06.2011
[CO]
PLCore:
- When testing the Dungeon demo under Linux, I noticed that the "Object" RTTI methods (but only those?) were not exported correctly when using GCC. Found the "bug" within my
  change from "04.06.2011" when I removed the per instance cost of RTTI methods... the RTTI method instantiation was wrong. I still think that this is the right way because
  tons of those methods will come in the future!
  After a look into how Stefan did it with the RTTI constructors I was able to fix the issue, more or less. It looks like now, that more stuff is connected to the RTTI the
  template instantiation issue strikes back (we already had it multiple times under Linux). Interesting that everything runs that smoothly under MS Windows.
  Maybe it's better to do as many RTTI related definitions as possible in the cpp files instead of the header files? As far as I can see, for constructor and method definitions
  this wouldn't be problem - except that the RTTI stuff would be more scattered over two files (although there's already "pl_implement_class" in the cpp files...).   
  This would probably also make the life of the compiler a little bit easier... the more complex derived classes from derived classes get, the more work for the compiler
  (the slow down is really notable when compiling). Right now, I don't want to work too much on the RTTI - I already did way more changes as I wanted. It's not
  really my field and I'll have other stuff on my TODO-list (but I really had to do something about the most important issues to be able to go on with other parts in a decent way).
  So a kind of patchwork has do to the job for now: In important RTTI classes, I'll added a define around the constructor and method definitions so that they are only considered
  when compiling the project they are in. This solved my current template instantiation issue under Linux - for now.
  Ps. By the way, I just noticed that the Windows version of the Dungeon executable is after this change only 230 KiB instead of 395 KiB... I assume that this massive template
  instantiation within the header files really has a notable impact on everything. :/



>> 18.06.2011
[CO]
PLCore:
- Added "DynSignature"-interface and derived "DynEvent", "DynEventHandler", "DynFunc" and "DynParams" from this new interface. Previously, those interfaces had
  only a "GetSignature()"-method in order to request the signature description as string. With the introduction of script support there was a need to get concrete
  type ID information of return and parameters for proper exchange of data between script and C++. Of course, it would have been possible to just parse the already
  available signature-string, but this would have been a little bit uncomfortable.
- PLScriptLua: Added new static method "RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()" which returns the current Lua function parameters on the Lua
  stack as string. This was my motivation for the "DynSignature"-interface because this new method is used by "RTTIObjectMethodPointer" and "RTTIObjectSignalPointer"
  and type ID information is used internally.
- PLScriptLua: Solved another reference issue. Well, not directly an issue with references in general, more an issue about their usage in scripts with strings.
  Strings are somewhat of a special case, at least within their usage. It's possible that there's a RTTI method with a "Object*(const PLGeneral::String&)"-signature
  meaning that the parameter is a reference. Within scripts, strings are fundamental and therefore it should be possible to use such a RTTI method by writing for instance
    this:GetSceneNode():GetByName("Soldier")
  so that the script programmer doesn't need to care whether or not the required RTTI method parameter is in fact a reference instead of a string. Of course, a real
  reference a parameter should still also be possible as well. To solve this issue, whenever the script programmer provides a string, but a RTTI method is expecting
  a reference or a pointer, this given string is stored within a string-list on the heap during the function call. By doing so, the reference/pointer has a valid address.
  -> Some weeks ago, I was afraid that we can't keep the "const PLGeneral::String&"-concept and had to change it into "PLGeneral::String" in order to use such methods
     within scripts. But the solution within PLScriptLua solves this issue and the PixelLight interfaces don't need to be rewritten. The solution also introduces no
	 extreme runtime overhead because the string class is quite optimized internally and is using e.g. the "copy-on-write"-concept. So, those temporary strings on the
	 runtime stack don't really hurt much.
- "PLScriptLua::RTTIObjectMethodPointer::GetLuaFunctionParametersAsString()": If a RTTI signature demands more parameters as the script programmer provided, we need to add
  the missing parameters because if there's a reference parameter it really needs a valid address
- "Script": Added namespace support for global variables. By using namespaces, one can e.g. define that all script variables an editor is able to show have to be
  within a "public"-Namespace (just an example, there's no such thing fixed build in within PLCore!). In this editor-example, the user is then able to get and set script
  variables just like RTTI attributes, but the other script variables which are e.g. within the global namespace are hidden.
  Currently, this namespace support is only implemented within PLScriptLua... the next scheduled PixelLight release is near and so I really have to work focused.
- "Script": Due to namespace support for global variables, I had to change the "GetGlobalVariables()"-signature. This method no longer returns a list of found global variables,
  instead a list to be filled up has to be provided as parameter.
- "Script": Added support for global script functions which are inside a namespace. Currently, this namespace support is only implemented within PLScriptLua.
- "pl_class_internal"-macro: Added "__pl_rtti_export(PLCORE_RTTI_EXPORT)" within the RTTI macro to make it possible to expose "Object"-methods to the RTTI
- "Object": Renamed "IsInstanceOf(const Class &cClass)" into "IsInstanceOfByReference(const Class &cClass)" to make it possible to expose the
  "IsInstanceOf(const PLGeneral::String &sClass)" method to the RTTI (this version of the method is the more often used one)
- "Object": Exposed several methods to the RTTI... this makes it for instance possible to construct the names of methods/attributes etc. to be called from inside a script
   dynamically inside the script...



>> 17.06.2011
[CO]
PLCore:
- "Script": Added support for "Object&"
- "DynEvent": "Connect()" and "Disconnect()" required a pointer as parameter, but there was no documentation whether or not a null pointer was allowed.
  When providing a null pointer, the implementation crashed because there was no test for a null pointer. Before I start adding pointless pointer
  checks, I just change the methods so their using references as parameters as done in other PixelLight parts. By the way, connecting event handlers
  looks now also the same as when doing the same in Lua scripts. *g*



>> 16.06.2011
[CO]
PLCore:
- There was an issue when using a reference type as RTTI method result... this was the reason why I hadn't yet exposed methods like
    SceneNode &GetSceneNode() const;
  to the RTTI. It took me several hours to wrap my head around the type traits Stefan wrote (no critics, the system is really genial... but the topic is just not really
  my expertice, I'am more the graphics programmer type :) and several more hours for attempts and experiments to get reference types as return values up and running.
  When I finally had an working solution, I reduced my number of code changes to the bare minimum in order to reduce the risk to introduce new bugs or to mess everything
  up. I really had to do a change in order to be able to continue exposing methods to the RTTI... the alternative to just forbid the usage of pointers wasn't a real
  solution for me.
  The problem was the following: The internal system stores within the parameters class the parameters, and also copies them around like
    cP.Return = (*this)(cP.Param0);
  as long as the type is no reference, everything is just fine. But as soon as there was a reference type hell broke loose because a when copying one reference into another,
  not the address of the referenced object is copied but instead the value. Within the system, this reference behaviour results in another behaviour as the desired one. My
  solution is the introduction of a "storage" type within the type definitions. Usually, meaning for 99% of all types, the storage type is identical to the real type. For
  reference types, the real type is a reference (as before) - but the storage type is a pointer. This way it's possible to internally copy around the parameter in the correct
  way. There are also the two new type methods "ConvertRealToStorage()" and "ConvertStorageToReal()" which are used to convert the types when necessary. I hope the compiler
  is clever enough to notice when this results in copying one variable into itself without any further change - in this case, this change would introduce no new additional work
  to be done. The example code from above now looks like this
    cP.Return = Type<R>::ConvertRealToStorage((*this)(Type<T0>::ConvertStorageToReal(cP.Param0)));
  and from the outside, as long as not accessing "Return", "Param0" etc. directly, the user will not notice that his reference is internally handled as pointer. With this change,
  it's now possible to expose methods with a reference type as result to the RTTI - meaning to also enable it's usage within scripts.
  ... the last days were really exhausting because due to university, I had to get into the topic and solve the issue at night and during lectures. But I really wanted to have this
  issue solved within the upcoming PixelLight 0.9.7 release because it's quite fundamental for scripting. Now that it's up and running, I think it was worth the effort. :D
- PLScriptLua: Added "TypeRef" support for method results
- ... now that I have GCC 4.6.1 installed, removed the following hack within Event.h
    // [HACK] This is currently necessary to avoid the following strange compiler error:
    //		    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, ...>
    #ifdef GCC
        static Functor<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> DummyFunctor;
    #endif
  in order to check whether or not this is still the case... made a fresh build without the hack and there were no more problems. :)
  So, I let the hack out... there's no point in supporting buggy old compilers. For example in GCC 4.5.2 the nullptr emulation was no longer working due to a GCC bug. So, if you
  encounter any compiler issues, just use an up-to-date compiler (if there's one :) instead of spending time to hack around compiler bugs.
- "Func.h": Removed debug-output in case of a signature mismatch. The "new" RTTI 2 is now working since over a year within PixelLight and does really a fantastic job. I assume it's
  about time to remove this scaffold (which, over the time caused some debug/release include issues).
- Minor "SignatureString::GetSignatureID()" implementation change to make the life of the string class a little bit more comfortable. I know, this doesn't really have a directly
  measurable impact... but when I see something that can be optimized without messing everything up (especially when it's within the core), I do it because in the end, all sums up...
- Removed
    typedef Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> _Func;
  etc. in e.g.
    FuncFunPtr<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : public Func<void, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
  because it really looks like dead code (wasn't able to find any usage of it).



>> 14.06.2011
[CO]
PLCore:
- "ConsoleApplication": The "Init()"-method documentation stated that it's calling "OnInit()", and the "DeInit()"-method documentation stated that it's calling
  "OnDeInit()"... but those two methods are actually called by the "ConsoleApplication::Run()"-method. I had a look into this diary to see the intended behaviour
  and found the description within the "06.08.2010"-entry from Stefan Buschmann (I'am really glad that we're writing diaries :). The implementation is correct,
  but the documentation wasn't. Fixed that.
- "Script:" Added "IsGlobalFunction()" so one can check whether or not there's a certain global script function before calling it. Background: When calling a global
  script function, the script backend usually writes an error into the log when the given global script function wasn't found. I still think that this behaviour is
  useful. When using optional global script functions, it's a good idea to check whether there's such a global script function by using "IsGlobalFunction()".
- PLScriptBindings: Changed the default value of "UpdateFunction", containing the name of the script function to be called, from "Update" into "OnUpdate"
 (same name as in "PLEngine::ScriptApplication")
- "PLEngine::ScriptApplication" and "PLScriptBindings::SNMScript" have now both the script entry points "OnInit()", "OnUpdate()" and "OnDeInit()".
  The name of the optional script function called by C++ by one of these entry points is an RTTI atribute, meaning that e.g. a scipt can manipulate
  it's own entry points! Wow, the script-stuff is getting pretty flexible. *g*



>> 12.06.2011
[CO]
PLCore:
- Merged PLScript into PLCore. When starting PLScript on "25.04.2011" I had no real idea were the script voyage would end. Back then, I decided to
  create an own project for script support - this has proven to be useful when starting a new component. Now that the Lua backend of PLScript has
  nearly all features I wanted I start to play around with it a little more... and it's a little bit annoying to add PLScript to the VC project solutions.
  Right now, PLScript consists just of a handful of classes and it doesn't look as if a lot more script classes will come. The "magic" happens in the RTTI
  system and within the general PLCore infrastructure. Scripts exist to make the world a little bit less complex, so, it's probably a good idea to make using
  scripts within the PixelLight C++ API less complex as well by directly adding the scripting-feature into PLCore. The PLScript documentation will still be an
  own document because the PLCore documentation is already comprehensive and contains more advanced stuff which will probably shock many people which are just
  looking for e.g. "How to use Lua within PixelLight". *g*



>> 11.06.2011
[CO]
PLCore:
- PLScriptLua: A Lua script can now connect a RTTI signal with a Lua function



>> 10.06.2011
[CO]
PLCore:
- "DynParams": Added "GetReturnTypeID()", "GetNumOfParameters()" and "GetParameterTypeID()" in order to make it possible to get some more
  information about parameters if one has just access to the "DynParams" interface
- Added "FuncGenFunPtr" and "FuncGenMemPtr" using functions/methods with the signature "Signature<void, DynParams&, void*>". There are situations were it's not
  possible to, e.g. create a typed event handler because the types are unknown to compile time. Those two new functor implementations are using a generic
  function/method and pass the parameters by using "DynParams".
- "DynParams": Added "GetPointerToReturnValue()" and "GetPointerToParameterValue()" to make it possible to set a return value or to get a parameter if one has
  just access to the "DynParams" interface. It's of course no good idea to use generic void* pointers to access the data and whenever possible typed access should
  be used instead... but there are situations were it's really required to be generic because the types are not known to compile time.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";

        // Set return value
        if (cDynParams.GetReturnTypeID() == TypeInt32)
            *((int*)cDynParams.GetPointerToReturnValue()) = 42;
    }
  This function can then be used in the following way:
    FuncGenFunPtr<int, String> cFunctor(&GenericFunction);
    int nResult = cFunctor("He ho!");
  As you can see, using a generic function is just like using any other functor, except that the target function has a generic signature. The user
  data pointer enables the user to pass on additional data... this is a quite common approach (although it also has to be used with precaution).
- "DynEvent": Added "CreateGenericEventHandler()" which creates a generic event handler which is compatible with the dynamic event. Sadly this is only
  possible for global functions and not for class methods because we don't have any class type information available. But for my use-case it will do the job.
  Here's an example of a generic function:
    void GenericFunction(DynParams &cDynParams, void *pUserData)
    {
        // Get the value of the first parameter
        String sMessage = (cDynParams.GetParameterTypeID(0) == TypeString) ? *((String*)cDynParams.GetPointerToParameterValue(0)) : "";
    }
  And here's an example of how the new "DynEvent::CreateGenericEventHandler()"-method can be used:
    Event<String> cMyEvent;
    DynEventHandler *pDynEventHandler = cMyEvent.CreateGenericEventHandler(&GenericFunction);
    if (pDynEventHandler) {
        cMyEvent.Connect(pDynEventHandler);
        cMyEvent("He ho!");
        delete pDynEventHandler;
    }
  ... this means that if one has just access to the "DynEvent" interface, it's now possible to create an event handler which is informed when the event
  is emitted.
- PLScriptLua: RTTI signals now have some build in methods. When writing e.g.
    object.MySignal.Connect(object.OnMyEvent)
  the RTTI slot "OnMyEvent" of our RTTI class instance "object" is connected with the RTTI signal "MySignal" of our RTTI class instance "object".
  To disconnect, just use "Disconnect" instead of "Connect".



>> 09.06.2011
[CO]
PLCore:
- Until now, the constructor of RTTI signals was demanding a pointer back to their owner object. When looking at the "pl_slot_<x>"-macros, one could
  see that this provided constructor parameter was not used and I have no glue why it's there - because signals are internally just events (as also stated
  within the documentation). If there's need to know where an event came from, this information has to be provided in the event definition. Events should be as
  lightweight as possible, so storing e.g. an additional pointer within the event instance would probably not be the best idea. 
- PLScript: Lua is now an recommended external dependency and will be the script backend which is within the official PixelLight SDK. The answer for "Why Lua
  and not Python, JavaScript or AngelScript?!" is quite simple: Right now, the Lua backend is the most advanced one because Lua and it's C-API is mostly
  intuitively to use and there are tons of useful information all over the net how to integrate Lua into a "game engine". Lua is also the most compact
  of all of those mentioned script languages - the Windows dll is only 124 KiB while v8 (used for JavaScript) is 2,354 KiB! The syntax of Lua is also
  good to read and something like OOP can be done without totally unreadable tricks as required for JavaScript (did some OOP experiments within "44ScriptOOP").
- PLScript: Added "ScriptManager::GetScriptLanguageExtension()" which returns the filename extension of a given script language
- PLScriptNull: The null backend has no load and runnable scripts -> removed the "null" and "NULL" formats



>> 06.06.2011
[CO]
PLCore:
- PLScriptLua: Something like "sceneNode:SetActive(true)" is now handled correctly, meaning the boolean value "true"



>> 05.06.2011
[CO]
- *breaking change* "ElementManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)". There were already situations were the compiler wasn't able to distinguish between these two methods
  and upcoming changes/features would cause even more problems.
PLCore:
- Exposed "ConsoleApplication" to the RTTI
- Until now, C++ methods exposed to the RTTI had to be non-constant. Due to the script support, RTTI methods will now be heavily used and it's not that
  comfortable to be forced to change a method signature just to be able to expose it to the RTTI. So, within the "__pl_method_meth"-macro I cast away the
  const within the method pointer using a good old C-style cast to be as flexible as possible in here. I don't think that this introduces any security risks
  because the RTTI method just points to the real C++ method, and in there the const is still there and the compiler will blame you as usual if a non mutable
  member attribute is changed within a constant method.
- *breaking change* "ResourceManager": Renamed "Get(uint32 nIndex)" into "GetByIndex(uint32 nIndex)" and "Get(const String &sName)" into
  "GetByName(const String &sName)" (same change as in "PLGeneral::ElementManager")
- PLScriptBindings: Added "ScriptBinding_PL"
- PLScript: Removed experimental "ScriptBindingScene" because it's no longer needed. Write e.g.
      PL.GetApplication():GetScene():GetByName("Soldier")
  within a Lua script to get the scene node "Soldier". Something like
    PL.GetApplication():GetScene():GetByName("MySubscene"):GetByName("Soldier")
  will work of course as well... WOW! Stefans RTTI is *really* powerful and most script bindings will come practically
  for free... I just added
      pl_method_1(GetByName, SceneNode*, PLGeneral::String, "Returns a scene node by using the given name, can be a null pointer", "")
  within the RTTI class interface of "PLScene::SceneContainer" in order to be able to access the C++ method from inside a script.
  To avoid issues when exposing C++ methods to the RTTI I'am afraid we need to change something like
     void SetFilename(const PLGeneral::String &sValue)
  into
     void SetFilename(PLGeneral::String sValue)
  because "const PLGeneral::String &" is of course a reference, and the RTTI is using it this way (which is correct!). This is becoming a problem
  when there's no real "PLGeneral::String" instance on the method calling side... which is true for scripting. Before I start to hack around, I probably
  just change it as seen above... there's no real need for passing in a string reference anyway because the string class internally just shares
  a string buffer and therefore "copying" one string into another is blazing fast.
  -> I'am sure the "PL.GetApplication()" way is the right one for PixelLight. It results in only a few global functions (they introduce script
     initialization costs!) and the rest is completely dynamic by just using RTTI class instances (they introduce no script initialization costs!).
	 Exposing new features to script languages only requires a single, simple line of C++ code, and this line is even not just there for scripting,
	 it's generic. So, there's no need for thousands of "script proxies"/"script wrappers" in order to expose C++ stuff to scripting languages as seen
	 in many other engines with script support.
  -> In the next few days I should really spend more time on university stuff, but then I probably will start exposing the most important C++ methods
     to the RTTI (exposing this stuff doesn't blow up the memory footprint of RTTI class instances). 
	 When I'am done with it, the Lua support should already be quite usable... as for the Python, JavaScript and AngelScript support ... well,
	 I first have to figure out how to access RTTI objects in a decent way using those script APIs. The strongly typed AngelScript already produced some
	 headaches. For now, it's important to me that at least one scripting language is usable, so I focus on this point.
- PLScript: Removed experimental "ScriptBindingSceneRendererTool" because it's no longer needed. Write e.g.
      PL.GetApplication():GetSceneRendererTool():SetPassAttribute("DeferredDOF", "Flags", "Inactive")
  within a Lua script.
- PLScriptBindings: Renamed "ScriptBindingLog" into "ScriptBinding_PL_Log", "ScriptBindingTiming" into "ScriptBinding_PL_Timing" and
  "ScriptBindingSystemConsole" into "ScriptBinding_PL_System_Console" so one can directly see the resulting script namespace (I'am not sure whether or
  not the current solution will stay this way)



>> 04.06.2011
[CO]
PLCore:
- Adding a RTTI class method came with the cost of 8 bytes (32 bit build) per RTTI class instance. While e.g. RTTI class attributes really require
  per RTTI class instance data, RTTI class methods don't need per RTTI class instance data... at least as long as such a method is not called. When
  calling a RTTI class method, the RTTI class instance is required, but only then.
  One may say: "8 bytes - who cares about a few bytes?", but considering that those 8 bytes are per method and per class instance this really sums up.
  Until now, RTTI class methods were not used that often within PixelLight, so, this wasn't a real problem. For the script support, those RTTI class
  methods play an important role and I'am quite sure that all over the place a lot of RTTI class methods will be added in order to use RTTI class
  instances e.g. within scripts. With this in mind, those 8 bytes really hurt.
  So, before I start to add a lot of RTTI class methods for script support, I stopped and had a look into how to reduce the RTTI class method per
  instance memory costs. RTTI class methods are now static, meaning they only introduce a memory cost for the RTTI class itself which is not critical
  because there's only one such class instance per class. :D
  When requesting a callable RTTI class method, an instance of such an object is created on the fly. In short, memory was traded for additional memory
  allocation/deallocation - but I really think it's ok and maybe there will be more internal optimisations later.
  -> This change means, that something like
       "cMyObject.MethodTest()" or "cMyObject.MethodTest.Call(PLCore::Params<void, int, float>(20, 1.1f))"
     for calling the method "Test" though it's RTTI wrapper is no longer possible. But that's not really a loss because in those situations it's possible
     to directly call the C++ method anyway.
  -> This change also means that within constructors, it's no longer required to initialize RTTI class methods by writing e.g. "MethodLoad(this)". This makes
     exposing methods to the RTTI easier because it's only required to add e.g.
       pl_method_2(Load, bool, Chunk&, PLGeneral::File&, "Load method", "")
     within the RTTI class definition in order to access the method "Load" though the RTTI.
  -> And the most important meaning of this change: Add as many RTTI class methods as you want, your RTTI class instance won't grow into the kilobytes through that. :D
- "Object::GetMethod()" returns now "DynFuncPtr" instead of "DynFunc*"
- "Object::GetMethods()" no longer returns a list instance, instead a list instance to be filled has to be provided as parameter.
  This change avoids unnecessary copying around. Because the RTTI stuff is fundamental, it really has to be as performant as possible...
  even if this means that the interface of "Class::GetMethods()" is not identical to "Object::GetMethods()".
- Stephan found a cleanup bug within my delayed shared library loading implementation... in the case that a class dummy can't be registered because there's
  already a class dummy or even the real class, no one destroyed the created dummy class instance. This is now handled within "ClassManager::RegisterClass()".
  Uff, simple principle, that many implementation bugs - not that I had expected it otherwise... but I really hope that was the last one.
- The type ID of "TypePtr" and "TypeRef" was set to -1 instead of an unique value
- PLScriptLua is now able to deal with RTTI class instances derived from "PLCore::Object" instead of just direct pointers
  to "PLCore::Object". The current solution is not really a good one, but for now it works. I hope I'am able to figure out
  a more waterproof solution.



>> 03.06.2011
[CO]
PLCore:
-> Stephan Wezel made a PLProject refactoring (see PLProject diary for details), delayed shared library loading is now also working under Linux
   because PLProject adds the class information into the plugin-file
- PLScriptBindings: Added "ScriptBindingSceneRendererTool"... The "making of" of the dungeon demo is now done via a
  Lua script. Still experimental, but the wires begin to tie up.



>> 02.06.2011
[CO]
PLCore:
-> After an university lecture etc. maraton of two weeks and some non script related PixelLight work, back to the script stuff. :)
- PLScript: "Script::SetGlobalVariable()" has now as parameter the more generic "PLCore::DynVar" instead of "PLGeneral::String"
- PLScript: Renamed "Script::GetGlobalVariableType()" into "Script::GetGlobalVariableTypeID()" so that it's similar to e.g. "PLCore::Var::GetTypeID()"
- PLScriptLua: "Script::SetGlobalVariable()" now also supports "PLCore::Object*" and is able to add new global variables
  (one can use e.g. "Script::IsGlobalVariable()" to check whether or not there's such a variable before setting one to avoid adding a new
  global variable if this is not desired)
- "PLScriptBindings::SNMScript" now adds the global variable "this" to the script so that it's able to access "this" RTTI class instance,
  meaning the script scene node modifier
- PLScriptV8 & PLScriptPython: "Script::SetGlobalVariable()" is now able to add new global variables



>> 29.05.2011
[CO]
- Added "Stopwatch::Stopwatch(bool bStartAtOnce)" to make it possible to use the stopwatch in a more compact way
- "StringBufferManager::ReleaseStringBuffer()": Activated the string buffer management under MS Windows because, especially when
  debugging, this adds a real performance boost like e.g. 2 sec instead of 20 sec to start an application in debug mode.
  (so, this string management is nothing optional - without it, it's just painful to debug more complex applications)
  Under Linux, I currently just get a segment fault when starting an application with enabled string buffer management - so it's deactivated
  under Linux for now because I don't have the time to do intensive debugging at the moment, but I really need to be able to do decend debugging
  under MS Windows...
- Ok, "StringBufferManager::ReleaseStringBuffer()" is now working under Linux as well... there was a really stupied bug which caused the UTF8
  string buffer to lie about it's type...
PLCore:
- Added parameters to the plugin relevant "ClassManager"-methods to make it possible to e.g. disable delayed shared library loading
- Added an option to "ConsoleApplication" to make it possible to configure whether or not it's allowed to perform delayed shared library loading to
  speed up the program start ("DelayedPluginLoading" within the configuration file)
- The "ClassManager"-destructor has to destroy the class implementation dummies, the real classes are destroyed automatically by the RTTI system
  (see "pl_class" -> "__pl_guard"). Stephan Wezel helped me in identifying those (hopefully) last bugs in the refactored "Class"-class and helped
  testing the stuff under Linux as well as fixing some details, a huge thank's for the motivating support. :D
-> It looks like the delayed shared library loading is really working quite fine and it's finally fun again to do debugging because the program start
   doesn't take half a minute. I hope I'am now able to focus back to complete the scripting stuff and fix some general bugs like the one described at
   http://dev.pixellight.org/forum/viewtopic.php?f=6&t=48&p=153#p153
   ... the time until the next planned PixelLight release is running, but it was really important to me to speed up the program start time in order
   to be able to debug in a resonable way.



>> 28.05.2011
[CO]
PLCore:
- Continued "Delayed shared library loading"-refactoring: Currently, "LoadableManager" forces many plugins to be loaded in order to register
  loader instances. To delay the plugin loading, "Loader" is now just a proxy and "LoaderImpl" the real loader implementation. This way, the available
  loader implementations are registered correctly, but the actual loader implementations which require to load in the shared library are only
  created when really required.
- The RTTI interface for "Object" was defined as
    pl_class_internal(Object, "PLCore", "", "Object base class")
  and the result was that the base class of "Object" was "" instead of <no base class>, meaning an empty string. I changed it to
    pl_class_internal(Object, "PLCore", , "Object base class")
  ... although it looks somewhat strange, it's correct this way.
- "ClassImpl::GetBaseClass()" is no longer calling "InitClass()" to enhance the chance that a RTTI class is never initialized



>> 26.05.2011
[CO]
PLCore:
- Started "Class" refactoring... There are now a lot of PixelLight plugins within the Git repository and by default, they are all loaded within
  "ConsoleApplication::OnInitPlugins()" so that it's possible to create RTTI class instances. While this behaviour is quite comfortable
  because plugins can be used automatically by just throwing the loose plugins into a scanned directory, it's also quite slow at program start.
  (although there are already several internal optimizations in place like delayed RTTI class initialization!)
  Usually only a few plugins are really used during runtime, but in order to be able to create RTTI class instances it's required that the system
  knows which RTTI classes are actually available. Currently, this requires to load in the shared library which may cause the loading of other
  shared libraries. (domino effect) Due to the increasing number of loose PixelLight plugins, the program start time starts to get annoying long
  - especially in debug mode. My plan was to focus on the script implementation, but I'am not able to try out and debug stuff in reasonable time
  because each program start takes several seconds, even if there's actually not happening much in an application. Of course, it would be possible
  to just "deactivate" plugins, but such hacking around would cost time as well and would be error prone. So, it's probably time to add another
  RTTI initialization speed up optimization: Delayed shared library loading
  This was actually planned for several years, but there were always more important things to do - like getting the RTTI to the point were it's
  really cool and powerful. Stefan accomplished that. The "new" RTTI system is now several months in use and works really well, so, it's now probably
  really time to implement this delayed shared library loading thingy to speed up the program start when there are a lot of optional loose plugins
  available. (which is now the case)
  The delayed shared library loading should be transparent to the user, meaning that it should happen automatically on the fly so that the user don't
  need to care about it. So, as the first refactoring step I applied the bridge design pattern to "Class" and moved the previous implementation
  into the implementor "ClassReal". The RTTI system still creates automatically class instances, but they are now derived from "ClassReal" instead
  of "Class" which is now just a class implementation wrapper. Looks like everything is still working as before. This change makes it possible to
  secretly change the internal class implementation... the next step is to add class metadata into the "plugin" file and when loading a plugin,
  this metadata is used to create dummy class instances without actually loading the shared libraries the RTTI classes are implemented in. The real
  RTTI class instance is only created by loading in the shared library when really required, e.g. when an instance of the RTTI class has to be created.
  In this case, the internal class implementation is changed - but the "Class" instance the user is working with will be still the same. This should
  speed up the program start.
- Added "pl_module_delayed()"-macro and the plugin file option "Delayed" which is "true" by default
- Renamed "ClassManager::LoadPluginLibrary()" into "ClassManager::LoadModule()" and made it public
- Add RTTI class metadata within the XML plugin file
- Wow, already done! Delayed shared library loading is working! The startup time of e.g. "01Application" is now better.
  (it's of course only faster when not all available plugins are used)
-> I'll do some more testing before I upload this change (although the next two days I'am quite busy with university, again :/)



>> 24.05.2011
[CO]
- The "DynLib" implementations were not unloading the dynamic OS library automatically. I thought about this issue to figure out whether
  it's acutally a "feature", but this really looks like an adverse behaviour because e.g. something like "File" is closing the opened file
  automatically.
PLCore:
- "ClassManager": Moved plugin file format version 1 loading code from "LoadPlugin()" into a separate method "LoadPluginV1()"
- "ClassManager": Moved plugin library loading code from "LoadPluginV1()" into a separate method "LoadPluginLibrary()"
- "ClassManager": There was a memory leak during plugin library loading: The ownership of the created instance of the dynamic
  library was given to the created "Module" instance, but "Module" never destroyed the given instance of the dynamic library.
- "ClassManager": No one was destroying the module instances, so this is now done within the "ClassManager"-destructor
- Made the "Module" constructor and destructor private because only the class manager is responsible for managing the modules
- The "Module" destructor was virtual, but there's no reason for that



>> 22.05.2011
[CO]
PLCore:
- PLScript: Woho, the demo "Scripts.scene" comes to live... "ScriptsScene.lua" is already up and running and is manipulating a scene
  node by using a Lua script. It's still everything experimental to see what's possible and how it may work as a whole
  system.
- Added PLScriptBindings plugin which exposes certain parts of PixelLight to script languages. This means that the script bindings
  are a 100% loose plugin and are not within the core. First I thought about adding some basic script bindings directly into PLScript and
  other script bindings into the PLEngine project which brings together the individual components to an easy usable framework. But
  this way the standard PixelLight script bindings would be scattered over multiple projects and there would also be the risk that the
  completly optional script support may accidentally grow into the core over the time. This way, it will probably also easier for other
  people to contribute to the script bindings part.



>> 21.05.2011
[CO]
PLCore:
- "TypeObjectPtr" & "TypePtr" & "TypeRef": "ConvertFromVar()" is now using "GetUIntPtr()" instead of "GetInt()" (this was a [TODO] point)
- PLScript: Worked on "PLCore::Object*" support



>> 19.05.2011
[CO]
PLCore:
- DynEvent: Added "void Emit(const PLGeneral::String &sParams)" and "void Emit(const PLGeneral::XmlElement &cElement)" to make it possible to emit
  events when one just has a DynEvent pointer
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynEvent" to make it possible to request some more information about the dynamic function
- Warning, breaking event change: I had to change "void Emit(_T0 t0, _T1 t1)" into "void operator ()(_T0 t0, _T1 t1)" etc. because when not doing so, the compiler
  failed to see the difference between e.g. "Emit(String)" and "Emit(String)", ok, maybe there isn't one. This issue has to do with the
  "void Emit(const PLGeneral::String &sParams)" change above - but those non typed call methods are really required. I don't wanted to rename those methods
  into e.g. "void EmitString(const PLGeneral::String &sParams)" because it felt unnatural to me and by the way, "DynEvent" is quite similar to "DynFunc" -
  at least within the usage. Whenever possible I try to avoid such breaking changes, but sometimes they are required to avoid that stuff gets uggly.
  So, to call e.g. an event named "MyEvent" call "MyEvent()" (if you have ever used boost, you are already familiar with this way :) instead of "MyEvent.Emit()".
- PLScriptLua: Calling RTTI object methods within Lua scripts is working... currently only slow progress because the university is using most of my available
  time. But I still try to get the script support up and running until the next scheduled PixelLight release. :D
- PLScriptLua: Calling RTTI object signals within Lua scripts is working



>> 17.05.2011
[CO]
PLCore:
- PLScript: Added "Script::PushArgument(PLCore::Object *pObject)" and an experimental Lua implementation to get an idea how to access RTTI objects
  directly within scripts *work in progress*



>> 16.05.2011
[CO]
- Removed "long" methods within the "String" and "Tokenizer" classes to avoid compiler issues with 64 bit data types
  (a compiler may actually define a 64 bit data type as long, and then there's no way to distinguish long from long *g*)



>> 13.05.2011
[CO]
- "String": Added "int64"-support
PLCore:
- "PLCoreDefinitions.h": Added "TypeInvalid"
- PLScript: "Script:" Added support for global variables. At first I thought about adding "GetGlobalVariable()" & "SetGlobalVariable()" versions
  for the supported primitive data types - but this would result in a total copy'n'past overkill within the internal implementations. Those
  string methods should do the job (the internal implementations try to don't change the script variable type).
- PLScript: Renamed "Script::AddDynamicFunction()" into "Script::AddGlobalFunction()" and "Script::RemoveAllDynamicFunctions()" into "Script::RemoveAllGlobalFunctions()"



>> 12.05.2011
[CO]
PLCore:
- Added "GetNumOfParameters()" and "GetParameterTypeID()" to "DynFunc" to make it possible to request some more information about the dynamic function
- Added "PLScriptLua::Script::LuaStackDump()" which writes the current Lua stack content into the log



>> 11.05.2011
[CO]
PLCore:
- PLScript: The "ScriptManager" creates now instances of all found "ScriptBinding" classes
- PLScript: Added "Script::AddBindings()" to bind all available "ScriptBinding" instances at once
- PLScript: By default, "ScriptManager::Create()" and "ScriptManager::CreateFromFile()" binds all available "ScriptBinding" instances at once



>> 08.05.2011
[CO]
- A while ago, Stephan reported me an issue with double slashes within filenames - finally I found some time to have a look into it.
  Something like "PLGeneral::File("e:\\1//Test.jpg").Exists()" failes. Because I wasn't sure whether or not this behaviour is "correct"
  (the filename looks kinda messy) I first tested the same with boost by writing "boost::filesystem::exists("e:\\1//Test.jpg")" and with
  Qt by writing "QFile("e:\\1//Test.jpg").exists()" and "QUrl("e:\\1//Test.jpg").isValid()". For boost and Qt a filename like
  "e:\\1//Test.jpg" is totally fine.  	
  Next I tried to find a description which behaviour is "correct". As usual, found first information at Wikipedia:
    "http://en.wikipedia.org/wiki/URL_normalization" (from 2011-05-08)
      "Removing duplicate slashes Paths which include two adjacent slashes should be converted to one. Example:
       http://www.example.com/foo//bar.html → http://www.example.com/foo/bar.html "
  I wasn't able to find this in standards like RFC 3986 (http://tools.ietf.org/html/rfc3986#section-6) - but I was searching only a few
  minutes. After this research I "assume" that removing duplicate slashes is fine, at least this way there's within PixelLight the same
  behaviour as in boost or Qt.
  -> Made a minor change within the "Url::SetValue()" implementation.
PLCore:
- PLScript: The AngelScript add on source codes are now within "External\Optional\AngelScript\add_on" directory instead within the to download external package.
  CMake told me that it wasn't able to find those add on source codes... because it was checking BEFORE downloading and extracting the external package. Maybe
  it's possible to change the CMake script... but that's somewhat too dangerous for me and usually really time consuming to get it right.



>> 07.05.2011
[CO]
PLCore:
- Implemented "PLScriptPython::Script::AddDynamicFunction()" namespace by using Python dictionaries... probably not the best solution but for
  now I just want to have it up and running to get an idea of concepts multiple scripting languages are sharing. Maybe I'll replace "namespace"
  later by "module".
- Implemented "PLScriptV8::Script::AddDynamicFunction()" namespace by using V8 object template
- Implemented "PLScriptAngelScript::Script::AddDynamicFunction()" namespace. It looks like that AngelScript (2.20.2) has currently no support
  for namespaces... so right now I'am doing an ugly hack: e.g. "PL.Timing.GetTimeDifference()" is written within scripts as "PL_Timing_GetTimeDifference()". :/
-> Ok, the namespace support for global functions is now implemented within all script backends... although I'am really not happy with the current
   AngelScript solution (e.g. "PL_Timing_GetTimeDifference()" instead of "PL.Timing.GetTimeDifference()") and Python solution
   e.g. "PL[’Timing’][’GetTimeDifference’]()" instead of "PL.Timing.GetTimeDifference()"). It's really time consuming to do the research into multiple script
   API's at the same time and on those two issues I already spend several hours without a decent solution. So, if there's someone who knows a better solution...
-> Right now my candidates for the "recommended PixelLight script language" are JavaScript and Lua. Lua is quite compact while JavaScript is a web-standard which
   could be somewhat beneficial for PixelLight, especially regarding to the browser plugin. AngelScript looks somethat unfinished although I like the API in
   general. Python is just a monster. *g*
- PLScript: "Script": Added string versions of "PushArgument()" and "GetReturn()". Adding support for this within PLScriptAngelScript was some hard work because unlike
  JavaScript (V8), Python and Lua, within AngelScript strings are just "add_on" and not everything is documented as detailed as I wished for and I wasn't able
  to find real help via google as well. So I had to guess, review the AngelScript source codes and perform some debugging... I really hope that I didn't miss
  anything...



>> 06.05.2011
[CO]
PLCore:
- PLScript: Added "ScriptBinding" which is actually a blank RTTI class. RTTI classes which are only used for "script binding" should be
  derived from this class. This doesn't mean that it will be impossible to bind any other RTTI class instance to a script - but usually
  it's useful to have such an abstract base class...
- PLScript: "Script::AddDynamicFunction()": Added namespace as last optional parameter (backend implementations will follow)
- PLScript: Added "Script::AddBinding()" which adds a script binding to connect the given RTTI class instance with this script (currently only RTTI
  methods are used)
- Implemented "PLScriptLua::Script::AddDynamicFunction()" namespace by using Lua tables



>> 02.05.2011
[CO]
PLCore:
- "DynFunc": Added "GetReturnTypeID()" to make it possible to figure out the return type (e.g. "TypeNull" for "void()" or "TypeInt" for "int()")
  of a dynamic function
- Python backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- V8 (JavaScript) backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
-> The Lua, Python, AngelScript and JavaScript backends are now equal in the implemented behaviour. It's possible to call script functions
   from the C++ side, and it's also possible to call C++ functions from the script side. I'am quite sure that this isn't everything one
   requires when working with script engines, but it's a start. I have to take a break for a couple of days due to university stuff, then
   I continue working on PLScript.



>> 01.05.2011
[CO]
PLCore:
- AngelScript backend: Implemented "AddDynamicFunction()" and "RemoveAllDynamicFunctions()"
- Python backend: Calling Python functions is working



>> 30.04.2011
[CO]
- "String": Added pointer constructor "String(void *pValue)"
PLCore:
- "Functor"-Templates: Added "Clone()"-Implementation
- "DynFunc": Added protected copy constructor and copy operator to avoid misuse, made the default constructor protected as well to avoid confusion
- "DynFunc": Added "PLGeneral::String" and "PLGeneral::XmlElement" parameter versions of "CallWithReturn()". When using
  "DynFunc::Call(const PLGeneral::String &sParams)" or "DynFunc::Call(const PLGeneral::XmlElement &sParams)" there's absolutely no chance to get any
  function return values because there's no type information. Currently I'am using "DynFunc::Call(const PLGeneral::String &sParams)" within the work
  in progress PLScript to let a script call a given C++ function/method and really need at least a string representation of the result which I can give
  back to the script API. I really hope that those "CallWithReturn()" template methods don't backfire... right now it appears that there are no side
  effects during template instantiation. I could have added the string return directly into the already existing methods, but I wasn't comfortable
  with that.
- PLScript: Added script support for functors/functoids so that it's possible to call C++ functions or member methods from inside scripts...
  as well as other script functions because the functors are hiding this detail.
  The method "Script::AddDynamicFunction()" is used to register functors while "Script::RemoveAllDynamicFunctions()" can be used to remove
  all registerd functors. The Lua implementation is already working. Please note that this is still highly experimental and I don't know
  whether or not the script interfaces are completly changed later.



>> 29.04.2011
[CO]
- Added "File::GetContentAsString()"
PLCore:
- Moved "OpenFile()" from "Loader" into "LoadableManager" because it's kind of universal
- Moved "LoadStringFromFile()" from "PLRenderer::EffectPass" into "LoadableManager" because it's kind of universal
- "SignatureString": "PLGeneral::String GetSignatureID()" constructed internally the signature string on every call. But during runtime, this
  must only be done once and then the signature can just be reused. So, the internal signature string is now static to enhance performance. I
  double-checked the change, used the debugger a few times on it to see and think through the performed steps and tested the existing PixelLight
  projects as well. It looks like that this change has no side effects.
- PLScript: Added "GetScriptLanguage()", "GetSourceCode()" and "SetSourceCode()" to "Script" (similar to "PLRenderer::Shader")
- PLScript: Added "FuncScriptPtr" which is a version of "PLCore::FuncFunPtr"/"PLCore::FuncMemPtr" for script functions. This means that script functions
  can be called in the same way as all other functions/methods (e.g. RTTI methods) can be called. This template is using
  the "Script" methods "BeginCall()", "PushArgument()", "EndCall()" and "GetReturn()" to call script functions. Calling Lua and AngelScript
  functions is already implemented and working. Those mentioned script function calling methods are currently public although it's not recommended
  to call them without using "FuncScriptPtr", but currently I see no change to hide those methods from the user. But this is just my first attempt to
  get things up and running... next stop: Implementing the same for Python and JavaScript. (calling C/C++ methods from scripts will follow as well)
- PLScript: Calling JavaScript functions is working... although the implementation is currently somewhat poor... having some issues getting into the V8-API...



>> 28.04.2011
[CO]
- "FileWindows::GetSize()" is now using the MS Windows API functions "_filelength" and "_fileno"
PLCore:
- PLScript: As requested within the PixelLight forum at: http://dev.pixellight.org/forum/viewtopic.php?f=3&t=45
  ... I'll also added a script backend for AngelScript (like the others, just a skeleton right now!). Ok, four script languages should really
  be enough to get a good script interface.



>> 26.04.2011
[CO]
PLCore:
- PLScript: Compiled 32 bit versions of Lua, Python and V8 (JavaScript engine) for Windows and Linux. Configurated everything so that the script
  projects can be compiled and are able to run.
  Next stop: Concrete script implementations :D



>> 25.04.2011
[CO]
PLCore:
- Started the PLScript project. As usual there's a null backend and I'll implement backends for Lua, JavaScript and Python in parallel.



>> 19.04.2011
[CO]
- Removed "_DEBUG" preprocessor tests within the String and String Buffer class



>> 15.04.2011
[CO]
- Premier: First entry within the tracker ("Bugs"-category) at http://sourceforge.net/tracker/?group_id=507544
  -> Bugfix (ID: 3286541): "PLGeneral::XmlElement::GetLastAttribute()" was returning the first instead of the last attribute



>> 10.04.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitData()" is now using English as the default language instead of the current system locale, this makes things more predictable



>> 08.04.2011
[CO]
PLCore:
- Added "ResourceManager::EventResourceRemoved"-event which is called when a resource is going to be removed



>> 09.03.2011
[CO]
- Url-class: Nearly over a year ago, a client reported that a client reported (jap :) that UNC (Uniform Naming Convention aka Universal
  Naming Convention) support was not working. At this time, I never had heard of UNC before and there was not really time to look into it
  in more detail - so, a hack on the client side had to do the job. Today, why ever, I was really curious what's the issue with UNC.
  After looking what exactly UNC is all about (I usually don't have to do anything with network related stuff), I made some experiments
  (also with "QUrl" from Qt) and figured out, that the only problem seemed to be within the "Url::SetValue()"-method while parsing the
  given URL. After spending some hours to get into regular expressions again and looking for pitfalls that may occur, I added UNC parsing
  support to the Url-class. Now, the following works for me
    System::GetInstance()->SetCurrentDir("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test");
  As well as
    File cFile("\\\\COFENBERG-PC\\Users\\COfenberg\\UNC_Test\\Test.txt");
    if (cFile.Open(File::FileRead|File::FileText)) {
        String sText = cFile.GetS();	// -> sText = "Hello" :D
    }
  I don't know whether or not my change within "Url::SetValue()" is perfect... in general, I wanted to keep the required implementation change 
  as compact as possible.



>> 02.03.2011
[CO]
- As noticed by a PixelLight user, the data type returned by "System::GetMicroseconds()" was "uint32" which is critical for the stored data
  and "unsigned long" is commonly used instead. So, methods like "System::GetMicroseconds()" are now using "uint64" instead of "uint32".
  It's really cool to get feedback on how to improve PixelLight, keep up providing feedback! :D



>> 26.02.2011
[CO]
- StringBufferASCII is now using "memcpy" instead of "strncpy" because "memcpy" is usually slightly faster as "strncpy"
  (checked usual implementations of those functions). Within this class, it's guaranteed that the values are correct, so there's no security
  risk in using "memcpy". I know, the difference is not really measurable, but I always try to squish out everything possible out of such
  basic implementations.
- StringBufferUnicode is now using "memcpy" instead of "wcsncpy"
- Added some more String constructors to make it easier and "more intiutive" to create a string out of a number
- Had a look into "sprintf" (a variation is used within "String::Format()") and "itoa" (non-standard extension to the standard C). In certain
  situations, "sprintf" has no chance to come near to the performance of "itoa" - which is obvious because "sprintf" is more universal and powerful.
  The following example took 880 ms
    for (int i=0; i<100000; i++)
        String sMyString = String::Format("The number %d is fantastic!", 42);
  while the following example took 129 ms
    for (int i=0; i<100000; i++)
        String sMyString = String("The number ") + 42 + " is fantastic!";
  after using "itoa" in the internal String implementation. I think there's a notable performance difference in the second version which is worth to
  talk about. :D



>> 25.02.2011
[CO]
PLCore:
- "ConsoleApplication": Moved "Write some general information into the log"-step from "OnInit()" to "OnInitLog()". It was a little bit
  confusing that initial information like "Log-system started" was written somewhere at the end of the initialization phase.



>> 22.02.2011
[CO]
PLCore:
- "ConsoleApplication::OnInitPlugins()": The PixelLight runtime directory is now also scanned non-recursively for plugins. This is quite useful
  for projects which can be used completely dynamically, but can also be used in other C++ projects to access certain features. This behaviour is
  also symmetric to the application directory scan.



>> 17.02.2011
[CO]
- Program entry point within "Main.h": Removed "setlocale(LC_ALL, "");" because I don't think that it's a good idea to use "setlocale".
  This is up to the user and the user is also responsible for the consequences when changing the current locale...
- String internals: Sadly, the current set locale is of course also an issue on all operation systems. It would be fantastic if we never
  ever would come into contact with "setlocale" at all, but sadly, the user can and possibly WILL change the current set locale and then
  hell breaks lose because e.g. "42.21" will be written as "42,21" and possibility written e.g. into a XML file... on another side "42,21"
  is read from the same XML file and boom, invalid floating point number due to the use of another locale. To be honest, I really hate this
  topic but sadly, I can't just completely ignore it forever.
  Today I was remembered, again, why we decided to wrap EVERYTHING within PixelLight so more complex projects can use a consistent framework...
  Just an example: MSVC has some cool string functions like "_sprintf_l", on Linux there are some similar functions allowing you to directly
  provide the locale to use as a parameter (other systems like Android OS, don't offer such stuff, of course!), instead of using an ugly global
  setting. But sadly, there's no standard for that. So I backup the current set locale by using "strdup" before changing it (evil dynamic memory
  management, but currently I see no other simple solution)... but wait, now VC tells me the following:
    "warning C4996: 'strdup': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strdup. See online help for details."
  Cool, the VC compiler tells me "Do NOT use POSIX, it's evil!". Because I don't like dozens of "#ifdefs" either, I just
  suppressed this stupid warning. Low level C/C++, one just must love it! *gruml*
  Sadly I'am afraid that the locale changes from today are no real solution, and something like a locale class is required... but for now, I
  just have enough of this topic...



>> 01.01.2011
[CO]
- Renamed the method "Mutex::Lock()" with a timeout as parameter into "Mutex::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received
- Added "PLGeneral::MutexGuard" helper class using the really cool "Scoped Locking"-idiom which can make the code more compact while
  also increasing the maintainability
- Renamed the method "Semaphore::Lock()" with a timeout as parameter into "Semaphore::TryLock()" so one can see that it's really wise to
  check whether or not a lock was actually received...



>> 29.12.2010
[CO]
- Removed "String::Unknown"-definition, it was only used once internally and less variations are usually the better choice
- Removed "String::UTF8"-definition
- Removed "utf8" data type
- "String": Refactoring of the UTF8 support, in fact reduced the support to the two methods "GetUTF8()" and "SetUTF8()"
- "QtStringAdapter" is now using UTF8 instead of wchar_t to avoid the need to recompile Qt or PixelLight with other compiler settings



>> 18.12.2010
[CO]
- "PLGeneralWindows.h": If "_MSC_VER" (VisualStudio) or "_WCHAR_T_DEFINED" is not defined, "wctype.h" will be included for
  "wchar_t". Now PLGeneral can be used within for example QtCreator at once.
- Added a static adapter class within PLGeneral for mapping Qt strings to PixelLight strings and vice versa



>> 17.12.2010
[CO]
- Added unicode support to "FileLinux", "FileSearchLinux", "ConsoleLinux", "DynLibLinux", "SystemLinux", "FileStdStream", "Log",
  "ConsoleWindows" and "Process"



>> 12.12.2010
[CO]
PLCore:
- Loadable-System: At the PixelLight mailing list (pixellight@lists.pixellight.org), a discussion about case-sensitive file-extensions
  came up. In general, while for instance UNIX like systems have case-sensitive file systems, MS Windows does not. At the
  beginning of the development of PixelLight, we made the design decision that PixelLight should be case-sensitive in general
  to avoid porting problems across multiple-platforms. Naturally, for MS Windows only users, this leads to confusion when
  they try to load in, for example an image named "MyImage.JPG", and nothing happens although the jpg file format is supported.
  The reason behind this is, that the file extension is used to figure out which loadable implementation is responsible for
  loading the concrete data. In this case, "jpg" tells the (plugin based) system to use "PLGraphics::ImageLoaderJPG" to load
  in the data. The extension string test is case-sensitive, and as such, "JPG" is unknown to the system.
  Ideas came up to add an option to make the extension case handling configurable, or to make file extensions in general case-insensitive.
  I did some research on the topic to see how other developers handle this situation or think about this - as expected, there are a lot
  of different opinions about "what's best".
  I thought about the issue, and I see the point that this can be a problem using a lot of content - to be honest, from time to time
  I have some "problems" with this as well. For example, "The Compressonator" (http://ati.amd.com/developer/compressonator.html) from ATI (ok,
  AMD nowadays *g*) always wants to write "DDS" instead of "dds" as file extension.
  In my opinion, I still think that it's no good idea to weaken the "PixelLight is in general case-sensitive" design decision and adding a huge
  comment that this is the one and only place within PixelLight were it's handled by using strategy A instead of strategy B. I really think that, on
  the long term, this will cause more problems than solving them.
  Fortunately, the loadable system already supports multiple aliases for one and the same file format. For example "PLGraphics::ImageLoaderJPG"
  can be addressed by using "jpg", "jpeg", "jpe", "jif", "jfif" or "jfi" as jpg file extension. So, why not add "JPG", "JPEG", "JPE", "JIF", "JFIF"
  and "JFI" as well? Of course, something like "JpG" will still not be recognized, but I can't remember a program using this case convention... and
  as a computer scientist, I love orderliness and don't really want to support spelling chaos intentionally. I saw that some other developers are
  using this solution as well, and I think it's a good compromise - it doesn't weaken a general system design decision by adding an exception, but
  it allows to use for example "JPG" instead of just "jpg", too.




/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 06.12.2010
[CO]
PLCore:
- DynEvent um "GetNumOfConnects()"-Methode erweitert, bei z.B. Profiling ist es hin und wieder interessant zu
  erfahren wie viele Connections gerade vorhanden sind



>> 04.12.2010
[CO]
- Beim über die Codes "schweifen" (hin und wieder passiert mir soetwas unbeabsichtigt *g*) vielen mir in der String Klasse ein
  paar Stellen wie z.B. "if (pszFormat && strlen(pszFormat))" auf. Sinn ist hier eigentlich nur rauszufinden ob direkt das erste
  Zeichen im String eine terminierende Null ist - die String länge braucht man hier gar nicht. Änderte diese Stellen daher in
  "if (pszFormat && pszFormat[0] != '\0')" - spart einen Funktionsaufruf und ändert die komplexität hier von n zu 1 da nicht mehr
  im String nach '\0' gesucht werden muss. Interessant das mir das noch nicht vorher ins Auge gestochen ist. *g*



>> 29.11.2010
[CO]
- "Stopwatch::Stop()"-Bugfix: Wenn die Stopuhr gerade nicht läuft, und man "Stop()" aufruft sollte natürlich "0" als gemessene
  Zeit zurückgegeben werden...
-> Die im Tagebucheintrag vom "30.10.2010" angesprochenen String Optimierungen angepackt...
- StringBuffer: "Append()" hinzugefügt, wenn immer möglich wird in der String-Implementation nun "Append()" verwendet da dessen
  Implementation einfacher gehalten ist (wodurch Optimierungen und bessere Performance leichter zu realisieren sind)
- StringBuffer um "m_nMaxLength"-Variable erweitert, damit ist es nun möglich, dass ein String Buffer intern größer ist als der
  tatsächlich gespeicherte String. Hintergrund ist, das Speichermanagement teuer ist und derzeit die String Klasse für ein paar
  Dinge performancemäßig leider unbrauchbar ist. Da wir meist nur ASCII nutzen, konzentriere ich mich erstmal auf Optimierungen
  für ASCII Strings - aufgrund des Umfangs der String Klasse, wird es sicherlich nen bischn dauern bis alles etwas flotter geht.
  Oft werden mehrere Strings konkateniert, hier zeigte die String Klasse performance mäßig deutliche schwächen. Sinnfreies aber
  einfaches Beispiel:
    String sString;
    for (int i=0; i<100000; i++)
      sString += 'a';
  Vor dem Beginn der Performance optimierungen dauerte das im Release Modus unglaubliche 2995 ms. Nach dem einbauen von "Append()"
  noch 2757 ms, und sobald bei "Append()" intern Speicher für zukünfige Zeichen reserviert und dann genutzt wurde nur noch
  47 ms. Das zeigt denke ich, dass es Sinnvoll ist diese Optimierung weiterzuverfolgen da es doch schon ein deutlicher Unterschied ist -
  gerade bei großen Datenmengen! (der Code wird dadurch aber leider nicht einfacher oder gar weniger :/)
- StringBufferManager hinzugefügt. Zukünftig sollten StringBuffer-Instanzen nur noch hierüber erfragt, und sobald nicht mehr benötigt
  hierhin zurückgegeben werden. Sobald man einen StringBuffer benötigt, fragt man einfach den StringBufferManager nach einer StringBuffer
  Instanz die eine bestimmte String länge halten kann... es obliegt dann dem StringBufferManager zu entscheiden ob man einen Buffer
  mit GENAU der länge zurückbekommt, oder einen Buffer der *mehr* halten kann. Es ist ebenfalls dem StringBufferManager überlassen ob
  er gerade nicht benötigte StringBuffer Instanzen buffert statt sofort zu löschen, um dann diese wiederverwenden zu können um dynamisches
  Speicher anlegen/freigeben zu reduzieren. Durch den StringBufferManager wurde hier und da die Implementation der String Klasse etwas einfacher. :D
  Die StringBuffer-Klasse hat eine statische Instanz von StringBufferManager und StringBufferManager speichert gerade nicht benötigte
  StringBuffer Instanzen zwischen - das ist momentan eher noch Experimentiell und sicherlich definitiv nicht optimal (u.a. weil die statische initialisierungs
  und deinitialisierungs Reihenfolge ja nicht festgelegt werden kann), läuft aber bereits halbwechs ordentlich und reduziert das dynamische anlegen
  und freigeben von Speicher zur Laufzeit.
-> Uff, das waren nun fast 14 Stunden am Stück mit Strings jonglieren, aber ich denke es ist schonmal besser als vorher, vorallem wurde die Implementation
   an einigen Stellen deutlich überschauberer. Das mit Strings intern mehr Speicher geben + StringBufferManager wollte ich nun schon seit Jahren mal
   ausprobieren... und da mir wiedermal aufviel wie laaaam die String Klasse stellenweise ist/war, hatte ich mich nun endlich einfach mal drangesetzt und
   es durchgezogen. Ich merke hier bei mir nun eine allgemeine leichte Performance verbesserung... wie gehofft. :D
   Morgen mal noch etwas weitertesten, aber bisher siehts so aus als ob sich durch das interne String-Refactoring (das Interface nach Außen hin hat sich
   nicht verändert!) keine total üblen Bugs eingeschlichen hätten die sofort alles zum Crashen bringen.



>> 14.11.2010
[SB]
- String::Format(): Hier gab es einen Bug, da nicht darauf geachtet wurde, dass laut Dokumentation die Funktion
  _vscprintf (und alle anderen Funktionen dieser Art) das Handle für die Argumentenliste "zerstört". Daher muss
  nach dem Aufruf von _vscprintf die Argumentenliste beendet und dann wieder neu geöffnet werden. Unter 32 Bit Linux
  sowie unter Windows gab es hier niemals irgendwelche Probleme, aber unter 64 Bit Linux stürzte das ganze hier auf
  mysteriöse Art und Weise ab. Wäre schon nett, wenn solche Dinge dann vielleicht nicht nur irgendwo in der Doku versteckt
  wären, sondern auch verlässlich abstürzen würden, damit sowas nicht völlig unentdeckt bleiben kann ;-)
  Zu diesem Fehler: http://bytes.com/topic/c/answers/572931-segmentation-fault-vsnprintf-lib64-tls-libc-so-6-a



>> 04.11.2010
[SB]
- XmlAttribute: Die Funktion sscanf_s ist eine Microsoft-Erweiterung und daher
  unter anderen Systemen nicht vorhanden. Habe das daher erstmal in sscanf()
  umgewandelt, vielleicht könnte man hier natürlich auch eine von unseren
  bereits vorhandenen Varianten verwenden, um Strings in Zahlen zu konvertieren?
  Die String-Klasse hat soetwas ja schon, alleine schon daher würde ich daher
  empfehlen, in Zukunft möglichst auf low-level String-Funktionen zu verzichten.



>> 30.10.2010
[CO]
- Wie mit Stefan besprochen: TinyXML Abhängigkeit entfernt. Das hatten wir nun bereits seit etlichen Jahren angedacht... TinyXML ist zwar
  wirklich super, aber unsere eigenen Ansprüche verändern sich über die Zeit so das immer mehr Änderungen in TinyXML nötig wurden um es in
  PL noch richtig nutzen zu können. Die XML Wrapper Schicht an sich war auch noch nie sooo toll da diese Overhead hinzufügte. Nachdem Stefan
  nun probleme beim Einladen großer XML Dateien hatte, entschlossen wir uns dazu, die TinyXML Abhängigkeit nun zu entfernen um mehr Kontrolle
  über die XML Implementation zu haben und z.B. einfacher Problemen nachgehen zu können. Der Kern des XML Parsers basiert auf TinyXML damit ich
  nicht ganz bei 0 anfangen musste und auf einen über viele Jahre hinweg ausgereiften XML Parser aufbauen kann, ich denke das die Implementation
  auf Dauer allerdings immer weiter von TinyXML abdriften wird.
  Das war nun zwar ca. 2 Tage Arbeiten an Grundlagen-Klassen, aber ich denke es hat sich gelohnt da unsere grundliegenste Komponente nun von
  einer externen lib weniger Abhängt was das Cross-Compiling etwas einfacher macht. Die erzeugte PLGeneral dll ist bei mir um 10 KB kleiner geworden
  da weniger Redundanter Code vorhanden ist (mehrere String Klassen etc. da jede lib das nochmal selbst implementiert).
  -> Weis noch nicht ob Unicode XML Dateien schon korrekt funktionieren, da müsste man etwas testen und gegebenenfalls ausbessern
  -> Das XML Laden (XmlDocument::Load) ist im Augenblick etwas langsamer als vorher da unsere String Klasse bei z.B. "sMyString +=" immer einen internen
     neuen String erzeugt... hier sollte man wohl demnächst kleinere Optimierungen machen so das der interne String immer etwas mehr Speicher belegt
     als eigentlich nötig ist, was dann aber ein performanteres anhängen von weiteren Zeichen oder kurzen Strings ermöglicht.
  -> Am XML Interface hat sich zwar nicht wirklich was großartig verändert, unter der Haupe gabs allerdings einiges an Änderungen... darum wäre es gut
     wenn jemand das nochmal kritisch durchgeht (auch z.B. die Copy-Operatoren) und testet.



>> 24.10.2010
[SB]
- Time: Wenn man Zeiten als String abspeichert, möchte man diese manchmal auch gerne wieder einlesen. Da das Format
  hier ja sehr strikt ist, dürfte dies auch ohne weiteres möglich sein, daher habe ich FromString() so implementiert,
  dass es die von ToString() ausgegebenen Time-Strings parsen kann und somit Zeiten auch als Strings übergeben
  werden können.



>> 11.10.2010
[CO]
- String: < und > Operatoren für ASCII waren fehlerhaft Implementiert. StringBuffer::IsLessThan() und StringBuffer::IsGreaterThan()
  wurden, warum auch immer, mit einer String länge von 0 aufgerufen... interessant das dies bisher noch nicht aufgefallen war, und das
  obwohl die String-Tests die umfangreichsten aller Tests sind. :/ (ok, die ASCII, UTF8 und Unicode kombinationsmöglichkeiten machen
  es nicht einfacher das möglichst Wasserdicht zu testen)



>> 20.09.2010
[SB]
- HttpServer: Methoden zum Senden von Daten nach HttpServerConnection verschoben, wo sie auch hingehören.
  Eine Server-Klasse sollten eigentlich nur Connections verwalten, die eigentliche Kommunikation
  zwischen zwei Hosts passiert aber immer in einer Connection, daher sollte die Funktionalität dieser
  Kommunikation auch dort definiert werden. Dies macht auch die Verwendung und den Zugriff auf eine Connection
  einfacher, ansonsten gibt es immer Probleme mit der Sichtbarkeit und der Vererbung von der Server-Klasse.



>> 16.09.2010
[CO]
- "PLGeneralWindows.h" um MinGW Support erweitert



>> 22.08.2010
[CO]
- Huch, die "FileWindows::CopyTo"-Implementation war fehlerhaft, die Windows Funktion "CopyFile" erwartet als zweiten Parameter,
  die Ziel URL inklusive Dateiname, übergeben wurde allerdings URL ohne Dateiname...
- "FileLinux::CopyTo" war noch nicht implementiert... selbst nach längeren Suchen konnte ich allerdings keine c-Funktion für Dateien
  kopieren finden, per Hand eine neue Datei erzeugen und dann die Daten selbst umkopieren war mir etwas zu doof...
  die jetztige Implementation über "system" ist allerdings genauso doof :/ (aber wenigstens läufts)



>> 16.08.2010
[SB]
PLCore:
- ConsoleApplication: Basispfad für Daten, die direkt im Runtime-Verzeichnis liegen, korrigiert.
  Das mit den Paketen ist ja schön und gut, aber es ist super unpraktisch, damit zu arbeiten, wenn man z.B. gerade
  an den darin enthaltenen Daten selbst arbeiten will, da man dann ständig alles entpacken und wieder packen müsste.
  Darum sollte es zumindest die Möglichkeit geben, die Daten aus einem Zip-File einfach an Ort und Stelle zu entpacken,
  und danach sollte noch alles so laufen wie mit dem Zip-File. Da aber die Zip-Files selber im Unterverzeichnis "Data"
  liegen, musste dieses natürlich noch dem Runtime-Pfad hinzugefügt werden, damit das klappt.



>> 15.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun die Umgebungsvariable PL_RUNTIME ausgelesen.
  Wenn diese gesetzt ist, wird das darin enthaltene Verzeichnis als
  PixelLight-Runtime verwendet, ansonsten wird in /usr/ und /usr/local gesucht.
  Um dies möglichst einfach zu machen, gibt es ausserdem das Script profile,
  welches dieses Verzeichnis ausgehend vom aktuellen Verzeichnis setzt.
  Natürlich kann man auch in seiner .profile oder .bashrc-Datei im
  Homeverzeichnis diese Variable automatisch beim Systemstart setzen lassen,
  damit man dies nicht immer wieder per Hand ausführen muss.
  Somit ist es nun wieder möglich, einfach so aus den Sourcen heraus zu
  arbeiten, ohne immer mittels "make install" das SDK im System installieren
  zu müssen.



>> 12.08.2010
[SB]
PLCore:
- Core: Unter Linux wird nun erst geschaut, ob "/usr/local/share/pixellight/Runtime" existiert, wenn ja, wird dieses
  als Runtime-Directory verwendet, ansonsten wird angenommen, dass ein global installiertes Runtime im Pfad
  "/usr/share/pixellight/Runtime" zu finden ist. Bei mir hat das damit schonmal geklappt, dass die Plugins aus
  diesem lokalen Runtime verwendet wurden, die konnten dann aber nicht geladen werden, weil wohl die automatisch
  geladenen dynamischen Bibliotheken, welche sich entsprechend in /usr/local/lib/ befinden, nicht automatisch
  geladen werden konnten. Dies lässt sich aber durch ausführen des Befehls "ldconfig /usr/local/lib" beheben.
  Momentan besteht dann noch das Problem, dass jetzt die dynamischen Abhängigkeiten wie Cg, Newton oder OpenAL
  natürlich nicht gefunden werden können.



>> 07.08.2010
[SB]
PLCore:
- ConsoleApplication: OnDeInit() wird wie OnInit() nun außerhalb aufgerufen, damit es sicher als letztes aufgerufen wird.



>> 09.08.2010
[CO]
- "UTF8Tools::GetNumOfStringBytes" um "nCount" erweitert
- "StringBufferUTF8::LastIndexOf(const char szString[]..." war fehlerhaft implementiert, daher erstmal eine funktionierende
  Lösung eingebaut, die allerdings sicherlich nicht die Effizienteste ist
- "StringBufferUTF8::GetSubstring" implementiert
-> Nun geht "Url(sFilename).GetExtension()" wenn "sFilename" ein UTF8-String ist
- "String::Compare" & "String::CompareNoCase" & "String::Insert" um UTF8 Support erweitert
- "FileWindows::Open(" um Unicode-Support erweitert
- UTF8Tools Warnungen beseitigt wo ich halbwechs sicher bin das die Beseitigung keine Seiteneffekte hat



>> 06.08.2010
[SB]
PLCore:
- ConsoleApplication: OnInit(), also die für die eigentliche Applikation bestimmte lokale Init-Methode, wird nun
  nicht mehr im Rahmen von Init() aufgerufen, sondern ist fest in der Run-Methode verdrahtet. Hintergrund ist,
  dass diese Methode als aller letztes aufgerufen werden muss, damit sie einen Sinn ergibt, alle Basisklassen
  müssen also die Chance haben, sich vorher komplett inizialisiert zu haben. Das würde aber heißen, dass niemand
  einfach Init() von der Basisklasse aufrufen kann, sondern immer alles neu implementieren müsste, damit die
  Reihenfolge stimmt. Darum musste OnInit() verschoben werden, damit dies nicht mehr nötig ist.



>> 05.08.2010
[CO]
PLCore:
- LoadableManager ist kein Loadable mehr, Kopie der alten Version liegt im Archive (Removed_LoadableFromLoadablaManager_05082010)



>> 05.08.2010
[SB]
PLCore:
- ConsoleApplication: LastCrashed und Speichern/Laden von LoadableManager-Pfaden entfernt.



>> 04.08.2010
[SB]
- System: GetDataDirName() hinzugefügt. Diese Methode wandelt den übergebenen Namen für das Unterverzeichnis im
  User-Data-Dir in ein für das OS typisches Format um. Aus "PixelLight" wird dann unter Linux ".pixellight", unter
  Windows wird der Name nicht verändert und bleibt bei "PixelLight".
PLCore:
- ConsoleApplication: Behandlung von Log- und Config-Dateien implementiert. Die Schwierigkeit hierbei ist es,
  gleichzeitig ein vernünftiges Standardverhalten zu implementieren, und es trotzdem dem Applikationsprogrammierer
  möglichst einfach zu machen, später alles abzuändern oder ganz auszuschalten, ohne dass er dafür große Teile
  komplett neu schreiben muss. Es gibt daher für das meiste jetzt Optionen in ConsoleApplication, die verwendet
  werden können, um Standardeinstellungen abzuändern:
  - MultiUser: Gibt an, ob Config und Log im User-Verzeichnis gespeichert werden sollen
  - AppDataSubdir: Gibt das Unterverzeichnis im DataDir an (wenn leergelassen, wird es in Run() auf der Applikationsnamen gesetzt)
  - LogName: Dateiname für Log (wenn leergelassen, wird Applikationsname mit '.log' verwendet)
  - ConfigName: Dateiname für Config (wenn leergelassen, wird Applikationsname mit '.cfg' verwendet)
  Hierüber kann man also ziemlich einfach z.B. den Dateinamen von Log oder Config abändern, ohne gleich die
  gesamte Main-Methode neuschreiben zu müssen. Wenn z.B. LogName oder ConfigName auf "" gesetzt werden, heißt das,
  dass diese Datei überhaupt nicht verwendet werden soll. Zusätzlich gibt es auch noch die Kommandozeilen-Optionen,
  die in jedem Fall vorrang haben (will jemand auch das nicht, sollte er die Option im Konstruktor entfernen).
- ConsoleApplication: Es wird nun alles bereits im Konstruktor gesetzt, damit es möglichst einfach wird, das Verhalten
  zu verändern, indem man einfach im Konstruktor alles so setzt, wie man das haben will. Der einzige dadurch notwendig
  gewordene Hack besteht darin, dass beim Späteren Aufruf von SetName() auch noch automatisch die Dateinamen für Log
  und Config angepasst werden, falls diese so aussehen, als wären sie noch auf ihren Default-Wert gesetzt.
- ConsoleApplication: Wenn die Konfigurationsdatei nicht geladen werden konnte, wird jetzt in einem zweiten Schritt
  dennoch der Dateiname gesetzt, damit eine neu erzeugte Config später gespeichert werden kann. Hierbei wird es wieder
  erst mit dem User-Data-Dir versucht, dann mit dem Applikationsverzeichnis. Wenn der ConfigName auf "" steht, wird
  gar keine Config verwendet. Ein auf der Kommandzeile übergebener Pfad hat immer Vorrang, und wenn er nicht
  existiert oder fehlerhaft ist, so werden trotzdem keine Standardpfade mehr versucht. Analog zur Config auch die
  Log-Methode angepasst, nur dass hier kein Dateiname gesetzt wird, wenn das Log nicht zu öffnen ging (ergibt hier
  keinen Sinn).
- ConsoleApplication: Option 'UseRuntime' hinzugefügt, die bestimmt, ob automatisch nach einer installierten
  PixelLight-Runtime gesucht werden soll, von der dann die Plugins und Datenpakete verwendet werden. Wie bisher
  kann das auch über die Config-Option eingestellt werden, wenn diese gefunden wird, wird diese Flag entsprechend
  gesetzt.
- ConsoleApplication: Weitere virtuelle Methoden eingebaut, um dem Programmierer möglichst viele Möglichkeiten zu
  geben, das Standardverhalten der Applikation abzuändern:
  - OnInitCmdLine() wird nach dem Parsen der Kommandozeile aufgerufen und ist dafür da, die gesetzen Optionen abzufragen
  - OnInitPlugins() wird nach dem Laden der Config aufgerufen und ist zum Laden der Plugins da
  - OnInitData() wird nach OnInitPlugins() aufgerufen und ist zum Setzen der Datenpfade da
- Methode ScanPackages() aus GuiApplication direkt nach LoadableManager verschoben. Da diese Funktion recht universell
  ist und sicherlich auch ausserhalb des Application-Frameworks verwendet werden kann, sollte sie auch gleich im
  LoadableManager vorliegen, auf dem sie ja auch operiert. Name und Kommentar analog zu ClassManager::ScanPlugins()
  angepasst.
- Core: Der Runtime-Pfad unter Linux ist nun erstmal festgelegt auf "/usr/share/pixellight/Runtime". Später könnte
  man hier vielleicht noch anhand der aktuell verwendeten Bibliothek oder deren Version unterscheiden... (könnten
  ja theoretisch mal mehrere Runtimes gleichzeitig installiert sein)
- Folgende Config-Items von EngineGeneralConfig nach CoreConfigGroup verschoben, da sie universell für alle
  Applikationen wichtig sind: UsePixelLightRuntime, FirstRun, LastCrashedMessage, LastCrashed, Language.
  Dabei LoadLibsFromRuntime in UsePixelLightRuntime umbenannt, da es hier nicht nur um die Libs geht (wobei man hier
  genauer von Plugins sprechen sollte), sondern gleichzeitig auch um die Daten im Runtime-Verzeichnis.
- Alles wichtige von GuiApplication nach ConsoleApplication verschoben.



>> 03.08.2010
[SB]
- System: GetCurrentDir() gibt das aktuelle Verzeichnis nun im Native-Format zurück statt wie bisher im URL-Format.
- System: Zusätzlich zu GetUserHomeDir() gibt es nun auch noch GetUserDataDir(). Hier wird das Verzeichnis zurückgegeben,
  in das die Konfiguration der Applikation geschrieben werden soll. Unter Linux sind Home- und Data-Dir identisch,
  unter Windows wird hier der Ordner "Anwendungsdaten" im Home-Verzeichnis zurückgegeben.
PLCore:
- Application überarbeitet. Statt "About" gibt es nun "Version", welches man bei den meisten Applikationen als
  Kommandozeilenoption finden kann (-a für about eher nicht). Die eigentliche Funktionalität wurde von Run()
  in die virtuellen Methoden Init(), Main() und DeInit() verschoben, da es ansonsten für abgeleitete Klassen
  nicht möglich ist, das Verhalten der Applikation zu modifizieren (z.B. wenn überhaupt kein Log geöffnet oder
  die Kommandozeile nicht geparsed werden soll - das ist in der bisherigen Lösung nicht zu verhindern).
  Die Idee dabei ist, dass in den drei Methoden Init(), Main() und DeInit() das eigentliche Gerüst für die
  Ausführung der Applikation implementiert wird, dies wird also von der jeweilige Basisklasse (z.B. Application,
  GuiApplication oder SceneApplication) entsprechend modifiziert. Konkrete Programm-Applikationen dagegen sollten
  diese Methoden dagegen möglichst nicht mehr verändern müssen, sondern statt dessen nur einzelne Schritte verändern,
  welche in zusätzlichen virtuellen Methoden bereitgestellt werden (z.B. OnRun(), OnInitLog() etc.). Diese
  Methoden werden von den Basisapplikationen aus aufgerufen. Nur wenn man wirklich grundlegend die Arbeitsweise
  der Applikation ändern will, muss man dann Main() etc. anpassen.
- Neue Application-Klasse in ConsoleApplication umbenannt. Diese Änderung wollte ich sowieso machen, damit man nicht
  mehr ständig das Problem mit gleichen Namen hat, da wir die Klassen in konkreten Programm ja auch immer "Application"
  nennen, und das daher immer in Konflikt gerät. Ausserdem wird es so leichter, die Klassen nach und nach umzustellen,
  da erstmal beides nebeneinander existieren kann.
- ConsoleApplication: Option m_bMultiUser hinzugefügt, mit der bestimmt wird, ob das Multi-User-Environment des Systems
  verwendet werden soll, oder nicht. In dem Falle wird immer zuerst versucht, z.B. Config oder Log-Dateien im
  entsprechenden User-Verzeichnis abzulegen, erst dann wird als Fallback z.B. das Application- oder das aktuelle
  Verzeichnis verwendet. Diese Option ist standardmäßig eingeschaltet und sollte wohl nur noch in Sonderfällen
  ausgeschaltet werden, da alle aktuellen Systeme mittlerweile darauf ausgelegt sind.



>> 02.08.2010
[SB]
- SystemLinux: GetProgramName() implementiert, so dass nun genauso wie unter Windows der absolute Pfad zur Bin-Datei
  zurückgegeben wird, gleichgültig von wo das Programm aufgerufen wurde. Der in args[0] übergebene Pfad ist leider
  relativ zur aktuellen Position und hilft daher nicht wirklich weiter, wenn es darum geht, den Pfad zu extrahieren
  um dann z.B. relativ dazu Datenpfade herausfinden zu können. Mittels der PID kann aber der absolute Pfad einer
  Applikation relativ leicht abgefragt werden. Dafür wurde nun SetProgramName() entfernt, da dies nur eine Notlösung
  war, damit den Wert aus arg[0] übergeben zu können.
- SystemLinux: GetUserHomeDir() scheint richtig zu funktionieren, daher eingebaut und TODO entfernt.
- System: GetProgramName() in GetExecutableFilename() umbenannt, da dies wesentlich eindeutiger ist.
- Log: ConsoleOutputActive in Verbose umbenannt. "Keep it simple" darf ruhig auch mal auf Namen angewendet werden :-)
- Log: Kommentare etwas überarbeitet.
PLCore:
- ApplicationContext hinzugefügt. Damit die Application-Klasse möglichst übersichtlich bleibt, sollten hier nicht
  so viele Daten und Methoden auf einem Haufen sein, denn das macht es immer gleich um einiges schwerer, den
  Aufbau einer Klasse zu verstehen. Die Laufzeit-Informationen der Klasse, also z.B. die wichtigen Verzeichnisse
  sowie die übergebenen Parameter, wurden daher in die neue Context-Klasse verschoben. Die Daten, die dagegen die
  Applikation selber bestimmen (wie z.B. Name und Titel) bleiben aber in der Klasse selbst.
- Application: Name hinzugefügt. Bisher gab es nur den Titel, der Name einer Applikation sollte aber auch noch
  gesetzt werden, da dieser meist kürzer ist als der ausgeschriebene Titel. Wenn kein Name angegeben wird, so wird
  der Name aus dem Dateinamen der Applikation extrahiert (z.B. "TestApp.exe" -> "TestApp").



>> 01.08.2010
[SB]
- Eigene Versionsnummer von PLGeneral entfernt.
[SB]
PLCore:
- Config-Klassen in eigenes Verzeichnis "Config" verschoben. Bitte die Application-Verzeichnisse nicht immer mit
  zusätzlichen Klassen belasten, insbesondere, wenn diese ganz locker auch für sich selber stehen können.
- Timer-Klassen entfernt, da veraltet und zur Zeit sowieso nicht mehr verwendet. In PLGui liegen ja schon Timer-Klassen
  bereit, wenn man das also mal braucht, müsste man sich nur noch einmal vernünftig überlegen, wie man darauf ausserhalb
  von PLGui am besten zugreifen könnte.



>> 24.07.2010
[SB]
- ConsoleLinux: Wenn Dateibefehle verwendet werden, um auf die Konsole zu schreiben, sollte der Dateipuffer immer geleert werden, damit die
  Ausgabe sofort erfolgt. Habe daher hier fflush(stdout) hinzugefügt.



>> 17.07.2010
[CO]
- "XmlNode::GetNextSiblingElement" & "XmlNode::GetFirstChildElement": Rückgabetyp sollte XmlElement und nicht XmlNode sein
PLCore:
- XML basierendes Chunk PixelLight Dateiformat hinzugefügt, Dateiendung ist "xchunk" statt "chunk" für Binäre Dateien



>> 15.07.2010
[CO]
- Bugfix in verschiedenen Projekten: Verwendung von XmlNode GetFirstChild/IterateChildren war Fehlerhaft da oft auf XmlElement
  gecasted wurde ohne vorher zu prüfen ob es überhaupt XmlElement ist, im Falle von XmlComment bekam man so dann einen Crash
PLCore:
- Nachdem ich die letzten Stunden damit verbrachte die Projekte und Daten entsprechend anzupassen... Suchpfade wie besprochen
  aus dem Loadable Manager entfernt. Zukünftig muss man also z.B. "Data/Textures/MyTexture.dds" statt "MyTexture.dds" schreiben.



>> 07.07.2010
[CO]
- "String::GetUInt32()": Statt "atol" wird nun "strtoul" verwendet da sich scheinbar das Verhalten von "atol"
  unter Linux/Windows unterscheidet und z.B. unter Linux das umwandeln in uint32 nicht klappte wenn die Zahlen
  zu groß waren



>> 06.07.2010
[SB]
- Bug in FileLinux::IsFile() behoben.



>> 08.06.2010
[CO]
PLCore:
- LoadableManager::OnClassLoaded: Hier darf die Klasse wirklich nur in eine Liste eingetragen werden, da man noch nichtmal
  davon ausgehen kann das "IsDerivedFrom" immer funktioniert da z.B. eine benötigte Basisklasse erst etwas später registriert
  werden könnte... das war bei mir unter Linux natürlich gerade der Fall, und dann war einfach der Loadable Type "Scene"
  unbekannt und es konnten keine Szenen eingeladen werden.



>> 02.06.2010
[SB]
PLCore:
- Bei der Verwendung von Enums im RTTI wird nun nicht mehr stur der Basistypus verwendet, da dies dazu führen würde,
  dass z.B. bei Methoden auch die Signatur so verändert wird, dass überall der Basistypus erwartet wird (Bsp.: Wird eine
  Methode, oder ein Event z.B. mit der Signatur(void, EnumType<EEnum>) angemeldet, so würde für die tatsächliche Methode
  die Signatur (void, int) erwartet). Das ist verwirrend, daher wurde die Behandlung von Enums nun so verändert, dass
  jetzt überall der tatsächliche Enum-Typus verwendet wird.
- Neuer Typ-Wrapper EnumTypePlain<> eingebaut, der für direkte Enum-Typen verwendet wird, also solche, die nicht am
  RTTI angemeldet wurden. Wenn man nun bspw. Type<EEnum> schreibt, wird intern Type< EnumTypePlain<EEnum> > verwendet,
  welches es ermöglicht, dieses als Typus im RTTI zu verwenden (dann hat man natürlich z.B. keine Umwandlung in Strings
  unter Verwendung der Enum-Namen, kann aber ansonsten diesen Typus wie gewohnt verwenden).
- RTTI-Makros für Enums angepasst: Normale enums werden nun ohne den Basistypus deklariert, also z.B. pl_enum(EEnum)
  statt pl_enum(EEnum, int). Nur in dem speziellen Fall, dass "unechte" Enums z.B. mit floats erzeugt werden sollen,
  muss auch der Basistyp mit angegeben werden, hierfür kann nun das Makro pl_enum_direct() verwendet werden.
  Es ist zu beachten, dass der Name in enums nun nicht mehr völlig frei gewählt werden kann, sondern immer der angegebene
  Typus unter dem exakten Namen auch existieren muss (also entweder ein echtes enum oder z.B. eine leere Klasse). Damit
  sind einige beabsichtigte oder unbeabsichtige Unstimmigkeiten, die es bisher gab (z.B. Enum hieß EFlag wurde aber
  als EStyle angemeldet) nicht mehr möglich.



>> 01.06.2010
[SB]
PLCore:
- RTTI: Bei der Verwendung von Enums z.B. in Events kam es bislang noch zu Fehlermeldungen durch den Compiler.
  Der Grund dafür war, dass noch nicht überall konsequent die tatsächlichen Typen verwendet wurden, welche von
  Type::_Type ermittelt werden (bei Var<T> war dies schon der Fall, aber bei allen Functoid- und Event-Typen noch nicht).
  Wenn bspw. ein Enum verwendet wird, ist der Typus ja EnumType<T> - dies ist aber nur ein Pseudo-Typus, der nicht wirklich
  verwendet werden darf (EnumType<T> als Parameter in einer Funktion ergibt keinen Sinn). Daher wird in Type::_Type der
  Typus auf den jeweiligen tatsächlichen Typus gemappt, dieser Typus muss dann verwendet werden.
  Als Faustregel kann festgehalten werden: In Template-Parametern sollte immer der Eingabetyp unverändert weitergereicht
  werden, erst wenn es zur Verwendung kommt (z.B. als Variable oder als Funktionsparameter), muss dann der jeweilige
  korrekte Typ verwendet werden.



>> 30.05.2010
[SB]
PLCore:
- RTTI: Beim Einbinden von RTTI-Klassen in andere Projekte, kam es zu dem Problem, dass diese Klassen dann mehrfach
  am System angemeldet wurden, weil die entsprechenden Template-Klassen vom Compiler dann mehrfach instanziiert werden
  (in jedem Projekt, in dem die Klassen eingebunden werden, also nicht nur in dem Projekt, das sie exportiert).
  Aufgrund der RTTI-Makros ist es leider nicht einfach möglich, diese Templates dann zu exportieren, darum wurden die
  RTTI-Makros nun so erweitert, dass man wie bei DLL-Exports eine Definition dafür verwendet, um festzustellen, ob die
  jeweilige Klasse gerade importiert oder exportiert wird. Für solche Projekte, die niemals in andere Projekte eingebunden
  werden (z.B. reine Plugins, die nur dynamisch über das Plugin-System eingeladen werden, oder Applikation, die gar nicht
  in andere Projekte eingeladen werden), kann das Makro pl_rtti_export verwendet werden. Alle anderen Bibliotheken sollten
  im Header-Datei ähnlich zu PLXXX_API ein Makro definieren, das jeweils auf 1 oder 0 gesetzt wird für Import oder Export.
  Die Projekte wurden entsprechend umgestellt.



>> 27.05.2010
[SB]
PLCore:
- Workaround für Linux bzw. GCC eingebaut, da es leider sonst folgenden, ziemlich dubiosen Linker-Fehler gibt:
    ../../../PLBase/PLCore/libPLCoreStat.a(ClassManager.cpp.o):
    In function `PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const':
    ClassManager.cpp:(.text._ZNK6PLCore5EventIPKNS_6ModuleENS_8NullTypeES4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_E4EmitES3_[PLCore::Event<PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>::Emit(PLCore::Module const*) const]+0x1a):
    undefined reference to `vtable for PLCore::Functor<void, PLCore::Module const*, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType, PLCore::NullType>'
  Dieser Fehler ist wirklich sehr eigenartig, weshalb ich annehme, dass es sich um einen Fehler im Compiler handeln könnte:
    - Der Fehler tritt z.B. mit Event<Module*>, Event<int> und allen anderen Typen auf
    - Der Fehler tritt *nicht* mit Event<Class*> auf, den Grund hierfür konnte ich aber nicht finden
    - Der Fehler tritt auf, sobald der Operator () vom Functor aufgerufen werden soll
    - Sobald der entsprechende Functor<T> in der Klasse Event oder in einer Methode instanziiert wird, verschwindet der
      Fehler. Es muss aber eine richtige Instanz sein, eine Typendeklaration, ein Zeiger oder eine Referenz reichen hier
      nicht aus, was wirklich eigenartig ist
    - Wenn statt des Functor()-Aufrufes eine neue Methode im EventHandler eingebaut wird, die wiederum Functor()
      aufruft, tritt der Fehler ebenso auf und kann ebenso behoben werden, indem dann in der neuen Methode innerhalb von
      EventHandler der Functor instanziiert wird. Komischer Weise reicht hier aber eine Instanziierung innerhalb der Klasse
      dann nicht mehr aus (zumal hier ja der Functor auch bereits instanziiert wird!).
  Es scheint also so, als ob unter bestimmten Voraussetzungen die Template-Klasse vom Compiler nicht richtig instanziiert
  wird, weshalb es dann zu dieser wenig hilfreichen Fehlermeldung kommt (diese Fehlermeldung wird normaler Weise darauf
  zurückgeführt, wenn z.B. eine virtuelle Methode, meist z.B. ein virtueller Destruktor, nicht implementiert wurde. Dies
  scheint mir hier aber nicht der Grund zu sein, zumal hier der Zusammenhang mit Templates besteht. Darum und aufgrund
  der unlogisch wirkenden Verhaltensweisen des Fehlers, halte ich einen Compiler-Bug für möglich).
  -> Als Workaround wird nun der Functor in der Emit-Methode einmal statisch instanziiert. Habe dafür im CMake-Projekt
  auch gleiche eine neue Präprozessor-Definition eingefügt, die mitteilt, wenn der GCC zum Compilieren verwendet wird
  (ifdef LINUX wäre hier eigentlich falsch, darum lieber ifdef GCC, zumal man theoretisch auch den GCC für Windows
  verwenden kann).
- CMake-Projekt so angepasst, dass PLCoreStat nur noch von PLGeneralStat abhängig ist, und nicht mehr wie bisher von
  PLGeneral.
- ClassManager::GetClasses() gibt nun keine Liste mehr zurück, sondern füllt eine übergeben Liste, um unnötige Kopier-
  operationen zu vermeiden.



>> 27.05.2010
[CO]
- Log liegt wieder in PLGeneral. Diesmal allerdings in einem eigenen "Log" Verzeichnis und nicht ans RTTI angeschlossen.
  "LogFormaterConsole" entfernt, das Log kann auf Wunsch nun direkt in die Standard OS Konsole schreiben.
PLCore:
- Log liegt wieder in PLGeneral
- "Application::Run": Hier wird nun das Log anhand von Kommandozeilen Parametern initialisiert, ich denke es ist das beste das
  direkt hier zu machen statt z.B. erst in "PLGui::GuiApplication"
- "Application::OnPrintVersion()" in "Application::OnPrintAbout()" umbenannt damit es keine Konflikte mit "v" als Kommendozeilen
  Parameter für "Verbose" gibt (uh, "v" scheint nen Standard-Parameter zu sein http://de.wikipedia.org/wiki/Verbose :)



>> 25.05.2010
[SB]
- String::GetUInt64(): _wtoi64 gibt es leider unter Linux nicht. Habe da nun statt dessen wcstoumax() verwendet,
  welches hoffentlich die richtige Funktion dafür ist. Leider gibt es die wiederum unter Windows nicht, jedenfalls
  konnte ich das nicht finden, obwohl es eigentlich zum ISO-Standard gehören sollte, und musste darum hier leider
  eine Fallunterscheidung einbauen.



>> 24.05.2010
[CO]
- Bugfix: "ElementManager<AType>::SetElementName": Umbenannte Elemente sollten nur in m_mapElements eingefügt werden, wenn
  diese kurz zurvor ausgetragen wurden
PLCore:
- Bugfix: "ResourceManager<AType>::SetResourceName": Umbenannte Elemente sollten nur in m_mapResources eingefügt werden, wenn
  diese kurz zurvor ausgetragen wurden



>> 23.05.2010
[CO]
- Da der Typ "handle" als "unsigned int" definiert ist, ist es unter 64 Bit übersetzt, 64 Bit statt 32 Bit groß.
  "INVALID_HANDLE" wird daher nun 32/64 Bit abhängig definiert. (scheinbar nur für Windows nötig)



>> 22.05.2010
[CO]
- String Klasse um Operatoren für uint32 und uint64 erweitert. Unter Windows nutzte ich dafür die Erweiterungen "I32"
  und "I64", unter Linux einfach nur "u" und "llu" - habe im Code für Linux als Kommentar alternativen eingefügt die
  man eventuell noch testen könnte.
PLCore:
- "Type<T*>", "Type<T&>" und "Type<Object*>": ConvertToString/ConvertFromString arbeitet nun mit uint32/uint64.
  Über die Definition "X64_ARCHITECTURE" wird bei uns festgelegt das es 64 Bit ist, "X64" war mir dann Namenskonflikt
  mäßig doch etwas zu Riskant. :D



>> 21.05.2010
[SB]
PLCore:
- TypeInfo: Neben IsEnumType() gibt es nun ebenfalls IsFlagType(), um Flags von Enums unterscheiden zu können.
  Im Falle von Flags gibt IsEnumType() nun dort auch 'false' zurück - das scheint mir ein wenig logischer, natürlich
  muss man hier aber wissen, dass auch bei IsFlagType() == 'true' die Methoden zum Auslesen der Enums natürlich
  funktionieren. Mann könnte das auch anders herum machen, so dass IsEnumType() in beiden Fällen 'true' zurückgibt, dann
  würde man "Flag" sozusagen als Sonderfall von "Enum" ansehen. Momentan habe ich es aber wie oben beschrieben gelöst.
- Class: ClassName (Name mit Namespace) wird nun noch gesondert als String gespeichert, damit beim Zugriff darauf nicht
  immer dynamisch neue Strings zusammengestellt werden müssen.
- Log, LoadableManager und Localization: Template-Instanz so verändert, dass es sich auch mit gcc compilieren lässt.
  Bei so einer expliziten Instanziierung von Templates ist zu beachten, dass es nicht erlaubt ist, diese innerhalb
  eines fremden Namespaces vorzunehmen. Da Singleton zum namespace PLGeneral gehört, muss also eine Spezialisierung
  innerhalb von PLGeneral oder ausserhalb aller Namespaces vorgenommen werden, aber *nicht* z.B. innerhalb von PLCore.
  Wie so oft geht dies zwar unter VC, unter z.B. dem gcc aber nicht, daher sollte hier in Zukunft darauf geachtet werden,
  Template-Instanziierungen immer ausserhalb fremder Namespaces vorzunehmen.



>> 20.05.2010
[CO]
- Das alte RTTI aus PLGeneral entfernt... manohman, das waren 2 verdammt heftige Wochen. Im großen und ganzen läuft nun alles
  wieder, natürlich steht nun noch weiteres Bugfixing an bis alles wieder so rund läuft wie vor der großen Umstellung. Interessant
  ist, dass es am Ende nun wirklich 2 Wochen Arbeit waren, so wie am Anfang pi*daumen geschätzt. *g*
PLCore:
- LoadableManager: Neue Klassen werden erst dann, wenn diese benötigt werden korrekt Eingetragen. Trägt man sofort bei
  erhalten des ClassManager::EventClassLoaded Ereignisses ein, so kann es sein das eine Klasse noch nicht vollständig
  initialisiert ist und dann die Loader Registierung nicht klappt.
- LoadableType speichert nun ebenfalls die RTTI Klasse von der alle Loader Implementationen dieses Types abgeleitet sein
  müssen. Diese Klasse wird z.B. in Loadable verwendet um zu sehen ob der Loader Typ, der über eine Dateiendung ermittelt
  wurde, wirklich zum Loadable Typ passt der gerade eingeladen werden soll... sonst könnte man einem Mesh sagen es solle
  sich doch bitte aus diesem Bild hier laden - klar, probieren kann ich es als Benutzer immer noch, das System grinst mich
  in dem Fall aber nur dämlich an. *g*



>> 19.05.2010
[CO]
PLCore:
- Loadable System von "PLGeneral::Parameters" befreit. Gestern Abend schwierte mir im Kopf eine Loader-Lösung herum die mit
  RTTI Methoden arbeitet, heute in aller früh setzte ich das mal um und passte entsprechend alle Loader an. Das Ergebnis
  gefällt mir sogar... Die einzelnen Loader-Basis Klassen wie z.B. "ConfigLoader" sind nun superschlank, ja praktisch leer.
  Die konkreten Loader-Implementationen wie z.B. "ConfigLoaderPL" sind nun ebenfalls etwas schlanker da dort keine Dynamischen
  Parameter mehr geparst werden. Es gibt nun einfach öffentliche Load/Save Methoden, die man also auch ganz ohne RTTI nutzen kann.
  Ebenfalls kann es LoadParams/SaveParams Methoden geben - wenn ein Format noch besondere Optionen anbietet, wie z.B. welche
  Kompression beim Speichern verwendet werden soll. Wenn man es ganz wild treiben will, kann man die Methoden Namen auch frei
  wählen, beim Resourcen-Laden muss man dann allerdings die Methoden Namen angeben. Es stehen nun also deutlich mehr Nutzungsmöglichkeiten
  zur Verfügung und die Implementationen sind schlanker geworden + man kann in den RTTI Methoden Kommentaren nachlesen was es
  für weitere besondere Format abhängige Parameter gibt und was die machen.



>> 17.05.2010
[CO]
- PixelLight ist nun soweit auf das neue RTTI umgestellt, nun folgen nur noch Aufräumarbeiten & Bugfixing
- "Log" von PLGeneral nach PLCore verschoben
PLCore:
- "Log" von PLGeneral nach PLCore verschoben



>> 16.05.2010
[SB]
PLCore:
- ClassManager: GetClasses() kann nun auch nur Klassen aus einem bestimmten Modul zurückgeben. Damit ist diese Methode
  nun immer mehr zur zentralen Such-Funktion für Klassen geworden, was ich auch ganz sinnvoll finde. Kommentare an
  anderen Stellen eingefügt, um auf diese zentrale Suchfunktion hinzuweisen.



>> 16.05.2010
[CO]
PLCore:
- PLCore::Object::IsInstanceOf in der Art erweitert das ebenfalls "true" zurückgegeben wird wenn die beiden zu testenden
  Klassen identisch sind



>> 15.05.2010
[SB]
PLCore:
- RTTI: Ein mit ModifyAttr überschriebenes Attribut setzt nun den Default-Value in Abhängigkeit vom Storage-Type
  des Basis-Attributes. Wenn das Basis-Attribut also den GetSet-Storage gesetzt hat, wird auch im überschriebenen
  Attribut der Default-Wert *nicht* mehr gesetzt, so dass es nicht mehr zu Problemen im Konstruktor kommen sollte.
  Ist dagegen DirectValue als Basis-Storage gesetzt, so wird der Default-Wert gesetzt, da es hier keine Probleme gibt.
  Ich habe es zwar noch nicht ausprobiert, aber das ganze sollte auch über beliebig viele Ebenen funktionieren,
  da der StorageType der Basisklasse hier jeweils durchgereicht wird :-)
- Constructor: IsDefaultConstructor() eingebaut
- Class: HasConstructor() und HasDefaultConstructor() eingebaut
- Class: IsDerivedFrom() gibt nun bei der eigenen Klasse "false" zurück, damit der Name exakt stimmt
- ClassManager: GetDerivedClasses() akzeptiert nun mehrere Parameter, mit denen man bestimmten kann, ob die Basisklasse
  selbst mit aufgeführt werden soll, ob rekursiv oder nicht rekursiv gesucht wird, sowie ob abstrakte Klassen, also solche
  ohne Konstrukturen, mit aufgeführt werden sollen oder nicht.
- Class und ClassManager: Das Auflisten der abgeleiteten Klassen wurde noch einmal gründlich überarbeitet. Es ist nun die
  von Christian eingebaute Lösung, die nur auf den Namen operiert, verwendet worden, da mir aufgefallen ist, dass das
  InitClass()-Schema in Bezug auf abgeleitete Klassen ja gar nicht richtig funktionieren kann. Denn wenn die Klasse
  initialisiert wird, trägt sie sich zwar in die Liste ihrer Basisklasse ein, aber damit kann man ja noch nicht sicherstellen,
  dass die eigenen abgeleiteten Klassen bereits initialisiert wurden. Die Liste an abgeleiteten Klassen bleibt also leer,
  da man die entsprechenden Klassen vorher initialisieren müsste, womit sich die Katze in den Schwanz beißt ;-)
  Darum wurde die Liste von abgeleiteten Klassen nun aus Class entfernt, statt dessen wird die Suchmethode aus
  ClassManager verwendet, um an die Liste von abgeleiteten Klassen zu kommen, wenn diese abgefragt wird.
- ClassManager: GetDerivedClasses() in GetClasses() umbenannt.



>> 14.05.2010
[SB]
PLCore:
- NullType nach TypeTraits.h verschoben
- InvalidType in TypeTraits.h hinzugefügt. Dies ist ein Template, das alle nicht unterstützten Typen repräsentiert
- TypeTraits: Einige Templates hinzugefügt, um den Typus eines, äh, Typus festzustellen:
  - IsConvertible, mit dem man feststellen kann, ob zwei Typen ineinander konvertierbar sind.
  - IsEnum, mit dem man feststellen kann, ob es sich bei einem Typen um ein enum handelt
  - TypeClassification, welches Informationen über den Typus in Form von bools in einer Klasse speichert
  - CheckType, welches den geeigneten Typus für nicht-standard-Typen auswählt (z.B. <int> für enums)
  - IsBaseClass, welches ermittelt, ob eine Klasse eine Basisklasse einer anderen Klasse ist
  - CheckBaseClass, welches einen Compiler-Fehler hervorruft, wenn eine Klasse nicht von einer Basisklasse abgeleitet ist
- Type und DefaultValue: Es werden nun die neuen Templates verwendet, um neben den Standardtypen weitere, nicht-standard-Typen
  zu unterstützen. So werden nun z.B. auch enums unterstützt, in diesem Falle wird der Typus einfach wie ein int behandelt.
  So etwas wie Event<EEnum> sollte daher nun verwendet werden können.
- RTTI: Es wird nun ein Compilerfehler erzeugt, wenn im RTTI-Makro nicht angegebene Klasse nicht von der angegebenen
  Basisklasse abgeleitet wurde. Damit werden nun Fehler leichter entdeckt, z.B. wenn die Klasse selbst als Basisklasse
  angegeben wurde etc. Was allerdings noch nicht entdeckt werden würde, wäre z.B., wenn zwar eine korrekte Basisklasse
  angegeben wurde, dazwischen aber noch weitere Klassen sind (z.B. A->B->C, und es wird angegeben, C sei von A abgeleitet!).



>> 11.05.2010
[CO]
PLCore:
- Bis auf SceneNode und SceneNodeModifier ist nun alles auf das neue PLCore2 umgestellt, also Klassenmäßig Halbzeit :D
- Wie in einer EMail besprochen: "type_flag" in "pl_flag_type", "type_enum" in "pl_enum_type" und "ret_type" in "pl_ret_type" umbenannt



>> 08.05.2010
[SB]
PLCore:
- TypeTraits.h hinzugefügt: Hier wird es einige generelle templates geben, um Abfragen auf Typen zur Compile-Time
  zu ermöglichen.
- Rtti.h: Es waren noch einige Änderungen notwendig, damit das Projekt wieder mit gcc zu compilieren ist. Die
  erzeugten Storage-Templates für ein Attribut sind so geschrieben, dass sie nur valide sind, wenn der entsprechende
  Storage-Type auch wirklich ausgewählt wurde (es gibt z.B. keine Methoden GetMyVar()/SetMyVar(), wenn MyVar nicht
  mit dem Storage-Typus GetSet deklariert wurde). Im template-code wurde jedoch für jedes Attribut das entsprechende
  Template verwendet, wenn auch nur als Typus für andere Templates, wo es später verworfen wurde. Für den gcc reicht
  dies jedoch aus, um das Template zu spezialisieren, was natürlich zu einem Fehler führt. Aus diesem Grunde wird
  nun das template SpecializeIfEqual<> verwendet, welches eine Template-Class nur dann spezialisiert, wenn eine
  bestimmte Bedingung erfüllt ist. Damit lässt sich PLCore2 nun auch unter Linux wieder compilieren.
- IntegralType nach TypeTraits.h verschoben
- Traits.h entfernt



>> 07.05.2010
[CO]
- "Chunk" und "Localization" samt dazugehörigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalität
  benötigt wird die zukünftig erst ab PLCore zur Verfügung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
PLCore:
- "Chunk" und "Localization" samt dazugehörigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalität
  benötigt wird die zukünftig erst ab PLCore zur Verfügung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben
- Wie schon bei PLGeneral, hat nun auch PLCore eine statische Version da z.B. PLProject und der 3ds Max Exporter nun PLCore
  benötigen, aber nicht von einer dll abhängig sein sollten. Hoffentlich hab ich "CMakeLists.txt" korrekt erweitert, naja
  werds spätestens beim nächsten PL SDK übersetzen merken. *g*



>> 06.05.2010
[CO]
PLCore:
- Umstellung von PixelLight auf PLCore2 begonnen
- "Core", "ThreadTimer", "Timer", "TimerImpl", "TimerWindows", "Config", "ConfigLoader", "ConfigLoaderPL", "CoreConfigGroup"
  vom alten PLCore ins neue kopiert damit sich die Umstellarbeiten auf das neue RTTI Konzentrieren können.
- Params um Copy-Constructor und Copy-Operator erweitert da ansonnsten an einigen Stellen der VisualStudio Team Edition Compiler
  Warnungen ausgab, während der *normale* VisualStudio Compiler nix sagte



>> 05.05.2010 (PLCore2)
[SB]
- RTTI: pl_enum_end() in pl_enum_end geändert
- RTTI: Fehler in pl_enum() behoben - wenn der Wert 0 definiert war, funktionierte die Umwandlung von Name->Wert nicht
  mehr, da hier eine Abfrage fehlte.
- RTTI: Die Behandlung von Flags und Enums musste noch einmal gründlich überarbeitet werden, da es bspw. so nicht
  möglich war, Enums in einer Klasse zu definieren und in der gleichen Klasse auch gleich zu verwenden. Daher habe
  ich die interne Verwaltung von Enums nun so verändert, dass das enum nicht mehr durch eine Spezialisierung
  von PLCore2::EnumType<> definiert wird, sondern statt dessen eine einfache Klasse erzeugt wird, die dann als
  Template-Parameter weitergereicht wird. Das vereinfacht vieles und bedeutet letztlich für die Anwendung:
  - pl_enum() kann nun prinzipiell überall verwendet werden. Auch in Namespaces, und auch in Klassen :-)
  - pl_enum_value_namespace() wurde deswegen wieder entfernt, da es nicht mehr benötigt wird
  - pl_enum_value_direct() wurde hinzugefügt, dies kann verwendet werden, wenn der zu definierende Enum-Typ kein echter
    C++-Enum-Typ ist - letztlich kann dies verwendet werden, um beliebige Definitionen zu machen. Anwendungsfall sollte
    vor allem sein, wenn man enum definieren will, die nicht den Datentyp 'int' haben (z.B. float)
  - Überall, wo man auf ein enum zugreifen will, muss man nun zwangläufig auch das Makro type_enum() verwenden,
    da dies jetzt nicht mehr nur ein PLCore2::EnumType< > um den Namen legt, sondern auch den Namen so verändert,
    dass auf die erzeugte RTTI-Enum-Klasse verwiesen wird.
  - Für den direkten Zugriff auf RTTI-Enums ist jetzt die Klasse PLCore2::EnumType< > zuständig. Wie eben erwähnt muss
    hier immer type_enum() verwendet werden, um also z.B. die Anzahl an Elementen eines enums abzufragen, benutzt man
    also: type_enum(EnumName)::GetNumOfEnumValues();
- Bespiele für Enums erweitert: U.a. Verwendung von Enums in Klassen und Definition von float-enums.
- RTTI: Die Basisklasse muss in pl_class() nun ohne Anführungszeichen angegeben werden.
- VarAccess und VarStorage noch einmal gründlich überarbeitet und ein wenig überschaubarer gemacht. Der zugrunde
  liegende Storage-Typ (z.B. StorageDirectValue oder StorageGetSet) wird nun so weit wie möglich mitgereicht,
  damit dann an letzter Stelle das jeweilige Template anhand der Klasse entscheiden kann, was zu tun ist. Auch
  der StorageChoose wurde entsprechend umgeändert.
- Neben StorageDirectValue und StorageGetSet gibt es nun noch einen weiteren Storage-Typ: StorageModifyAttr.
  Dieser Typus kann verwendet werden, um Variablen in abgeleiteten Klassen zu überschreiben, und dabei in die gleiche
  Variable zu schreiben. Es wird also eigentlich die Variable der Basisklasse verwendet, jedoch im RTTI die Daten aus
  der abgeleiteten Klasse verwendet (z.B. Default-Value, Enum etc.). Wenn dies verwendet werden soll, muss daher der
  Typus der Variablen in der Basisklasse und in der abgeleiteten Klasse identisch sein. Wenn statt dessen StorageDirectValue
  verwendet wird, ist es zwar auch möglich, Variablen zu überschreiben und dabei den Typus zu ändern, dies sind dann
  jedoch in Wirklichkeit zwei Variablen, die nur den gleichen Namen haben.
- Beispiel für das Überschreiben von Variablen hinzugefügt.
- RTTI: Auf vielfachen Wunsch einer einzelnen Person kann nun bei Enums zu jedem Wert auch noch eine Beschreibung
  mit angegeben werden. Diese kann bei statischem Zugriff über EnumType<T>::GetEnumDescription(sName), oder bei
  dynamischem Zugriff über DynTypeInfo::GetEnumDescription(sName) abgefragt werden.
- Var: Methode Default() hinzugefügt. Die Methode gibt direkt den Default-Wert zurück, benutzt also direkt den
  jeweiligen Datentyp. Wie bei Get() und Set() ist diese Methode nur vorhanden, wenn man direkten Zugriff auf die
  Variable hat. Über DynVar gibt es die Methode GetDefault(), welche den Default-Value als String zurückgibt (ist
  nicht anders möglich, da hier der tatsächliche Datentyp noch nicht bekannt ist).



>> 04.05.2010 (PLCore2)
[SB]
- Var: Es kann jetzt auch der Default-Konstruktor verwendet werden.
- RTTI: 'pl_enum'-Makro erweitert, so dass die dadurch erzeugte EnumType-Klasse ein wenig mehr Komfort bietet.
- RTTI: 'pl_enum_base' eingebaut. Mit diesem Makro können bei der Deklaration eines Enum-Typs alle Werte eines anderen
  Enums übernommen werden, hiermit können also Datentypen "erweitert" werden.
- RTTI: Neben 'pl_enum_value' gibt es nun auch 'pl_enum_value_namespace', das verwendet werden kann, wenn der enum-Typ
  innerhalb eines Names (oder auch einer Klasse) liegt. RTTI-Enums müssen immer im globalen Scope deklariert werden,
  also auch ausserhalb von namespaces, hiermit können jedoch dann auch solche Enums angemeldet werden, die selbst
  innerhalb eines namespaces liegen.
- Neue Klassen DynTypeInfo und TypeInfo erstellt. Diese sind im Gegensatz zu den Type<>-Klassen nicht statisch, sondern
  haben ein virtuelles Interface und können daher dynamisch (polymorph) verwendet werden. Dies wird wohl so aussehen,
  dass man von einer Variable per GetTypeInfo() eine Referenz auf ein solches TypeInfo-Objekt zurückbekommt, und
  davon dann noch einmal die wichtigsten Typen-Informationen abfragen kann. Hier noch einmal die ganzen Konvertierungs-
  funktionen einzubauen, scheint mir nicht sinnvoll, zumal man dies auch direkt innerhalb von Var machen kann, und
  es ausserdem hier schwierig wird, da der tatsächliche Typ ja nicht bekannt ist. Deshalb kann man hier erstmal nur
  noch einmal Typ-ID und Namen abfragen.
- Var: GetType() hinzugefügt, welche eine statische Instanz von TypeInfo<T> für den jeweiligen Daten zurückgibt.
- DynTypeInfo: Es kann nun neben dem eigentlichen Datentyp auch abgefragt werden, ob es sich um einen Enum-Datentyp
  handelt (Enum und Flag ist auf dieser Ebene das gleiche). Falls ja, kann abgefragt werden, welche Enum-Werte es gibt,
  hier bekommt man dann eine Liste von Namen zurück. Es ist leider nicht möglich, hier auch gleich die Werte für
  die Enum-Namen abzufragen, aus dem Grunde, dass hierfür ja der Datentyp bekannt sein müsste. Um das zu erreichen,
  muss man also entweder Zugriff auf den jeweiligen Header haben und EnumType<ENUM> verwenden, oder den Umweg über
  eine Variable gehen, da man ja nun die Namen kennt, die man setzen kann.
- DynTypeInfo: Methode GetEnumValue() hinzugefügt, mit der man nun doch auf den Wert eines Enum-Names zugreifen kann,
  allerdings nur als String (s.o., der Typus ist hier nicht bekannt). Das sollte jedoch helfen, um z.B. in einem Dialog
  neben dem Enum-Namen auch dessen Wert anzeigen zu können.
- Object: Umbenennung der Methoden, um mehrere oder alle Attribute eines Objektes gleichzeitig setzen oder auslesen
  zu können in SetValues()/GetValues() und SetValuesXml()/GetValuesXml(). Auch wenn man hier letztlich auf Attribute
  zugreift, sind diese Methoden mehr als reine zugriffsmethoden auf Attribute und stellen den Kern des RTTI dar. Daher
  sollten diese Methoden von den anderen Attribut-Methoden getrennt sein und zudem einen möglichst einfachen und gut
  zu merkenden Namen haben :-)
- Object: Methoden SetAttributeDefault() und SetDefaultValues() hinzugefügt. Diese Methoden setzen einen bzw. alle
  Attribute auf ihren jeweiligen Default-Wert.



>> 29.04.2010 (PLCore2)
[SB]
- Klassen können nun noch zusätzliche Properties haben, also Key/Value-Pairs, die an einer *Klasse* (!) dranhängen
  und zur Laufzeit abgefragt werden können. Dies dient dazu, zusätzliche Infos zu einer Klasse bereitzuhalten, bspw.
  können Loader so bekannt geben, welche Dateitypen sie unterstützen oder eine Klasse kann beliebige andere Infos
  über sich preisgeben. Properties können in abgeleiteten Klassen überschrieben werden. Definiert werden Properties
  über das neue Makro pl_property. Leider müssen alle Properties innerhalb von pl_properties und pl_properties_end
  eingeklammert werden - anders war das mit den RTTI-Makros leider nicht zu lösen, ohne dass es unnötig kompliziert
  geworden wäre.
- RTTI: Analog zu 'pl_properties' und 'pl_properties_end' heißt es nun 'pl_class_end' anstelle von 'pl_class_end()',
  da es so einfach irgendwie netter aussieht.



>> 24.04.2010 (PLCore2)
[CO]
- Im "pl_module"-Makro "Unknown" Initialisierungen eingebaut da ansonnsten durch "ClassManager::RegisterModule" die
  Module Initialisierungen komplett überschrieben werden und am Ende wieder leere Strings vorhanden waren :/



>> 23.04.2010 (PLCore2)
[CO]
- Params: "DefaultValue<x>::Default();" eingefügt + Rückgabewert im Konstruktor initialisiert



>> 23.04.2010 (PLCore2)
[SB]
- DynFunc, Func: Call(DynParams &cParams) erwartet ein Params-Objekt, welches nicht const ist. Unter Windows wird dies
  scheinbar auch akzeptiert, wenn man z.B. Call(Params<int, int>(10)) aufruft - zwar geht hier natürlich z.B. der
  Rückgabewert verloren, aber der Aufruf findet dennoch statt, und theoretisch kann man das auf dem Stack befindliche
  Params-Objekt wohl auch manipulieren, auch wenn man davon natürlich im Nachhinein nichts mehr hat, weil man es nicht
  wieder auslesen kann :-) Unter Linux mit dem aktuellen gcc klappt dies allerdings nicht, hier wird ein so übergebener
  Parameter wohl grundsätzlich als const angesehen. Aus diesem Grund musste ich leider zusätzlich noch eine zweite
  Methode hinzufügen: Call(const DynParams &cParams). Die macht natürlich das gleiche wie im nicht-const Fall, mit
  dem Unterschied, dass hier keine Rückgabewerte geschrieben werden. Deswegen musste diese Methode nicht nur in DynFunc,
  sondern auch in allen 34 Spezialisierungen von Func<T> implementiert werden :-( Sollte jemandem hier eine einfachere
  Lösung einfallen, bitte Bescheid sagen...
- DynEvent, Event: Gleiche Problematik wie bei DynFunc, Func. Da Events jedoch niemals einen Rückgabewert haben können,
  reicht es hier aus, wenn die Parameter immer als const übergeben werden. Emit(DynParams&) wurde also überall zu
  Emit(const DynParams&) gemacht.
- Constructor: Auch hier die gleiche Problematik. Überall wo nötig wurde daher Create(DynParams&) in Create(const DynParams&)
  geändert. Auch an allen anderen Stellen, z.B. Object und Class, wurden nun wenn nötig zweite Varianten der jeweiligen
  Methoden hinzugefügt, damit man überall Parameter sowohl const als auch nicht-const übergeben kann.
- Func: Bei den Änderungen gab es noch einige kleinere Fehler, wo einfach von const nach non-const gecastet wurde, was
  hier definitiv nicht erwünscht ist. Nun habe ich hoffentlich alles erwischt (bitte nochmal drüber schauen!)
- Constructor: Hier gab es sogar ein noch größeres Problem, weil zwar der Aufruf im Prinzip nur ein const-Parameters
  benötigt, jedoch der Rückgabewert in diesem Fall ja intern verwendet wird. Ich habe das nun so gelöst, dass an einen
  Constructor immer const-Parameters übergeben werden, diese intern aber kopiert werden und somit ein non-const
  Parameters-Objekt entsteht, welches an den Functoid weitergegeben wird. Dort ist dann der Rückgabewert, also der Zeiger
  auf das neu erstellte Object, als Return-Value gespeichert, welches dann wiederum zurückgegeben werden kann. Nach
  meinen bisherigen Tests scheint das auch zu funktionieren, besonders schön ist die Lösung natürlich nicht.
- ClassManager und Class: Methode GetModule() eingebaut.
- ClassManager: Es wird nun bei duplizierten Klassennamen (Konflikten zwischen zwei Klassen gleichen Namens und
  Namespaces) eine Warnung ins Log geschrieben.
- Module: Name, Beschreibung usw. werden nun alle mit "Unknown" initialisiert. Sollte ein Projekt also nicht die Makros
  nutzen, um Infos über das Modul zu setzen, wird dieses in der Liste und z.B. im Log als "Unknown" auftauchen
- RTTI: Makro pl_current_module_id() hinzugefügt als Shortcut, um die ID des aktuellen Modules abzufragen.
- RTTI: Slots werden nun, genauso wie Methoden, beim Anmelden am RTTI umbenannt. Für den Slot "OnMyEvent" wird also
  jetzt ein Objekt namens 'SlotOnMyEvent' angelegt, dafür wird der aufgerufenen Methode kein automatisches "On" mehr
  vornangestellt. Dies ist nun konsistent mit den Methoden, man gibt also einfach auch beim Slot den Namen der Methode
  an, die aufgerufen werden soll, und erhält ein Feld mit 'Slot' davor. Als Konvention für uns würde ich vorschlagen,
  dass alle Slots immer der Konvention "On[EventName]" folgen sollten.



>> 22.04.2010 (PLCore2)
[SB]
- Functor: Einige Fehler in den partiellen Spezialisierungen behoben (R statt void)
- DefaultValue: Fehlende Datentypen nachgetragen.
- Class, Object, RTTI: Wie Christian richtig anmerkte, war die Verwendung von Event/Signal und EventHandler/Slot noch
  nicht konsequent umgesetzt. Habe das nun behoben, es sollte nun also völlig analog sein zu Attributes und Methods.
- DynEvent: virtual void Emit(DynParams&) war nicht als const deklariert - in den abgeleiteten Klassen aber schon, wodurch
  die virtuelle Funktion nicht korrekt überschrieben wurde (sondern das natürlich als neue Funktion galt).
- Class: GetAttribute(), GetMethod() etc. geben nun const-Zeiger auf die jeweiligen Descriptoren zurück. Zwar geschehen
  dann zwischenzeitlich const-casts, da man letztlich von dem Descriptor ja auch wieder auf das jeweilige Member-Objekt
  kommen kann, aber ich denke, das ist hier ok. Das mit const ist nicht immer so ganz sauber hinzubekommen, fürchte ich.



>> 21.04.2010 (PLCore2)
[SB]
- Fehler behoben, die beim Übersetzen mit gcc unter Linux aufgedeckt wurden.
- PLCore2 lässt sich nun unter Linux übersetzen.



>> 15.04.2010 (PLCore2)
[SB]
- Class: Die Namen etc. müssen nun direkt im Konstruktor übergeben werden, da ansonsten die Klasse bereits
  angemeldet wird, bevor ihre Daten gesetzt wurden, der Name ist also leer. Makros etc. entsprechend angepasst.
- Func: Einige Warnungen behoben
- Object: Wir nun auch beim RTTI angemeldet



>> 14.04.2010 (PLCore2)
[SB]
- RTTI-Makros: Probleme behoben, die auftraten, sobald das RTTI über mehr als eine Bibliothek hinweg verwendet wurde.
  Dies führte zu unaufgelösten externen Referenzen, diese Probleme wurden nun durch leichte Änderungen im RTTI behoben
  (hoffentlich auch für andere Compiler zu gebrauchen).
- RTTI-Makros: Die Basisklasse kann nun auch mit angegeben werden (*hust*)
- Basisklasse Config erstellt (noch leer).
- Basisklasse Application erstellt (noch leer).



>> 13.04.2010 (PLCore2)
[SB]
- Klasse Module erstellt, welche die Informationen über ein Modul speichert. Für jedes Module (Applikation/Bibliothek) wird
  automatisch eine Instanz von Module erstellt und beim ClassManager angemeldet. Ein Module beinhaltet dann bspw. auch eine
  Liste aller Klassen, die zu diesem Modul gehören.
- Funktionalität zum Laden und Verwalten von Plugins hinzugefügt.
- Type-Wrapper für Pointer-Typen hinzugefügt.
- ClassManager: Events hinzugefügt für das Anmelden/Abmelden von Klassen und Modulen. Dies kann z.B. verwendet, wenn eine
  Komponente darüber informiert werden muss, wenn es neue Klassen von einer bestimmten Basisklasse gibt etc.
- RTTI: Eine Makros hinzugefügt, die zwar nicht notwendig sind, aber die Definitionen besser zu lesen machen.
  ret_type() markiert einen Rückgabewert und sollte für die Deklaration von Methoden verwendet werden, um den Rückgabetyp
  von den Argument-Typen zu unterscheiden. type_enum() und type_flag() sind Wrapper-Makros, die anstelle der ansonsten
  recht langen und unübersichtlichen Templates verwendet werden sollten.
- Weitere statische Datentypen zum RTTI hinzugefügt: double, int8, int16, int32, uint8, uint16, uint32



>> 12.04.2010 (PLCore2)
[SB]
- Klassen-Template ModuleID hinzugefügt, welches dafür zuständig ist, jedem Modul (z.B. eine Applikation oder Bibliothek)
  eine eindeutige Modul-ID zu beschaffen.
- ModuleMain.h hinzugefügt. Dieser Header sollte genau einmal in einem Projekt eingebunden werden und die darin enthaltenen
  Makros verwendet werden, um das Modul zu beschreiben (Name, Beschreibung etc.).
- Makros und Klassen für die Deklaration und Registrierung von Modulen hinzugefügt.



>> 11.04.2010 (PLCore2)
[SB]
- Einige Fehler in Type<EnumType> behoben.
- Type<FlagType> implementiert (Flag-Types sind wie Enums, erlauben aber die Kombination von Werten).
- EnumTypes kann jetzt auch bei der Deklaration von Attributen verwendet werden (hier gab es noch kleinere Fehler, die
  das bisher verhinderten).
- Object, Class: Methoden hinzugefügt, um den Typus von Objekten abzufragen und z.B. zu erfragen, ob eine Klasse von
  einer anderen abgeleitet ist oder ein Objekt von einem bestimmten Typus ist.



>> 10.04.2010 (PLCore2)
[SB]
- Klasse ParamParser erstellt und implementiert. Diese Helfer-Klasse kann verwendet werden, um Parameter-Strings
  zu parsen, wie z.B. "Param0=\"Hello\" Param1=10". Die Klasse bietet dann ein einfaches Interface, um über die
  gefundenen Parameter sowie ihrer Werte zu iterieren und diese auszulesen. Da diese Funktionalität an sehr verschiedenen
  Stellen benötigt wird, sollte es hier eine wiederverwendbare Klasse geben :-)
- Params: Statische Funktion FromString hinzugefügt, welche ein Params-Objekt mit den im String angegebenen Parametern
  erzeugt und zurückgibt. Damit ist es möglich, bspw. eine Funktion mit den Parametern als String aufzurufen:
    cFunc.Call(Params<int, float>::FromString("Param0=10 Param1='1.5'")); // Parameter names are not important
- DynFunc, Func: Neue virtuelle Methode Call(const String&) hinzugefügt, die es erlaubt, eine Methoden mit einem
  Parameter-String aufzurufen, ohne im Vorfeld die Signatur der Funktion kennen zu müssen.
- Klasse ParamParserXml erstellt und implementiert. Diese arbeitet analog zu ParamParser, lies die Parameter aber
  im XML-Format ein, z.B.:
    <?xml version=\"1.0\" ?>
    <Call Param0=\"1\" Param1=\"2.5\"/>
- Params: Statisch Funktion FromXML hinzugefügt (analog zu FromString).
- DynFunc, Func: Neue virtuelle Methode Call(const XmlElement&) hinzugefügt (analog zu String&).
- Var, Type: Werte können nun auch gesetzt werden, indem ein Pointer auf eine andere dynamische Variable gegeben wird,
  anstelle eines statischen Typs (äquivalent zu Func, wo DynParam übergeben werden kann). Neben z.B. pVar->SetInt()
  gibt es nun also auch pVar->SetVar(pVar2).
- Objekt: Interface um einige Komfort-Funktionen erweitert, z.B. SetAttribute(), CallMethod() etc (Abkürzungen für
  den längeren Weg :-))
- Objekt: Methoden hinzugefügt, um alle Variablen zu laden oder zu speichern (per String oder XML).



>> 08.04.2010 (PLCore2)
[SB]
- Neue Klasse MemberDesc erstellt. Dies ist die Basisklasse für alle Member einer Klasse wie z.B. Attribute, Method etc.
  Dies erleichtert es beispielsweise, über alle Member einer Klasse zu iterieren, ohne für jeden Member-Typus eine eigene
  Schleife schreiben zu müssen.
- Class: Methodik implementiert, um Member von Klassen in abgeleiteten Klassen zu vererben, die (hoffentlich) sowohl
  simpel als auch mächtig ist. Zunächst werden alle Member einer Klasse über Selbst-Initialisierung nur bei der Klasse
  selbst registriert und dort in einer Liste "eigener Member" gespeichert. Da hier das Static-Initialization-Dilemma
  einsetzt, die Reihenfolge in der sich die Member registrieren also nicht vorhergesehen werden kann, muss damit gerechnet
  werden, dass später noch weitere Member der eigenen Klasse oder einer Basisklasse hinzukommen können. Um dieses Problem
  zu lösen, gilt die Klasse zunächst so lange als nicht initialisiert, bis versucht wird, auf die Member der Klasse
  zuzugreifen. Erst dann wird die Klasse initialisiert, was dazu führt, dass sie alle ihre Member aufzählt und internen
  Listen von Attributen, Methoden etc. aufbaut, welche dann für den Zugriff auf die Member verwendet werden. Dabei werden
  auch die Member der Basisklassen mit aufgezählt, wodurch auch die Reihenfolge der Member die richtig ist. Wenn nun später
  noch Member zu einer Klasse hinzugefügt werden, die bereits initialisiert wurde, führt dies dazu, dass diese Klasse sofort
  wieder de-initialisiert wird und dann wieder als nicht initialisiert gilt, bis ein Zugriff auf die Klasse erfolgt, der
  wieder zu einer Initialisierung führt (wodurch dann auch wieder alle Member korrekt aufgelistet werden). Auf diese Weise
  sollte sichergestellt sein, dass immer alle Member bekannt sind, auch wenn diese sich erst später angemeldet haben. Auch
  ist zu hoffen, dass eine Klasse nicht zu häufig initialisiert und wieder de-initialisiert werden muss, da dies eigentlich
  nur dann passieren kann, wenn eine Klasse zu früh initialisiert wird (auf das RTTI sollte also möglichst erst ab der
  Main-Funktion zugegriffen werden). Zudem führt dieses System dazu, dass Klassen, auf die überhaupt gar nicht zugegriffen
  wird im Laufe des Programmes, auch niemals ihre Member initialisieren müssen, was ein zusätzlicher Gewinn ist :-)
- Class, Object: Methoden für den Zugriff auf alle Member hinzugefügt (sowohl Listen aller Member sowie einzelne Member).



>> 07.04.2010 (PLCore2)
[SB]
- Klasse FuncDesc hinzugefügt, welche einen Descriptor für Funktionen und Methoden innerhalb einer Klasse darstellt.
- RTTI-Makros für die Deklarations von Methoden hinzugefügt.
- Klasse EventDesc hinzugefügt, welche einen Descriptor für Events und Signals innerhalb einer Klasse darstellt.
- Klasse EventHandlerDesc hinzugefügt, welche einen Descriptor für EventHandler und Slots innerhalb einer Klasse darstellt.
- RTTI-Makros für Events und EventHandlers hinzugefügt. 
- Klasse Constructor wurde in FuncConstructor umbenannt, da dies auch nur ein spezieller Funtoid ist, der ein Objekt
  erzeugt.
- Neue Klassen Constructor und ConstructorDesc implementiert, welche sich analog zu Attributen und Methoden um die Deklaration
  von Konstruktoren in Klassen kümmern. Constructor kann hier allerdings nicht komplett Analog zu den anderen genannten
  Klassen sein, da im Gegensatz zu Attributen und Methoden ein Constructor bei Class und nicht bei Object angesiedelt sein
  muss (ein Konstruktor wird von einer *Klasse* aufgerufen und gibt ein Objekt zurück, ein Constructor auf ein schon
  bestehendes Objekt anzuwenden, ergibt dagegen keinen Sinn). Daher unterscheidet sich die Klasse ConstructorDesc hier etwas
  von den anderen Konstruktoren, indem sie z.B. nicht nur den Konstruktor beschreibt (Name etc.), sondern gleichzeitig
  auch die Instanz des eigentlichen Konstruktor-Functoids beinhaltet. 
  so speichert bspw.
- RTTI-Makros für Konstruktoren hinzugefügt.
- Methoden hinzugefügt, um Instanzen von Klassen zu erzeugen:
  - ConstructorDesc stellt die Methode Create() zu verfügung, welche den jeweiligen Konstruktor aufruft
  - Class hat drei weitere Create()-Methoden, mit denen alle Konstruktoren einer Klasse aufgerufen werden können.
    Hier kann entweder der Default-Konstruktor aufgerufen werden, oder es wird entweder per Namen oder per Signatur nach
    einem bestimmten Konstruktor gesucht.



>> 06.04.2010 (PLCore2)
[SB]
- Event und EventHandler implementiert. Ein Event-Handler verhält sich zunächst einmal genau so wie ein Funktor, stellt
  aber zusätzliche Funktionalität bereit, die es erlaubt, Events und EventHandler miteinander zu verknüpfen. Wenn ein
  Event ausgelöst wird, werden automatisch alle angemeldeten EventHandler aufgerufen. Events und EventHandler wissen
  über gegenseitige Verbindungen bescheid, so dass Verbindungen automatisch entfernt werden, wenn eine der beiden Seiten
  beispielsweise gelöscht wurde.
- Klassen Event und EventHandler so verändert, dass hier immer der Rückgabetypus void festgelegt ist. Während bei generellen
  Functoiden und Functoren ein beliebiger Rückgabetypus verwendet werden kann, ergibt dies bei Events nicht so richtig
  viel Sinn. Was soll beispielsweise ein Event zurückgeben, wenn mehrere EventHandler aufgerufen wurden und jeder davon
  einen anderen Rückgabewert zurückgeliefert hat? Der Einfachheit halber haben daher nun alle Events und EventHandler den
  Rückgabetyp void.
- Kommentierung für RTTI-Makros erweitert.



>> 05.04.2010 (PLCore2)
[SB]
- Statische Funktions-Pointer (FuncFuncPtr) und Memberfunktions-Pointer (FuncMemPtr) als Ableitung von Func implementiert.
  Diese Funktions-Pointer, welche die Basis für Functoren sind, verhalten sich also genau so wie andere Functoide, tragen
  intern aber einen Zeigen auf eine Funktion mit sich herum :-)
- Functor implementiert. Ein Funktor ist ein spezieller Typus eines Functoids, der einen Zeiger auf eine andere
  Funktion beinhaltet. Wenn der Functor aufgerufen wird, ruft er die jeweils gespeicherte Funktion auf, stellt damit
  also eine Art generischen Funktionspointer dar.
- Func: Virtuelle Methode Clone() hinzugefügt, die benötigt wird, wenn eine Kopie eines Functoids angefertig werden soll.
  Dies wird von Functor verwendet, wenn eine Funktion einem Functor zugewiesen oder ein Functor kopiert werden soll.
- Basisklasse Constructor von ClassConstructor entfernt, statt dessen ClassConstructor in Constructor umbenannt.



>> 04.04.2010 (PLCore2)
[SB]
- Attributen müssen nun immer mit einen Zeiger auf das Object initialisiert werden. Das wäre zwar eigentlich nur für
  die Attribute notwendig, welche Get/Set-Methoden verwenden, aber dann wäre das ganze inkonsistent, weil manche Attribute
  initialisiert werden müssten, andere aber nicht. Es scheint mir daher sinnvoller, dies bei allen Attributen einheitlich
  zu gestalten, zumal man manchmal auch aus anderen Gründen den Zeiger auf das Object gebrauchen kann.
- Variablen: Alle Klassen noch einmal durchgesehen und die Dokumentation überarbeitet.
- Functor: Basisklasse DynFunc erstellt, diese Klasse steht allgemein für alle typisierten Funktionen bzw. Funktionsobjekte.
- Functor: Basisklasse DynParams erstellt, diese Klasse stellt die Basis für typisierte Parameter dar.
- "Functor" in "Func" umbenannt und alle Klassen und Ordner angepasst.
- Funktions-Objekte (Functoide) und Konstruktoren implementiert.



>> 29.03.2010 (PLCore2)
[SB]
- Type: Es werden nun keine Funktions-Templates, sondern statt dessen normale Funktionen mit festgelegten Namen verwendet.
  Jeder Typ muss hier die Umwandlungs-Funktionen für alle bekannten statischen Typen zur Verfügung stellen (ConvertToInt(),
  ConvertFromInt() etc.). Dies ist notwendig, da es ansonsten nicht möglich wäre, Standardtypen wie z.B. int in nicht-standard
  Typen umzuwandeln, da es ja bspw. kein Type<int>::ConvertToMyType() gibt. 
- Klasse Types entfernt, welche zuvor verwendet wurde, um zwischen Type-ID und Type-Name umzuwandeln. Leider sind diesem
  Mapping natürlich die nicht-standard Typen unbekannt, weshalb das ganze System nicht sehr sinnvoll ist. Statt dessen hat
  nun jeder Typus die entsprechenden Methoden GetTypeID() und GetTypeName() zur Verfügung zu stellen.
- Klasse Attribute in Var umbenannt.
- Klasse TypedVarDesc entfernt, da diese nicht wirklich notwendig ist zwischen VarDesc und VarDesc_VARNAME.
- Enumerations zum RTTI Typensystem hinzugefügt.



>> 28.03.2010 (PLCore2)
[SB]
- Tools: Klasse CompileError erstellt. Dies ist ein Template, das verwendet werden kann, um Compiler-Fehler zu erzeugen.
  Hierbei gibt es zwei Versionen, das eine Mal wird der Fehler in jedem Fall erzeugt, das andere Mal hängt dies noch
  von einer Kondition ab (es wird nur dann ein Fehler generiert, wenn eine bestimmte Aussage zutrifft).



>> 27.03.2010 (PLCore2)
[SB]
- Die Helferklassen für Access und Storage wurden umbenannt und in eigene Header-Dateien verschoben: TypedAttrAccess.h and TypedAttrStorage.h
- Template Signatur erstellt (dieses stellt den 'Typus' von Funktionen dar)
- Basisklasse für Functoide und Konstruktoren erstellt (noch lange nicht einsatzbereit)



>> 26.03.2010 (PLCore2)
[SB]
- Klassen, in denen keine Attribute definiert wurden, werden nun auch korrekt am System angemeldet.
- Attribute können nun Default-Werte haben.
- Attribute können nun als read/write oder read-only definiert werden.
- Attribute haben nun Zuweisungs- und Conversion-Operatoren. Man kann daher nun z.B. direkt
  'AttrInt = 3' oder 'int nValue = AttrInt' schreiben.
- Helferklassen eingebaut, um den Storage-Type eine Attributes festzulegen:
  - StorageDirectValue speichert den Wert eines Attributes direkt innerhalb einer privaten Variable.
  - StorageGetSet ruft zum Setzen oder Abfragen des Wertes die jeweilige Get- oder Set-Methode des Objektes
    auf, hier wird der Wert also nur indirekt gesetzt und keine eigene Variable instanziiert.
  Bis jetzt ist nur StorageDirectValue implementiert.
- Externer Storage-Type wurde implementiert. Hierfür muss eine externe Klasse angegeben werden, welche die
  notwendigen Get()/Set()-Methoden für das jeweilige Attribut zur Verfügung stellt. Diese Klasse wird dann
  vom Attribut verwendet, um auf den Inhalt der Variablen zuzugreifen, die eigentliche Speicherung der Daten
  kann innerhalb dieser Klasse also beliebig implementiert werden.



>> 25.03.2010 (PLCore2)
[SB]
- RTTI makros für Klassen und Attribute erstellt.
- Attr: GetDesc() wurde nun als virtuelle Funktion innerhalb der Basisklasse implementiert, somit ist es nun immer
  möglich, an den Descriptor zu gelangen, sobald man einen Zeiger auf ein Attribut hat.
- Class: Namespace und Description hinzugefügt.
- ClassManager hinzugefügt.



>> 24.03.2010 (PLCore2)
[SB]
- Erste einfache template-basierte RTTI Funktionalität implementiert. Es ist bereits möglich, Attribute von Klassen
  zu definieren und auf diese zuzugreifen. Alles ist komplett template-basiert, bisher wurden noch keinerlei Makros
  verwendet (natürlich werden später auch wieder Makros zur Verfügung gestellt, um die Verwendung der Templates
  hinter einfacheren Konstrukten zu verstecken, aber die eigentlich Funktionalität wird hoffentlich nur auf
  Templates basieren und keine Makro-Tricks mehr beinhalten wie z.B. Pointer-Arithmetik zum Ausrechnen von
  Speicheradressen o.ä.).
- Auflisten und Abfragen von Attribute-Descriptoren (bei der Klasse) und Attributen (beim Objekt) wurde implementiert.



>> 23.03.2010 (PLCore2)
[SB]
- Mit neuem System angefangen, daher erst einmal wieder in einem separaten Projekt (PLCore2), damit das alte PLCore
  zunächst einmal parallel erhalten bleiben kann, ohne dass es Konflikte gibt.
- Mit neuem RTTI begonnen, welches dieses Mal zum Großteil auf C++ templates basieren soll:
  - Type eingebaut als statischen Wrapper für die C++ Datentypen
  - Types ist eine statische Helfer-Klasse, die es bspw. erlaubt, Type-IDs in Strings umzuwandeln u.ä.
  - TypedAttr ist ein Class-Template für typisierte Attribute (also Variablen, die direkt einen Wert besitzen)
  - Attribute ist eine virtuelle Basisklasse für Attribute



>> 21.03.2010
[SB]
- HttpClient: Fehler bei der HTTP-Authentification behoben: Benutzername und Passwort wurden falsch übermittelt, wodurch
  eine Anmeldung natürlich nicht möglich war. Ausserdem wird nun auch das HTTP-Verb "DELETE" unterstützt.



>> 14.03.2010
[CO]
- "Config", "ConfigLoader" und "ConfigLoaderPL" nach PLCore ins Application-Verzeichnis verschoben (siehe PLCore-Tagebuch
  für mehr Informationen)
PLCore:
- "Config", "ConfigLoader" und "ConfigLoaderPL" von PLGeneral nach PLCore ins Application-Verzeichnis verschoben. Zukünftig
  sind "Konfigurationen" ausschließlich in Verbindung mit Application-Instanzen zu sehen. Ich konnte keinen Grund finden,
  wieso z.B. die Renderer-Klasse ein Konfigurations-Objekt haben sollte - dafür kann man genauso gut einfache Funktionen
  und oder das RTTI nutzen! "Konfiguration" sind eigentlich ja nur dann Interessant wenn man als Anwendungs-Programmierer Einstellungen
  "von Außen" über eine Text-Datei einstellbar haben will, oder Programm-Einstellungen wegspeichern und wiederherstellen will.
  Was es jedoch an relevanten Programm-Einstellungen gibt, weis eigentlich nur ein Anwendungs-Programmierer. Man kann schlecht
  *alles* was die einzelnen Komponenten an Variablen haben wegspeichern, das würde auch gar keinen Sinn machen. Als Anwendungs-Programmierer
  kann das sogar total lästig und unerwünscht werden wenn die "Engine" von sich aus Dateien rausschreibt - denn es kann sehr wohl
  auch mal Anwendungen geben die sich rein passiv zu verhalten haben, also nur von einer Festplatte lesen sollen, aber nix schreiben
  oder gar neue Dateien anlegen.
  Das Application-Framework bring natürlich wieder so Konfigurations-Objekte rein, aber das ist ja alles als Vereinfachung gedacht so
  das man sich nicht mehr um alles kümmern muss. Dies ist allerdings nicht fest in *PL verwurschtelt*, sondern man kann auch gut ohne
  diese Framework arbeiten und hat dann volle Kontrolle.
- "Config" ist kein Singleton mehr
- "Application" besitzt nun eine "Config"-Instanz. Das Konfigurations-System als solches ist also momentan noch so wie gehabt, nur das
  es kein Singleton mehr ist, sondern jede Application-Instanz eine eigene Konfigurations-Instanz besitzt. Des Weiteren nutzen nur noch
  Application-Instanzen Konfiguration und nicht mehr alle möglichen PixelLight-Komponenten. Dies stellt daher denke ich schonmal
  eine Verbesserung da.



>> 22.01.2010
[SB]
PLCore:
- Application::GetApplication(): Export in DLL hinzugefügt.



>> 19.01.2010
[SB]
- ThreadLinux: Wie es aussieht, ist die Thread-Implementation unter Linux noch so gut wie unbrauchbar. Leider kenne ich
  mich mit dem Threading ja auch so gut wie nicht aus, und müsste mich da nun enorm einarbeiten, um das irgendwie brauchbar
  zu machen. Die schlimmsten Fehler habe ich nun aber erstmal korrigiert bzw. umgangen:
  - pthread_kill(m_nThreadID, SIGKILL) ist *nicht* geeignet, um einen Thread zu beenden. Das Signal beendet immer den
    gesamten Prozess, auch wenn es an einen bestimmten Thread eines Prozesses gesendet wird. Daher wurde nun bei uns jedes
    Mal das gesamte Programm beendet, wenn nur ein Thread oder z.B. ein Timer beendet werden sollte. Zum Beenden eines
    Threads verwende ich nun pthread_cancel(). Diese Fehler hat natürlich dazu geführt, dass das Programm ständig "abstürzte",
    nun macht das alles schon einen deutlich stabileren Eindruck unter Linux :-)
  - Es gibt keinen timed-join Befehl in pthreads, also einen Befehl der bis zu einem bestimmten Timeout darauf wartet, dass
    ein Thread beendet wurde. Statt dessen hatte ich hier bisher einfach join verwendet, also ohne Timeout zu warten, was dann
    aber zu einem Einfrieren der Applikation führt, wenn sich ein Thread nicht freiwillig beendet. Daher lasse ich diese
    Funktion nun erst einmal komplett fehlschlagen, damit das zumindest nicht mehr passieren kann, hier müsste dann eine
    timed-join Operation implementiert werden, wofür ich auch schon ein Beispiel gefunden habe.



>> 30.11.2009
[SB]
- Neue und umfangreiche HTTP-Implementation erstellt. Dies umfasst sowohl einen HTTP-Client, als auch einen minimalen
  Http-Server. Der Client ist um einiges umfangreicher als die alte HttpHandle-Klasse und kann HTTP/1.0 sowie HTTP/1.1.
  Damit ist auch die "Download fortsetzen"-Funktion möglich, bzw. das auslesen beliebiger Teile einer Datei, sofern der
  Server das zulässt, was die Verwendung der File-Klassen und Seek() einfacher und vor allem deutlich schneller machen
  sollte. Auch ist die Klasse ansonsten umfangreicher, z.B. werden alle HTTP-Fehlercodes verstanden und können entsprechend
  abgefragt werden etc. Daneben gibt es noch einen sehr minimalistischen HTTP-Server, der dazu verwendet werden kann, aus
  einem Programm heraus z.B. eine kleine Weboberfläche zur Verfügung zu stellen. Die Server-Klasse ist dabei eine reine
  Basisklasse, die HTTP-Anfragen entgegennimmt und weiterleitet, von sich aus aber erstmal nur eine statische Seite
  anzeigt. Die eigentliche Funktionalität muss also in der abgeleiteten Klasse implementiert werden, z.B. was für
  Seiten auf welche URLs hin generiert werden sollen. Auch ist dies kein HTTP-Server in dem Sinne, dass er Dateien von
  der Festplatte lesen und auf HTTP bereitstellen würde, da der Anwendungsfall eher auf dynamisch generierte Web-Applikationen
  abzielt (z.B. als Weboberfläche für einen Spiele-Server). Allerdings wäre es recht einfach, dies in einer abgeleiteten
  Klasse zu implementieren :-)



>> 29.11.2009
[SB]
- Time: Die Monate werden nun von 1 an gezählt, statt wie bisher von 0. Es ist einfach völlig unintuitiv, wenn nur die
  Monate ungewohnt bei 0 anfangen, der Rest aber wie gewohnt von 1 an gezählt wird. Habe das nun daher verändert und hoffe,
  dass ich alle Verwendungen in PL entsprechend korrekt angepasst habe (-1 entfernt wo nötig und +1 hinzugefügt wo nötig).
  Allerdings wurde die Time-Klasse zum Glück bisher nicht so häufig verwendet, es dürften also wohl nicht allzu viele
  mögliche Fehlerstellen jetzt vorhanden sein.



>> 25.10.2009
[SB]
- Base64-Funktion nach Tools verschoben, da man diese Funktion später noch einmal brauchen könnte.



>> 24.10.2009
[SB]
- Connection: Mir ist gerade aufgefallen, dass es nicht unbedingt immer erwünscht ist, dass eine Connection automatisch alle
  Daten ausliest, die man ihr zuschicken will. Beispielsweise bei einem HTTP-Client würde man wohl erst den Header lesen,
  und dann entscheiden, ob man die Daten ausliest oder nicht (könnten ja auch große Dateien sein). Aus diesem Grund kann
  nun per Option eingestellt werden, ob eine Connection automatisch alles liest, was ihr geschickt wird, oder ob dies
  manuell aufgerufen werden muss. Dafür die Option EReceiveMode sowie die Methoden Receive() und ReadLine() eingebaut.
  ReadLine liest Text-Daten vom Stream und gibt diese Zeilenweise zurück. Dabei wird das EOL-Zeichen nicht automatisch gelöscht,
  da dies in manchen Kontexten wichtig ist, dies muss daher ebenfalls manuell geschehen. Ebenso wird nun beim Senden von
  Strings (Send()) nicht mehr automatisch CRLF angehängt, da dies auch nicht immer erwünscht ist. Für Zeilenenden ist nun
  also die jeweilige Anwendung selbst verantwortlich.
- Buffer: Einige Fehler behoben. Beim zeilenweisen Auslesen werden nun sowohl CRLF als auch nur LF als Zeilenenden akzeptiert.
  Zusätzliche Methode GetData() eingebaut, damit man auch auf den Inhalt des Buffers zugreifen kann.



>> 23.10.2009
[SB]
- Network: Habe die Basisklassen aus PLNetwork nach PLGeneral verschoben und noch einmal gründlich überarbeitet.
  Es scheint mir sinnvoll, diese Basisklassen bereits in PLGeneral zu haben, denn mit Sockets alleine zu arbeiten
  ist ziemlich mühsam und nicht sinnvoll, deswegen sollten immer diese Basisklassen verwendet werden, wenn es darum
  geht, Netzwerkfunktionalität einzubauen. Daher ergab die Trennung hier nicht viel Sinn, und eine weitere Bibliothek
  zu verwenden stellt immer eine zusätzliche Hürde dar, daher ist es besser, diese Klassen gleich in PLGeneral verfügbar
  zu haben. Die Netzwerk-Basisklassen bieten selber nur ein minimales Framework um Socket herum an, und durch die
  Überarbeitung wurde auch alles noch einmal deutlich schlanker und eleganter, so dass letztlich nur 5 zusätzliche
  Klassen herausgekommen sind, die PLGeneral daher auch nicht unnötig aufblähen sollten :-)
PLNetwork:
- Netzwerk-Basisklassen nach PLGeneral verschoben. Dieses Projekt ist damit zwar erstmal leer, bleibt jedoch erhalten,
  da ich mir sicher bin, das man dafür später noch Verwendung haben wird. Beispielsweise könnten hier Basisklassen
  für typische Netzwerk-Komponenten erstellt werden (z.B. Messenger, Chat, ...), welche dann von spezialisierten Backends
  wie PLIRC oder PLJabber implementiert werden. Auch wird es natürlich Basisklassen für die Netzwerksynchronisation brauchen,
  welche später die Grundlage für die tatsächliche Netzwerkfunktionalität in der Engine bieten wird. Daher ist es denke
  ich sinnvoll, dieses Projekt gleich beizubehalten, wenn es auch derzeit nicht genutzt wird.



>> 22.10.2009
[SB]
- String: Neue Methode RemoveLineEndings() eingebaut, die Markierungen für das Zeilenende ("\r" oder "\r\n") am
  Endes des Strings löscht. Das ist insbesondere dann wichtig, wenn in einem Netzwerkprotokoll die Zeilenenden
  entscheidend sind und daher Strings nicht gleich "bereinigt" werden sollten.
PLNetwork:
- Buffer: Option m_bRemoveDelimiters hinzugefügt. Damit kann festgelegt werden, ob die Zeilenenden in einem
  Protokoll automatisch entfernt werden sollen, oder in den zurückgegebenen Strings drin bleiben sollen. In manchen
  Protokollen ist es wichtig, dass diese Zeichen nicht entfernt werden, da z.B. eine Leerzeile eine besondere
  Bedeutung hat. Wenn die Zeilenenden aber entfernt werden, könnte nicht mehr zwischen eine leeren Zeile ("\r\n") und
  einem leeren String ("") unterschieden werden, der zurückgegeben wird um anzuzeigen, dass noch keine weitere Zeile
  gelesen wurde.



>> 20.10.2009
[SB]
- Time: Neue Methode GetDaysPerMonth() spendiert, um die Anzahl an Tagen in einem Monat abzufragen.



>> 18.10.2009
[SB]
- Habe meine alte Klasse 'HMLTParser' vom letzten Jahr wieder ausgegraben und reaktiviert :-) Diese Klasse hatte ich
  geschrieben, damit man eine HTML-Datei parsen und als Ergebnis einen XML-Syntaxbaum herausbekommen kann. Zwar hatte
  ich dann die gesamte HTML-Anwendungsidee verworfen und in dem Zusammenhang auch den Parser wieder gelöscht, aber
  da ich nun wieder einmal merke, wie praktisch es ab und zu wäre, HTML-Dateien einlesen zu können, habe ich die
  Klasse nun wiederhergestellt und noch ein wenig erweitert sowie ein paar Fehler behoben. Der Parser selbst sollte
  nun relativ robust sein, allerdings besteht natürlich immer noch keine Garantie dafür, dass er in der Lage ist, eine
  beliebige HTML-Seite fehlerfrei einzulesen. Dafür ist der HTML-Syntax viel zu unübersichtlich und es gibt zu viele Arten
  von Erweiterungen über eingebettete Scripte etc. Nun werden allerdings Kommentare und einige andere Tags von vornherein
  ignoriert, daher dürften einiger Maßen wohlformatierte Seiten jetzt eigentlich problemlos eingelesen werden können. Also
  falls man mal in irgendeinem Zusammenhang HTML-Seiten einlesen bzw. parsen muss, gibt es dafür nun eine Klasse, die man
  als Basis dafür verwenden kann.



>> 16.10.2009
[SB]
- FileObject und Url: Methoden für den Zugriff auf URLs überarbeitet. GetUrl_() in GetUrl() umbenannt, da denke ich die
  Verwendung und Bedeutung dieser Methode inzwischen klar festgelegt ist. In FileObject alle "Abkürzungen" entfernt,
  um direkt auf den Dateinamen zuzugreifen, es muss nun also immer GetUrl() verwendet werden und von dort aus weitere
  Methoden, um die URL als String zu erhalten. Ich bin mittlerweile ein Freund davon, keine unnötigen doppelten Funktionen
  irgendwo einzubauen, sondern lieber klar nur eine Möglichkeit zur Verfügung zu stellen. Das sieht zwar manchmal nicht so
  hübsch aus, ist dafür aber verständlicher und leichter nachzuvollziehen. Schließlich GetWindow(), GetLinux() etc. wieder
  in GetWindowsPath(), GetLinuxPath() etc. umbenannt, denn der Name sollte schon irgendwie darauf hindeuten, was dort
  zurückgegeben wird (auch wenn "Path" nicht ganz korrekt ist, aber hier fehlt es halt an einem eindeutigen Überbegriff für
  Pfade, URLs etc.).



>> 03.09.2009
[CO]
PLCore:
- "Event::Emit()": Der Zeiger auf den nächsten Event Handler wird nun auf dem Stack zwischengespeichert bevor der Functor
  aufgerufen wird... da man damit rechnen muss das innerhalb des Functors der aktuelle Event Handler gelöscht wird sollte
  man diesen dann nach dem Functor nicht mehr nutzen. Damit ist es nun möglich in Functoren soweit problemlos Event Handler
  während eines Emits zu löschen - neue hinzufügen wird natürlich je nach Situation immer noch für Anomalien sorgen.
  (aber wohl weniger wahrscheinlich welche die in Crashs resultieren :)



>> 26.08.2009
[CO]
PLCore:
- "TimerWindows::TimerFunction()": Ich hatte hier gerade das Problem das ein "einmalig Feuern Timer" mehrmals feuerte...
  kann mir das noch nicht richtig erklären, aber wenn ich in der Callback Funktion hier ZUERST den Timer stoppe und dann
  das Event abgebe geht das hier momentan. Seltsam seltsam...



>> 06.08.2009
[CO]
- "uint32" wird nun mit "__int32" definiert, das gleiche gilt für alle ähnlichen Typen
- "HashFunction" & "CompareFunction" um 64 Bit Datentypen erweitert... ansonnsten gibts Probleme wenn man in einer
  HashMap als Schlüssel z.B. "UINT_PTR" unter 64 Bit nutzen will, dann weis der Compiler nicht was er nehmen soll



>> 02.08.2009
[CO]
- "RegEx": Neue Funktion: "WildcardToRegEx()": Wandelt einen gebenen String mit Wildcard in einen String mit Regulären
  Ausdruck um
- "Map": "GetKeyIterator()", "GetConstKeyIterator()", "GetEndKeyIterator()" & "GetConstEndKeyIterator()" hinzugefügt
  damit man bei "Map" ebenfalls durch die Schlüssel iterieren kann
- "HashMapKeyIterator" & "SimpleMapKeyIterator" hinzugefügt



>> 20.06.2009
[SB]
PLCore:
- CMakeFiles.txt: TimerWindows darf aber bitteschön auch nur unter Windows eingebunden werden :-)



>> 17.06.2009
[CO]
PLCore:
- "Timer", "TimerImpl", "TimerWindows" und "ThreadTimer" von PLGui3 hierhin kopiert, aber in PLGui3 noch genauso drinnen
  gelassen. Habe die Klassen erstmal in den Grundordner gelegt da mir kein brauchbarer Name für einen Unterordner einfiel
  - da kommen ja noch einige Klassen bei Zeiten hinzu und dann findet sich sicherlich ne nette Gruppe der sich der Timer
  anschließen kann. :D
  Da "ThreadTimer::Run()" in einem Thread läuft kann der Timer allerdings zu jeder Zeit feuern... etwas das sicherlich
  schnell Problematisch werden kann. Eventuell wäre ne art von "TimerManager"/"TimerScheduler" Klasse nett über die
  man die Timer Synchronisieren kann... also quasi in der Art "So Leute, wer bereit ist - FEEEUER!". *g*
  Was beim Threaded Timer auch noch ein Problem ist, ist das "Stoppen" da die genutzte "Sleep()" nicht unterbrochen
  wird und der Timer erstmal ablaufen muss.
- "ThreadTimer::StartTimer()" und "ThreadTimer::StopTimer()": Der Thread wird hier gestartet und "abgewürgt", damit
  wird der Timer bei stop sofort angehalten. Damit verhält es sich wie "TimerWindows". Ich hatte mir zuerst die
  Windows Funktion "QueueUserAPC()" angeschaut aber irgendwie wurde das zuviel des guten.



>> 03.06.2009
[CO]
PLCore:
- "Application": Neue Funktion "IsRunning()" gibt zurück ob die Anwendung gerade läuft



>> 10.05.2009
[CO]
- "ZipHandle::ReadCurrentFileInfo()": Autsch, hier hatten wir ein übles Speicherleck wenn "m_cCurFile.m_nSizeFilename"
  0 war... denn hier muss noch ein Zeichen für \0 angehängt werden. Die String Klasse übernimmt dann die Kontrolle
  über den Speicher, bekommt aber die Original Speicherlänge ohne +1 und denkt sich dann "hopala, leerer String!"
  und übernimmt dann natürlich nicht die Speicherkontrolle da der Speicher ja scheinbar leer ist. Und dann müllt
  sich der Speicher langsam mit Herrenlosen frühlich frei herumschwirrenden 1 Bytes voll.
- "ClassManager::LoadPlugin()" sollte auch mehrmals aufgerufen werden können ohne das es bereits vorhandene
  Module erneut hinzufügt, baute daher einen entsprechenden Test ein.



>> 07.05.2009
[CO]
- "BinaryHeap", "BinominalHeap" und "FibonacciHeap" hatten Fehler so das der Compiler einem kryptische Fehler nur
   so um die Ohren schlug wenn man versuchte den "Comparer" durch einen eigenen zu ersetzen



>> 01.05.2009
[CO]
- "Bitset"-Konstruktor: Beseitigte eine Inkonsistenz zu "Array" und "Resize()": Die Standardeinstellungen von
  "bAdded" und "bInit" sind nun identisch. "Bitset" wird bis jetzt zum Glück sehr selten eingesetzt so das es
  nur wenige Stellen waren die einer Prüfung bedurften. (Änderung dieser Art sind ja immer sehr heikel :/)
- "Bitset" um superkomplexe "Reset()"-Funktion die es ebenfalls auch in "Array" gibt erweitert... setzt einfach
  die aktuelle Anzahl an Elementen auf null so das es einem "Clear()" gleichkommt, aber deutlich schneller ist da
  der angelegte Speicher erhalten bleibt. (hin und wieder sehr praktisch soetwas :)



>> 26.04.2009
[CO]
- "SystemWindows::GetOS()" erkennt nun auch Windows 7



>> 22.04.2009
[CO]
- Änderte einige Methoden der String-Klasse minimal so das die heute von Stefan festgestellten unschönheiten beseitigt sind



>> 22.04.2009
[SB]
- RegEx: Workaround eingebaut, da String::Copy() mit der Länge 0 den gesamten String zurückgibt anstelle der leeren Strings ("").
  Ich denke dies sollten wir dringend überarbeiten, denn dieses Verhalten ergibt zwar Sinn, wenn man 0 nur als Defaultwert,
  sprich als "nicht angegeben" betrachtet, verhindert aber, dass man den Wert 0 als tatsächliche Länge eines Substrings angeben
  kann. Und dies führt zu einem sehr ungewöhnlichen Verhalten, denn wenn ich z.B. alle Prefixes alles Strings mit sowas wie
  for (int i=3; i>=0; i--) sPrefix = sString.GetSubstring(0, i); abfrage, würde ich wohl eher ["abc", "ab", "a", ""] erwarten
  als ["abc", "ab", "a", "abc"] (siehe Test99).



>> 22.04.2009
[CO]
- "File": Neue Funktion: "GetMemoryBuffer()": Falls die Datei "im Speicher liegt" kann man sich hiermit direkt einen Zeiger auf
  den Speicher geben lassen. Ist zwar irgendwie "unschön" aber "praktisch" da man dadurch in einigen Fällen die Performance
  in Anwendungen verbessern kann... denn wenn man "weis" das eine Datei bereits komplett im Speicher liegt und man die Datei im
  Speicher braucht um diese mit anderen Funktionen weiterzuverarbeiten - dann muss man nun nicht mehr einen "Zwischenbuffer"
  erzeugen, die ganze Datei "einlesen", Arbeit erledigen und "Zwischenbuffer" wieder freigeben... sondern man nutzt direkt
  den bereits die bereits im Speicher liegende Datei. :D



>> 16.04.2009
[SB]
PLPlugin:
- Fehlende Abhängigkeiten in der CMakeLists.txt hinzugefügt.



>> 15.04.2009
[CO]
- Spendierte der "File"-Klasse einen weiteren Konstruktor dem man einen Buffer übergeben kann... was hin und wieder
  ziemlich praktisch ist da "Dateien" dann nicht zwanghaft direkt von der Festplatte kommen müssen.
- "Base::SetVars()": In meinem Regulären Ausdruck war noch ein böser Fehler drinnen so das beim Wert ' am Ende stehen konnte...
  generell hab ich hier noch etwas Probleme mit " und ' richtig erkennen und habe das momentan etwas umständlich gelöst -
  Stefan... falls du ne Idee hast wie man das alles zusammen in einem netten Ausdruck vereinen könnte... :D



>> 12.04.2009
[SB]
- System: Exit() hinzugefügt, um die Applikation sofort beenden zu können. Dies ist natürlich nur ein Wrapper für die jeweilige Systemfunktion.
PLCore:
- Application: Neue Methode OnKill() hinzugefügt, die aufgerufen wird, wenn das Betriebssystem versucht, die Applikation zu beenden. Standardmäßig ist
  diese Methode so implementiert, dass sie sofort Exit() aufruft und die Applikation damit zwangsweise beendet. Durch Überschreiben dieser Methode kann
  aber z.B. dafür gesorgt werden, dass erst einmal die aktuelle Aufgabe zu Ende gebracht wird und sich die Applikation hinterher ordentlich beendet.
- Application: Unter Linux wird nun das Signal SIGTERM aufgefangen und dann die Methode OnKill() aufgerufen.
- Application: Zugriffsmethoden für die Versions-Variable hinzugefügt.
- Application: Einen statischen Pointer auf die aktuelle Application-Instanz hinzugefügt. Wenn es anders geht, sollte dies zwar nicht unbedingt verwendet
  werden, aber solange man darauf achtet, immer nur *eine* Application zur Zeit zu haben, bietet dies nun eine sehr einfach Methode, um schnell an diese
  wichtige Application-Instanz und damit auf alle anderen Dinge darin heranzukommen :-)



>> 11.04.2009
[SB]
- CommandLine erweitert, um möglichst viele der üblichen Kommandozeilen-Optionen abzudecken. Ich hoffe mal, mit dieser
  aufgebohrten Klasse kommt man weit genug und kann auch komplizierte Kommandozeilen-Optionen definieren, damit man da
  möglichst nicht ständig wieder einen eigenen Parser schreiben muss. Es gäbe natürlich noch viel mehr Möglichkeiten, aber
  alles abzudecken wäre wirklich zu kompliziert und daher nicht mehr sinnvoll. Auch ist zu beachten, dass diese Klasse nun
  zwar vieles erlaubt, aber nicht alles auch auf Plausibilität prüft (z.B. beim Festlegen von benötigten und optionalen
  Parametern). Hier muss der Programmierer also noch selber darauf achten, dass er nicht unsinnige oder wiedersprüchliche
  Angaben macht. Die Änderungen im Detail:
  - Es gibt nun drei Typen von Optionen: Flags, Parameter und Argumente.
  - Ein Flag besteht nur aus einer Option (z.B. '-a' oder '--optiona') ohne weiterem Argument dahinter und
    kann einen kurzen sowie einen langen Namen haben.
  - Ein Parameter besteht aus einer Option und einem Argument dahinter (z.B. '-n <name>' oder '--name <name>').
    Die Möglichkeit, dass dieses Argument optional ist, besteht *nicht* (ich finde aber auch nicht, dass man das braucht).
  - Ein Argument wird ohne ohne Option davor angegeben (z.B. "app.exe <name>"). Hierbei werden die registrierten Argumente
    der Reihe nach durchgezählt, das erste angegebene Argument entspricht dem ersten in der Liste usw. Alle weiteren
    übergebenen Argumente werden in einer zusätzlichen Liste gespeichert und können über GetAdditionalArgument() abgefragt
	werden.
  - Alle Optionen können nun einen logischen Namen bekommen, z.B. "Name" für "-n" oder "--name". Das macht das Abfragen
    der Optionen einfacher und erlaubt es auch, die Flags später zu verändern aber den logischen Namen dabei beizubehalten,
    wodurch man weniger im Code ändern muss. Bei Parametern wird dieser Logische Name auch in der Hilfe mit angezeigt
    (z.B. --name <name>).
  - Optionen können nun zusätzlich noch als "Required" definiert werden. In diesem Fall wird es als Fehler gewertet, wenn
    die jeweilige Option beim Starten des Programmes nicht angegeben wurde, weshalb dann das Programm nicht gestartet und
	statt dessen der Hilfetext ausgegeben wird.   
  - CommandLine::ShowHelp() an die Änderungen angepasst und erweitert. Alle Parameter werden geordnet angezeigt, unterteilt
    in Argumente und Optionen. Habe mich dabei an möglichst übliche Darstellungen gehalten, z.B. steht <arg> für ein
    benötigtes Argument, [arg] für ein optionales. Am Anfang wird eine kurze Zusammenfassung (Synopsis) ausgegeben, hierbei
    wird auch der Dateiname des Programmes mit ausgegeben.
PLCore:
- Application: An Änderungen von CommandLine angepasst.



>> 10.04.2009
[CO]
- "Loader::OpenFile()"-Implementation etwas geändert so das weniger "File::IsFile()" aufrufe gemacht werden
 (langsam da Datei zugriff)
- "RegEx" etwas optimiert: "m_lstGroups" ist nun ein "Array", dadurch kann man von der schnellen "Reset"-Methode
  profitieren
- "Base::SetVars()" arbeitet nun mit Regulären Ausdrücken statt mit dem Tokenizer... und ist laut meinen intensiven
  Benchmarks die ich momentan betreibe sogar deutlich flotter. ("246 ms" statt "356 ms" Ladezeit in einem Projekt
  mit größerer Szene :)
  "static RegEx ..." mag zwar nicht Thread-Safe sein, aber das ist PixelLight in seiner Gesammtheit derzeit ohnehin
  nicht und das Beschleunigt die Sache. (ohne "static" beim Projekt von oben "280 ms"... und hier kommts wirklich
  knadenlos auf jede Millisekunde an :/)



>> 08.04.2009
[CO]
- Da das RTTI so grundliegend ist und sehr intensiv genutzt wird machte ich ein paar vorsichtige Optimierungen um
  soviel Performance wie möglich rauszuholen. (muss leider sein :/) Die Änderungen hab ich einige male durchdacht
  und genau geprüft damit ich blos nix klaput mache... Stefan, bitte zur Sicherheit auch nochmal überfliegen.
- "ClassManager::RegisterClass()": Das langsame durchgehen der 'm_lstClasses'-Liste ob die Klasse schon
   Registriert ist kann man sich sparen, 'm_mapClasses'-Test reicht völlig... + der Listen-Test brachte in
   meinen Tests immer das gleiche Ergebniss (nicht in Liste)
- "Class::HasBaseClass()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen
- "Base::IsInstanceOf()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen



>> 05.04.2009
[CO]
- "Tokenizer::StreamIsString()" nach "BufferedReader::IsString()" verschoben, dadurch kann man ein internes
  'GetSubstring()' nur für String vergleichen vermeiden (... performance...)
- "Tokenizer::StreamRead()": "m_nPosition++" aus der Schleife gezogen und zu "m_nPosition += nCount" gemacht
- "Tokenizer": "EndOfLine"-Definition für "\n" hinzugefügt damit man statt 'm_sEndTag = "\n"' einfach
  "m_sEndTag = EndOfLine" schreiben kann was um einiges Effizienter ist da keine dynamische Speicherbehandlung :D
- "String": Das zuweisen von "char" oder "wchar_t", sprich einzelnen Zeichen optimiert so das wenn die Situation
  es zulässt man keine dynamische Speicherbehandlung braucht
- "String": "GetChar()", "GetWideChar()", "GetInt()", "GetLong()", "GetFloat()" und "GetDouble()" Implementation
  überarbeitet damit so effizient wie möglich (keine xxx Funktionsaufrufe etc.)
- "StringBufferUnicode" & "StringBufferUnicode" & "StringBufferUTF8": Entfernte die "GetString()"-Methode da im
  grunde nur ein Umweg (= balast) in einem String-System das 'sehr eng verdrahtet' ist



>> 27.03.2009
[CO]
- "Bitset": Neue Funktion: "GetNumOfSetBits()": Gibt die Anzahl der auf "true" gesetzten Bits zurück



>> 25.03.2009
[CO]
- "Loader::OpenFile()" muss es natürlich auch erlaubt sein Dateien beim Speichern neu zu erzeugen, hm, merkwürdig das dies
  bis jetzt noch nicht aufgefallen war...
- "Loader::OpenFile()" sollte natürlich auch ohne eingetragene "Basis Pfade" funktionieren, tat es aber bis jetzt nicht



>> 11.02.2009
[CO]
- Bitset: 'GetNumOfIntegers()' & 'GetIntegers()' hinzugefügt damit man an die interne Datenrepräsentation rankommt...
  was hin und wieder hilfreich sein kann...



>> 06.02.2009
[CO]
- 'DynLib': Neue Funktion 'GetAbsPath()' -> Gib den absoluten Pfad der geladenen Dynamischen Bibliothek zurück



>> 30.01.2009
[CO]
- 'Singleton': 'DestroyInstance()'-Funktion hinzugefügt mit der man manuell die Zerstörung der Singleton-Instanz
  'befehlen' kann. Da das Singleton normalerweise erst 'gaanz am Ende automatisch' zerstört wird kann es zu
  problemen kommen wenn man eine Anwendung schreibt die in eine andere Eingebettet ist... + so kann man nie die
  von VC angebotenen Speicherleck Tests nutzen da dann immer angemeckert wird es gäbe ein Speicherleck da die
  Singletons erst nach dem Test freigegeben werden. Auf dauer sollten wir versuchen soweit möglich komplett auf
  Singletons zu verzichten... (einfach weil man nicht wirklich Kontrolle über erzeugung und löschung hat :/)



>> 26.01.2009
[SB]
- ChunkLoaderPL: Fehler behoben, wodurch sich das Projekt unter Linux nicht mehr übersetzen ließ.
  Statische Member einer Klasse müssen *immer* in einer .cpp Datei definiert werden, da diese als
  Symbol exportiert werden. Nur im Header einfügen reicht nicht aus, da dann ein "undefined external
  symbol"-Fehler ausgelöst wird, wenn von ausserhalb der Projektes versucht wird, auf dieses Symbol
  zuzugreifen. Also bitte bei statischen Members immer eine Definition in einer .cpp Datei hinzufügen
  (einzige Ausnahme sind Templates, da der Compiler das hier automatisch macht), oder statt dessen enums
  verwenden.



>> 25.01.2009
[CO]
- 'GetHexValue()' aus einem von Stefans Projekten nach 'ParseTools::ParseHexValue()' verschoben da man das durchaus öfters mal brauchen kann



>> 22.01.2009
[CO]
- 'Chunk'-Klasse hinzugefügt die z.b. zum speichern von Keyframes genutzt werden kann



>> 14.01.2009
[SB]
- FileLinux: Die Klammerung war hier falsch, weshalb Verzeichnisse nicht mehr richtig erkannt wurden. Darum funktionierte PLProject nicht
  mehr richtig. Habe hier gleich die Fehlermeldungen ein wenig erweitert. Keine Ahnung, warum das noch nicht früher aufgefallen ist ...



>> 01.01.2009
[CO]
- 'Timing::CheckUpdate()': Hier kann man nun optional einen Parameter übergeben der im Falle eines FPS Limits zurückgibt wie lange man noch
  warten muss bis es Zeit für das nächste Update ist. So kann man direkt diesen Wert für 'Sleep' nutzen anstatt '1'.
- 'Timing::Update()': FPS Limit wird nun auch ausgeführt wenn gerade 'freezed' aktiv ist



>> 03.12.2008
[SB]
PLCore:
- Neue Config-Klasse für PLCore hinzugefügt und erst einmal nur die Einstellung "LoadLibsFromRuntime" aus PLEngine hierher verschoben.
  Ansonsten hat man das Problem, dass eine Applikation, die noch nicht von PLEngine abhängig ist, auch diese Option nicht kennt und daher
  nicht die Plugins im PL-Runtime sucht. Daher muss diese Einstellung so früh wie möglich kommen, damit ist das Problem erstmal behoben.
  Jetzt müssen wir möglichst schnell die ganze Config-Problematik nochmal sauber angehen, ansonsten haben wir bald ein echtes Problem ...
PLPlugin:
- BasicSceneApplet entfernt. Dies wäre eine totale Verkomplizierung, wenn man hier nochmal eine extra Ableitungshierarchie
  aufmacht. Und damit könnte dann immer noch nicht eine Applikation zwischen Plugin und Exe 'geteilt' werden.
- Statt dessen hat PluginPixelLight nun direkt einen Zeiger auf eine Applikation, die dann eingebettet wird. Dank der
  Änderungen am Application-Framework kann nun generell jede Applikation (ab GuiApplication) in fremde Fenster eingebettet
  werden, dies wird hier nun einfach verwendet. Es wird eine Application wie gewohnt instanziiert, dann wird aber nicht
  Run() aufgerufen, sondern die Applikation in das Plugin-Window eingebettet. Als Test habe ich die Teapot-Application
  verwendet, die Application kann aber jetzt ganz einfach ausgetauscht werden.



>> 03.12.2008
[CO]
PLCore:
- "64 Bit 'Bugfix': Core::GetRuntimeDirectory()" vom "25.08.2008" rückgängig gemacht da Windows das
  'normalerweise' Automatisch macht.
  Im 3ds Max Scene Exporter muss der alte Hack drinnen bleiben da man auf einem 64 Bit OS ein 32 Bit PL SDK
  Installieren kann... und dann ein 64 Bit 3ds Max nutzt, das sucht dann nach dem Registry Eintrag um automatisch
  feststellen zu können wo der PLSceneViewer liegt - und findet das dann natürlich nicht da es in einem
  "Magischen" 'Wow6432Node'-Unterordner abgelegt wurde. :D
PLPlugin:
- 64 Bit VC Projekt Einstellungen hinzugefügt
PLPluginMozilla:
- 64 Bit VC Projekt Einstellungen hinzugefügt



>> 29.11.2008
[CO]
- Var: 'GetFlagsFromString()' & 'GetStringFromFlags()' public gemacht da man diese Funktionalität auch von außen brauchen kann
- Da wir überall 'PL_VAR_FLAGS' als 'uint32' handhaben stellte ich die paar Stellen die 'int' nutzten hier auch auf 'uint32' um... macht nicht
  wirklich einen unterschied da beides 32 Bit, aber so ists konsequent. :D



>> 16.10.2008
[CO]
PLPlugin:
- Projekt ist wieder übersetzbar, aber noch nicht wirklich wieder lauffähig. 'PL::Init()' etc. gibts nun nicht mehr, habe erstmal
  BasicSceneApplet angelegt - eine Klasse von 'BasicSceneApplication' abgeleitet die als 'Applet' fungieren soll.



>> 29.09.2008
[SB]
PLCore:
- Application: Verwaltung von Kommandozeilen-Optionen durch eine Instanz von CommandLine hinzugefügt. Es werden ausserdem gleich
  einige Standardoptionen hinzugefügt: "--version" zeigt Programmname und Version an, "--help" zeigt alle zur Verfügung stehenden
  Optionen an. Das Verhalten dieser Kommandos kann wie üblich über virtuelle Funktionen überschrieben werden.
  Ich möchte es hier dem Programmierer so einfach wie möglich machen und ausserdem dafür sorgen, dass PL-Applikationen
  gleich so viel Komfort wie möglich bieten. Oftmals stößt man auf Programme, wo alles gut gemacht ist, aber dann fehlen solche
  Standarddinge wie "--version" oder Kommandozeilenoptionen überhaupt. Bei PL ist das nun gleich standardmäßig drin, es sei denn
  ein Programmierer baut dies bewusst wieder aus, was natürlich auch möglich sein sollte (CommandLine.Clear()). 



>> 28.09.2008
[SB]
- CmdLineParser durch die neu implementierten Klassen CommandLine und CommandLineOption ersetzt. Das Prinzip bleibt zwar
  das gleiche, die Schnittstelle von CommandLine entspricht jedoch mehr unserem üblichen PL-Style als dies bei CmdLineParser
  der Fall war. So können bspw. die einzelnen Optionen über die Methoden AddOption und AddFlag hinzugefügt werden, anstatt wie
  bisher alles in einen recht kryptischen String zu packen, der erst einmal geparsed werden musste. Optionen, die sowohl einen
  kurzen als auch einen langen Namen haben, gehören nun auch direkt zusammen. Zusätzlich wird noch eine Beschreibung zu jeder
  Option gespeichert, was dazu benutzt wird, um automatisch einen Hilfetext auszugeben, in dem alle vorhandenen Optionen
  aufgezählt werden. In Verbindung mit dem Application-Framework können damit nun sehr einfach Kommandozeilenoptionen
  verwaltet werden, was ingesamt einen sehr guten Eindruck machen sollte, wenn jede PL-Applikation solche Standardfunktionen
  schon bietet, ohne das der Programmierer sich groß darum kümmern muss. 
PLCore:
- Application: Der Executable-Dateiname und die Argumente werden jetzt nicht mehr im Constructor sondern bei Run übergeben.
  Alle Projekte wurden entsprechend angepasst. Da bei dieser Reihenfolge ChangeIntoAppDirectory() nicht mehr vernünftig von
  Aussen aufgerufen werden kann, habe ich dies nun erstmal in GuiApplication::OnInit() eingebaut. Dies sollte auf jeden Fall
  von der Application selbst entschieden werden, und nicht von Aussen aufgerufen werden.



>> 05.09.2008
[CO]
PLCore:
- Application: "GetName()" in "GetTitle()" umbenannt
- Application: "GetFilename()" in "GetExecutableFilename()" umbenannt
- Application: "OnHelp()" in "OnPrintHelp()" umbenannt
- Application: "OnVersion()" in "OnPrintVersion()" umbenannt
- Application: GetExitCode(), SetExitCode(), IsShutDown(), ShutDown(), OnShutDown() in PLGui::Application verschoben
- Application: Neue Funktion: GetStartupDirectory(), gib das aktuelle Verzeichniss zurück das beim aufruf des Applikation
  Verzeichnisses eingestellt war
- Application: 'OnInit()' in 'GuiApplication' verschoben
- Application: 'Title' muss nun über 'SetTitle()' gesetzt werden und kann nicht mehr direkt im Konstruktor übergeben werden



>> 25.08.2008
[CO]
PLCore:
- 64 Bit 'Bugfix': Core::GetRuntimeDirectory(): Macht ein 32 Bit Programm bei einem 64 Bit OS in der Registry herum, so landen dessen
  Einträge in einem 'Wow6432Node'-Unterordner. Also statt 'SOFTWARE\\PixelLight\\PixelLight-SDK' dann
  'SOFTWARE\\Wow6432Node\\PixelLight\\PixelLight-SDK' ... nicht das es zu einfach wird. *g*



>> 24.08.2008
[CO]
- System: GetPlatform() gibt wieder 'Win32' oder 'Win64' zurück statt 'Windows' da hier eine feinere Unterscheidung z.B. beim Plugins laden
  hilfreich ist. Unter Linux wird derzeit wie gehabt 'Linux' zurückgegeben, ob wir hier dann auch 32/64 Bit unterscheidungen brauchen müssen
  wir uns später mal genauer anschaun.



>> 23.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit
PLNetwork:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit
PLCore:
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit



>> 22.08.2008
[CO]
- Der 64 Bit Support von PLGeneral funktioniert nun. CMake Dateien schau ich mir als nächstes an + ein paar Dinge müsste man
  wohl umbenennen damit es 'Sauber' ist. 'SystemWin32' z.B. zu 'SystemWindows' da es für 'Win32' und 'Win64' nutzbar ist. :D



>> 21.08.2008
[CO]
- Fing an mich mit 64-Bit Support auseinander zu setzen. 'WIN64' wird zusätzlich als Precompiler Definition hinzugefügt.
  Bei zumindestens schonmal einer Stelle, und zwar in SystemWin32::GetCPUMhz() muss man nun mit 'WIN64' eine Fallunterscheidung machen.



>> 20.08.2008
[SB]
- HTMLParser wieder entfernt, da mir das alles nicht robust genug ist. Um Texte anzuzeigen, wird nun ein eigenes
  XML-Format verwendet, da muss man nicht die ganzen HTML-Probleme mit sich herumschleppen und das war auch relativ
  schnell und einfach implementiert. Für "echtes" HTML kann man dann evtl. später auf vernünftige Bibliotheken setzen.



>> 12.08.2008
[CO]
- Ich entschloss mich dazu die "SimpleList"-Implementation noch ein Stück radikaler zu machen... und hier auch keine virtuellen Funktionen
  einzusetzen so das nochmal 4 Byte für die Virtuelle-Tabelle wegfallen. Eine leere "SimpleList" Instanz ist nun also nur noch 4 Byte groß.
  "Iterable" und "Container" Funktionen sind wie gehabt da und lassen sich genauso nutzen, auch sind weiterhin Funktionen drinnen die
  Daten von "Container" übernehmen können - nur kann man "SimpleList" nicht mehr auf "Container" oder gar "Iterable" casten. Da Sinn
  und Zweck dieser Implementation jedoch ist "so Speichereffizient wie irgend möglich sein", kann man das denke ich rechtfertigen
  das diese Klasse etwas aus der "Container"-Reihe tanzt.
- Die internen Daten von "SimpleList" sind nun von außen Zugreifbar für maximale Optimierungs möglichkeiten. Das ist zwar sehr unschön
  und Riskant - aber diese Klasse sollte man eh nur nutzen wenn man genau weis was man will und warum. Die Vorteile überwiegen hier
  wie man in PLCore::Event sehen kann die Nachteile finde ich.
PLCore:
- Dadurch das "SimpleList" von PLGeneral nun keine Virtuelle-Tabelle mehr besitzt wurden Event und EventHandler Instanzen noch
  kompakter. Vorher:
    Event        = 12 Byte
    EventHandler = 20 Byte
  nun
    Event        = 8 Byte
    EventHandler = 12 Byte
  ... ich denke NOCH weiter runter mit dem Speicherverbrauch ohne coole Funktionalität einbüßen zu müssen können wir nicht mehr.
  Event ist nun dank "SimpleList" also nur noch halb so 'groß' wie vorher, EventHandler sogar nur noch ein drittel so groß. :D
- Entfernte 'm_nNumOfHandlers' im Event, dadurch ist ein Event nun nur noch 4 Byte groß - mal schaun ob man da noch irgendwo
  reduzieren kann... *g*
  Das entfernen wurde möglich da ich Zugriff auf die internen "SimpleList" Daten nun public machte - so kann man 'sehr Performant'
  über die Daten iterieren - genau das was man hier ssseeeeehr oft macht, und daher wäre das über einen Iterator gehen der intern
  Dynamsich erzeugt werden muss nicht zumutbar gewesen.



>> 11.08.2008
[CO]
- Bugfix: Directory::CreateRecursive(): Hier muss auf jedenfall noch 'GetRoot()' (zur Sicherheit fügte ich auch noch 'GetProtocol()' ein)
  beim Pfad vorne eingefügt werden - sonst kann es schnell zu Problemen kommen wenn ein absoluter Pfad übergeben wurde. Viel mir
  gerade im 3ds Max Scene Exporter auf als 'neben' den gewünschten Verzeichnissen auch noch 'sollten nicht da sein'-Verzeichnisse
  erzeugt wurden.



>> 10.08.2008
[CO]
- "SimpleList" angelegt. Da "List" einige Daten speichert um diverse Operationen zu beschleunigen, aber in ein paar Situationen
  man diese Operationen nicht braucht und lieber eine 'super Speicherschonende' Liste hätte gibts nun "SimpleList". Startpunkt
  war "List" das ich schrittweise Umformte:
  - 'm_nNumOfElements' raus
  - 'm_pLastElement' raus
  - 'ListElement::pPreviousElement' raus
  -> dadurch ist SimpleList 8 Byte wenn leer im gegensatz zu "List" 16 Byte leer.
PLCore:
- Event und EventHandler Klassen von "List" auf das neue "SimpleList" umgestellt. Vorher
    Event        = 16 Byte
    EventHandler = 36 Byte
  jetzt
    Event        = 8 Byte (+ 4, siehe unten)
    EventHandler = 20 Byte
  -> Änderte an ein paar Stellen die Verwendung der Liste damit möglichst keine 'ineffizienten' Operatoren genutzt werden.
  Spendierte Event 'm_nNumOfHandlers' das 'GetNumOfElements()' aufrufe bei SimpleList vermeitet - denn diese Operation ist nun
  langsam. Es lohnt denke ich hier aber 4 Byte für bessere Performance zu investieren, denn 'GetNumOfElements()' wäre sonst
  'sehr häuftig' aufgerufen worden. Event ist nun also 12 Byte, aber immer noch 4 Byte kleiner als vorher (davon können wir uns
  ein Eis kaufen gehen *g*)... und bei jedem EventHandler den man einhängt spart man nochmal durch die schlankere "SimpleList"
  Implemenation. Lohnt sich also denke ich.



>> 09.08.2008
[CO]
- "PLGeneralStat.vcproj": Gib seine Objekt-Dateien nun in ein eigenes Build-Verzeichniss aus. Ich hatte in letzter Zeit ständig
  Linker fehler beim übersetzen - jetzt weis ich auch warum. :D
- MODULE_LICENSE() hinzugefügt für die Angabe der Lizenz. Mir war es wichtig das diese Information allerdings auch direkt im Modul
  Abrufbar ist - z.B. damit man über ein Plugin-GUI dann das dort auch bequem sehen kann.
- In Funktionen wie z.B. "ModuleID<T>::SetModuleName()" war der 'Überlaufschutz' nicht korrekt Implementiert, so müsste das nun
  korrekt sein



>> 09.08.2008
[SB]
PLCore:
- Events: Mittels ConnectBind() können nun auch EventHandler an Events eines anderen Typs gebunden werden, wobei die
  Parameter analog zu bind() gebunden werden. Intern wird hier einfach ein EventHandler vom richtigen Typ erzeugt und
  mit dem Event verbunden. Damit dieser dynamisch erzeugte EventHandler auch wieder gelöscht wird, brauchte es leider
  eine Klasse mit virtuellem Destruktor, die in eine Liste beim EventHandler eingetragen wird. Dies wird aber nur dann
  benötigt, wenn wirklich mal ein Event 'umgebogen' wird, im Normalfall bleibt die Liste leer. Ich hoffe, dass dies so
  am besten ist und damit übereinstimmt, wie Events und Handlers größtenteils benutzt werden. Sollte sich herausstellen,
  dass man die meiste Zeit ConnectBind benutzt, sollte man sich vielleicht eine andere Lösung überlegen, die 'teurer' ist
  für den Normalfall, dafür aber 'billiger' für den Bind-Fall. Bitte beachten, dass die Functors und Events zur Zeit noch
  getestet werden, einiges ist noch nicht so stabil wie es sein soll (z.B. wenn man mal die falsche Anzahl Parameter übergibt).
  Das überarbeite ich gerade nochmal, die Funktionalität sollte aber so bleiben wie sie ist.



>> 08.08.2008
[CO]
- Loadable::Reload(): Funktionierte unter umständen nicht korrekt da direkt eine Referenz auf einen 'internen' String übergeben
  wurde der während des Ladevorgangs verändert werden kann - und schon klappte das Neuladen nicht mehr. (altbekanntes "Problem" :)



>> 06.08.2008
[CO]
PLCore:
- 'ShutDown()' und 'IsShutDown()' Methoden in die 'Application'-Klasse eingebaut. Dies ist identisch zu dem was in
  der alten 'PLEngine::PL'-Klasse ist und das wie ich finde schon immer sehr gut funktionierte. Fügte desweiteren
  eine virtuelle 'OnShutDown'-Methode hinzu die innerhalb 'ShuwDown()' aufgerufen wird.
- 'Application'-Klasse: "OnRun()" Implementationen geben im 'normalfall' "GetExitCode()" zurück, nur im Fehlerfall was
  eigenes wie z.B. "-1" - so kann ein User der nur die Application Klassen nutzt über "SetExitCode()" einen Error Code
  setzen der zurückgegeben werden soll



>> 03.08.2008
[CO]
PLCore:
- 'Application'-Klasse um 'Name' erweitert, dies ist recht nützlich da man dann z.B. direkt anhand dieses Namens z.B.
  den Standard-Titel eines Fensters setzen kann.
- 'Base'-Verzeichniss mit alter Event und Functor Implementation gelöscht



>> 02.08.2008
[SB]
PLCore:
- Bind-Funktionalität für Funktoren hinzugefügt. Damit ist es möglich, Parameter eines Funktors zu binden, also
  auf einen festen Wert zu setzen und damit die Signatur einer Funktion zu verändern. Diese Implementation erlaubt
  es auch, Eingabeparameter und gebundene Werte frei festzulegen und damit die Reihenfolge, Anzahl und Art
  der Parameter des neu erzeugten Funktors fast beliebig bestimmen zu können. Ergebnis der Bind-Funktion ist
  ein Funktor, dessen Signatur durch die verwendeten Parameter komplett festgelegt ist und der daher selbst
  wieder typensicher ist.

  Anwendung:
    Beispielsweise kann man auf diese Weise einen weiteren Parameter hinzufügen, um z.B. bei Events noch
    einen Zeiger auf das Objekt mitzuliefern, das dieses Event erzeugte (z.B. Window* oder SceneNode*).
    Durch die Verwendung von bind wird ein Funktor erzeugt, der wieder kompatibel zum Event des jeweiligen Objektes
    ist.

  Verwendung:
    bind(f, t0, t1, ...)
    - f: Eingabe-Funktor, der letztlich mit geänderten Parametern aufgerufen wird
    - t0: Wert für Parameter 0
    - t1: Wert für Parameter 1
	- etc.

    Anstelle von echten Werten für Parameter können Platzhalter verwendet werden, um die Parameter
    des erzeugten Funktors durchzureichen:
	- _0: Platzhalter für Parameter 0
	- _1: Platzhalter für Parameter 1
	- etc.

  Beispiele:
	// Define a test functor of type void(int, float)
	Functor<void, int, float> f(Function);

	// Call directly
	f(1234, 0.25f);

	// Bind first parameter -> getting functor of type void(float)
	bind(f, 1234, _0)(0.25f);

	// Bind second parameter -> getting functor of type void(int)
	bind(f, _0, 0.25f)(1234);

	// Bind both parameters -> getting functor of type void()
	bind(f, 1234, 0.25f)();

	// Exchange parameters -> getting functor of type void(float, int)
	bind(f, _1, _0)(0.25f, 1234);

	// Just to show the resulting functor's type
	Functor<void, float> f2 = bind(f, 100, _0);
	f2(0.1f);



>> 29.07.2008
[SB]
PLCore:
- FunctorTools hinzugefügt und Funktionen erstellt, um einen Funktor zu erzeugen. Das dient vor allem der
  Übersichtlichkeit, damit man nicht ständig die ganzen Template-Parameter schreiben muss, gerade wenn man
  später mit bind etc. die Funktoren noch ineinander schachteln muss. Ich habe mich dabei an die üblichen
  Benennungen gehalten, die man in den meisten anderen Signal/Slot Implementationen findet: ptr_fun()
  erzeugt einen Funktor für eine statische Funktion, mem_fun() erzeugt einen Funktor für eine Memberfunktion.
- 'Types' in 'Traits' umbenannt, was eine übliche Bezeichnung für solche Typendefinitions-Klassen ist. Die Klasse
  heisst nun FunctorTraits und wurde ausserdem in eine eigene Headerdatei ausgelagert, die allerdings "Traits.h" heißt.
  Zusätzlich wurde auch noch Functor selbst in die Klasse aufgenommen, damit man alle benötigten Datentypen dort beisammen hat.
- Analog zum Functor auch bei den Events Types in Traits umbenannt.
- Weitere Klassen umbenannt:
    FuncImpl   -> FunctorImpl (Dateiname ist trotzdem "Impl.h" und nicht "FunctorImpl.h", damit alle Impl's beisammen stehen)
    FuncTyped  -> ImplTyped
    FuncPtr    -> ImplFunPtr
    FuncMemPtr -> ImplMemPtr
  sowie
    FunctorTools -> Tools



>> 28.07.2008
[SB]
PLCore:
- Functor und Events nochmal überarbeitet und übersichtlicher gestaltet (mehrere Dateien).
- Beide Klassen sind nun erstmal so einfach wie möglich gestaltet, dass heißt möglichst wenig Ableitungen und
  dadurch auch weniger virtuelle Destruktoren. Mal schauen, ob es für das neue RTTI notwendig ist, diese Klassen doch
  noch einmal aufzubohren (und dadurch evtl. doch wieder einiges virtuell machen zu müssen), ich fände es aber schön,
  wenn die Klassen so bleiben könnten, wie sie jetzt sind.
- ManagedEventHandler entfernt, da mir das nie wirklich gefallen hat (leicht unsicher, falls das falsch benutzt worden wäre).
  EventHandler sollten lieber als direktes Attribut einer Klasse instanziiert werden statt über new, und falls es doch
  jemand dynamisch braucht, muss er eben selber dafür sorgen, dass die erzeugten Objekte auch wieder gelöscht werden.
- Sowohl Functor als auch EventHandler haben nun wieder einen Default Konstruktor. Es ist zwar schön, wenn es keine Probleme
  gab ohne Default-Konstruktor, jedoch nimmt uns das die Möglichkeit, Funktoren oder EventHandler beispielsweise in einer
  Liste zu speichern oder in anderen Situationen, wo es notwendig ist, zunächst einmal das Objekt über den Default-Konstruktor
  zu initialisieren und den wirklichen Wert erst später zuzuweisen. Da beide Klassen so gestaltet sind, dass es problemlos
  möglich ist, zunächst einmal ein leeres Objekt zu erzeugen und erst später einen Zeiger auf eine wirkliche Funktion zu setzen,
  sollten wir uns diese Möglichkeit nicht unnötig verbauen. Abgesehen davon hat das Entfernen des Default-Konstruktors
  von EventHandler das Problem nicht wirklich gelöst, weil das eigentliche Problem im Functor lag und nicht im EventHandler,
  ein leerer Functor hätte daher immernoch zum Crash geführt. Das wurde nun behoben, da ein leerer Functor jetzt eine Null-Funktion
  aufruft, anstatt wie bisher einfach abzustürzen :-)
- Ein EventHandler kann nun auch auf mehrere Events hören, womit es größtenteils wirklich unnötig sein sollte, EventHandler dynamisch
  zu erzeugen. Christian: Bitte nochmal genau meine Implementation durchschauen, da bei so etwas leicht Fehler passieren (NxM Beziehung,
  beide Objekte müssen sich im Destruktor aus der Liste des jeweils anderen Objektes austragen, das wird leicht ganz schön kniffelig).



>> 23.07.2008
[CO]
- Neue System-Funktion: 'GetUserHomeDir()' liefert das 'Home Directory' des aktuellen Benutzers zurück - dort kann/sollte
  man dann immer Dinge wie Konfigurationen, Screenshots etc. speichern so das dort wo das eigentliche Programm gespeichert
  ist NICHTS dynamisches gespeichert wird. Das ist unter Unix scheinbar so gängig + unter Vista wird da wie es aussieht
  auch Wert drauf gelegt... jedenfalls muss man dort dann erst Verzeichnissattibute ändern bevor Logs etc. im Programm
  Verzeichniss geschrieben werden können...
  -> PLGeneral ist dadurch nun auch von 'Userenv.lib' Abhängig, das sollte aber kein Problem sein. Man hätte sicherlich
     auch irgendwie in der Registry herumfummeln können, was aber nicht ganz so prall sein soll - dann lieber gleich
     Funktionen die das OS dafür bereitstellt nutzen. :D
  -> Linux Implementation 'müsste so passen', aber da ich es nicht testen konnte ist es Auskommentiert.



>> 21.07.2008
[SB]
- HTMLParser implementiert. Diese Klasse liest eine HTML-Datei ein und erzeugt daraus ein XML-Dokument. Besonders robust ist
  der Parser sicherlich nicht, allerdings habe ich versucht, viele typische Fehler in HTML-Dateien (z.B. falsch geschlossene Tags
  oder gemischter HTML und XML-Syntax) zu berücksichtigen, so dass die Datei dennoch eingelesen werden kann. Die Klasse ist
  aber ein reiner Parser und beinhaltet keinerlei HTML-Semantik (was heißt, dass semantische Regeln, wie z.B. <li> kann nur in
  Listen vorkommen oder <tr> nur in Tabellen, nicht überprüft werden können). 



>> 18.07.2008
[CO]
- ClassManager::LoadPlugin(): Um Format Versions Informationen erweitert ('plugin'-Dateien)



>> 10.07.2008
[CO]
- ConfigLoaderPL & LocalizationLoaderPL: Um Format Versions Informationen erweitert



>> 09.07.2008
[CO]
- LoadableManagerLoaderPL: Um Format Versions Informationen erweitert. So wird es Zukünftig dann in all unseren XML Formaten gehandhabt.
- Loader: Ein paar 'Standard Strings' hinzugefügt



>> 08.07.2008
[SB]
- Statische Version von PLGeneral hinzugefügt. Ich denke, PLGeneral und evtl. später noch PLGui sollten erstmal als statische
  Bibliotheken ausreichen, damit man kleine Tools auch ohne Abhängigkeit von der PixelLight-Runtime schreiben kann (gerade
  auch wichtig für unsere internen Tools).



>> 04.07.2008
[CO]
PLCore:
- EventHandler: Standard Konstruktor entfernt da es ansonnsten einen Crash gibt wenn man einen nicht Initialisierten
  EventHandler nutzt - eine Situation die es auf jedenfall zu vermeiden gilt. Habe bei mir diesen Konstruktor schon seit
  Wochen auskommentiert und es gab keine Probleme.



>> 29.06.2008
[SB]
PLPluginMozilla:
- PLPluginMozilla implementiert.
- Anbindung an unsere abstrakte Plugin-Klasse vorgenommen und PixelLight-Plugin erfolgreich im
  Mozilla ausgeführt.



>> 28.06.2008
[SB]
PLPlugin:
- Projekt gestartet. PLPlugin stellt eine Schnittstelle zur Verfügung, um PixelLight als Plugin in andere
  Umgebungen/Applikationen einzubinden. Also PixelLight als Plugin für z.B. Browser, nicht Plugins für PixelLight :-)
  Dazu wird eine abstrakte Plugin-Klasse bereitgestellt, die von konkreten Wrappern für verschiedene Plugin-Schnittstellen
  angesprochen wird. Von dieser Plugin-Klasse werden dann konkrete Plugins abgeleitet, z.B. das standard PixelLight-Plugin,
  das wir letztlich im Browser oder sonstwo sehen wollen.
- Basisklasse Plugin implementiert, die das abstrakte Plugin-Interface darstellt.
- Basisklasse PluginImpl implementiert, die nach dem Backend-Prinzip das Interface
  für konkrete Backends bereitstellt.
- PluginOpenGL als Testplugin implementiert, in dem eine minimale OpenGL Szene angezeigt wird.
- PluginPixelLight erstellt für das standard PixelLight-Plugin. 
- Das Triangle-Sample genommen und als vorläufiges PixelLight-Plugin implementiert :-)
PLPluginActiveX:
- PLPluginActiveX implementiert. Diese konkrete Implementation von PluginImpl
  stellt das ActiveX Backend für unsere eigene Plugin-Klasse dar.
- Den Wrapper auf die Verwendung unseres abstrakten Plugin-Interfaces umgestellt.
- Den OpenGL-Test hier entfernt und dafür als PluginOpenGL in PLPlugin implementiert.
- Das PixelLight-Plugin läuft nun zum ersten Mal korrekt im Browserfenster :-)



>> 24.06.2008
[SB]
PLPluginActiveX:
- Projekt gestartet. PLPluginActiveX ist ein Container und Wrapper für ActiveX, über den das PLPlugin-Interface unter
  ActiveX verwendet werden kann.
- ActiveX control erstellt und an unsere Projektstruktur angepasst. Einstellungen
  gefunden, die zur Einbindung von OpenGL erforderlich sind.
- Kleines OpenGL Testplugin implementiert.



>> 22.06.2008
[CO]
- System Klasse um 'GetCurrentThread()' erweitert - das nutzen wir in verschiedenen Vorlesungen des öfteren mal und kann ganz hilfreich sein.
  Rauszufinden wie man diese Funktion intern realisieren kann war allerdings etwas - knifflig. Leider scheint es weder bei Windows
  noch bei Linux möglich zu sein an die Funktions Parameter zu kommen die man einem Thread beim erzeugen gegeben hat. Daher muss man
  das leider etwas umständlicher anpacken um an die PixelLight Thread Instanz des aktuellen Threads zu kommen:
  - Unter Windows lässt sich das mit 'Thread Local Storage' (TLS) realsieren, bis auf die unschöne Globale Variable ganz ok würd ich sagen
  - Unter Linux kann man dafür denke ich 'pthread_getspecific()' nutzen (fand das zuerst, und schaute dann obs unter Windows etwas
    ähnliches gibt :)
  Ich habe das direkt mal in 'PLPhysics::WorldThread' ausprobiert, klappt ganz wunderbar. :D
  Sobald die Linux Variante Implementiert ist würde ich gerne 'System::Sleep()' wieder nach 'Thread::Sleep()' verschieben da es für mich
  einfach dorthin gehört und man es in 'neuen Sprachen' wie Java oder C# ebenfalls in der Thread Klasse findet was ich sehr nett finde. Zwar
  ist 'System::GetInstance()->Sleep(100)' 'kompakter' zu schreiben als 'System::GetInstance()->GetCurrentThread()->Sleep(100)', aber irgendwie
  ist das einfach eine Thread Verwaltungs Funktion die für mich nix in der 'allgemeinen System'-Klasse zu suchen hat, auch wenn man diese auf
  dem aktuell laufenden Thread ausführt. Bei Zeiten würde ich dann auch noch gerne eine 'Thread::Yield()'-Funktion hinzufügen damit wir die
  meisten gängigen Thread Funktionen haben.
- Threads können nun auch einen von Menschen lesbaren Namen haben, gerade beim Debugging oder Thread Experimenten ist das sehr hilfreich
- Neue System Funktion: 'Yield()' -> veranlasst im Normallfall den aktuellen Thread den Prozessor aus der Hand zu geben, ebenfalls eine gängige
  Funktion. Habe das erstmal in die System Klasse eingebaut da dort auch die 'Sleep()'-Funktion ist. Hier müssten wir uns wie gesagt nochmals
  überlegen ob wir das wirklich in der System Klasse lassen wollen oder nicht lieber in die Thread Klasse schieben damit die Thread Dinge
  beisammen sind... auch wenn diese Funktionen auf den 'aktuell laufenden Thread' arbeiten und nicht auf die Thread Instanz was ein klein wenig
  verwirrt, aber das ist auch bei Java und C# so. (im aktuellen Semester habe ich wie gesagt sehr viele Vorlesungen die sich mit Threads in
  verschiedensten Sprachen befassen :) Wir müssen uns das nicht sofort nochmal anguckn ob wir das in der System Klasse haben wollen oder das so
  machen wie es mittlerweile viele API's handhaben und das den "Umstieg auf PixelLight" etwas einfacher machen könnte. :)



>> 21.06.2008
[SB]
PLCore:
- Neue Klasse Core hinzugefügt, die statische Funktionen bereitstellt, um Informationen über die gesamte
  PixelLight-Installation abzufragen (z.B. Installationspfad, Versionsnummer etc.). GetRuntimeDirectory
  wurde von PLEngine hierher verschoben, und überall, wo der Installationspfad abgefragt wurde, wird nun
  diese Funktion verwendet (sowas sollte wenn möglich immer zentral an einer Stelle sein und nich dupliziert
  werden).
- Die Informationen über das aktuelle SDK werden nun aus der Datei PixelLight.h genommen, die im Verzeichnis
  /PixelLight zu finden ist (siehe PLSDK)



>> 01.06.2008
[SB]
- RTTI: Es war immer noch ein Fehler beim Registrieren von Klassen vorhanden. Wenn die Liste der auf ihre Basisklassen
  wartenden Klassen durchgegangen wird, muß die Suche neugestartet werden, damit alle abgeleiteten Klassen auch initialisiert
  werden können. Hier war ein saublöder fehler drin, wodurch die Klassen meistens nicht initialisiert wurden.
  Aus irgend einem Grund ist die Reihenfolge der Initialisierungen unter VC anscheinend ziemlich optimal, so dass dieser
  Fehler da nicht wirklich aufgefallen ist - solange die Klassen in der richtigen Reihenfolge initialisiert werden
  (z.B. erst SceneNode, dann SceneContainer, dann SCPhysics) funktioniert ja alles korrekt. Beim Übersetzen mittels
  CMake ist die Reihenfolge, in der compiliert und gelinkt wird, jedoch eine andere, deswegen fiel der Bug hier ins Gewicht
  und beim Ausführen konnten Klassen nicht gefunden werden, da diese nicht richtig am RTTI angemeldet wurden.
  Ich habe jetzt keine Probleme mehr feststellen können, auch wenn ich mit CMake das Übersetzen starte, funktionieren hinterher
  alle Samples korrekt und das dubiose Problem, dass z.B. "SceneNode" nicht gefunden wird, ist nicht mehr vorhanden. Ich hoffe
  mal, dass dies auch meine Probleme unter Linux löst (dort wurden die Loader nicht gefunden, dürfte ziemlich sicher das
  gleiche Problem gewesen sein). 
- RTTI: Da es sehr blöd ist, das RTTI zu debuggen, wenn es aus irgend einem Grund nicht richtig funktioniert, und man hier
  auch nicht einfach ins Log schreiben kann, da dies ebenfalls schon ein funktionierendes RTTI voraussetzt, habe ich ein neues
  Makro eingebaut, um das RTTI zu debuggen. Normaler Weise ist das deaktiviert, wenn man es aber aktiviert, werden RTTI-Aktivitäten
  mit einfachen stdio-Methoden in einer festgelegten Datei (C:\rtti.txt) geloggt. Das dürfte es etwas vereinfachen, Problemen
  mit dem RTTI auf die Schliche zu kommen.



>> 22.05.2008
[CO]
- 'Informer' und 'Listener' Templates entfernt da wir zukünftig wie von Stefan vorgeschlagen auf das 'Event'-Konzept setzen das ich mittlerweile
  auch sehr nett finde. Diese zwei Templates wurden nur von 'SceneNode' und 'SceneQuery' innerhalb von 'PLEngine' verwendet, hier werden nun
  'Events' genutzt.



>> 16.05.2008
[CO]
- Wie besprochen liegen System Konsolen Funktionen nun in einer eigenen Klasse die man über 'System::GerInstance().GetConsole()' bekommt
- XML-Klassen: Interessant. Mir viel gerade als ich Stefans Änderungen durchschaute zum ersten mal das 'XmlDocument::SetTabSize()' beim speichern
  überhaupt keine Auswirkung hat da intern immer direkt "    " geschrieben wird. Als ich in den TinyXML Codes nachschaute sah ich das die
  das ebenfalls vergessen haben... oder es warum auch immer gewollt ist. Bei uns ist das jedenfalls nicht gewollt da ich keinen Grund finden
  kann warum die 'XmlDocument::SetTabSize()'-Einstellung ignoriert werden sollte. Darum ging ich die Funktionen die speichern nochmal durch
  und korrigierte das + nutzte '' anstatt "" wo nur ein Zeichen genutzt wird. (die String Klasse kann damit etwas Effizienter arbeiten :)
- XmlNode::GetDocument(): Auch hier war noch ein fieser Bug drinnen. Wow, Respekt, dieses Kerlchen hat sich aber ziemlich lange tapfer im
  Code halten können. *g*



>> 17.04.2008
[CO]
- SystemWin32::GetCurrentDir(): Gab das Verzeichniss 'Native' zurück. Da in der Dokumentation nix steht und in Programmen normalerweise
  wenn immer möglich nicht mit 'Native' gearbeitet werden sollte änderte ich das. Dies merkte ich durch 'LoadableType::GetRelativeFilePath()'
  das nicht mehr korrekt ging da alle Basis-Pfade im LoadableManager ein Protokoll vorne haben, aber das von 'System::GetCurrentDir()'
  keines hatte was hier nicht wirklich hilfreich ist. :D
- 'LoadableType::GetRelativeFilePath()': Da 'SystemWin32::GetCurrentDir() & CO' am Ende keinen Slash haben musste hier nun an einer Stelle
  '+1' eingefügt werden. Nun arbeitet diese Funktion wieder korrekt.



>> 05.04.2008
[SB]
- PLMain so umgeändert, dass man nun immer den Dateinamen und die Parameter übergeben bekommt. Das wird so auch
  an die Application-Klasse weitergegeben, so ist das einheitlich und man braucht sich nicht mehr zu fragen, ob
  Parameter[0] jetzt der Dateiname ist oder der erste Parameter. Damit dies unter allen System vernünftig funktioniert,
  waren noch ein paar Anpassungen nötig. Man könnte nun überlegen, die Funktion GetProgramName() aus System herauszunehmen,
  damit man das nicht doppelt hat. Natürlich könnte man das dann nur noch nutzen, wenn man auch die Application-Klasse
  nutzt (was man allerdings tun sollte, da es nur Vorteile bringt).
PLCore:
- Mit der Arbeit am Application-Framework begonnen. Die Klasse Application ist die Basisklasse und wrappt
  die Hauptfunktion des Programmes. Alles weitere wird durch Spezialisierungen in anderen Projekten (z.B. PLGui)
  hinzugefügt.



>> 05.04.2008
[CO]
- ThreadLinux: Speichert intern das vom Benutzer gesetzte 'PriorityClass' und 'Priority' damit sich das rein von den Rückgabewerten
  her wie unter Windows verhält. Linux selbst hat eine Funktion Namens 'pthread_setschedparam' zum setzen der Thread Priorität - allerdings
  ist 'SCHED_OTHER' als Default-Strategie gesetzt und in dem Fall sind keine Thread Prioritäten zulässig da dies komplett der Kernel
  übernimmt. Damit hat sich das mit den Thread Prioritäten unter Linux also erledigt.



>> 05.03.2008
[SB]
- Mußte die Verwendung des Null-Objektes noch etwas verändern: In (Standard-)C++ ist es nicht erlaubt, statische Member
  über Objekte anzusprechen. So etwas wie m_lstObjects->Null geht also nicht, es muß List<Object>::Null heißen. Leider
  scheint Visual C++ immer noch nicht standardkonform zu sein, da es hier keinerlei Fehler oder Warnungen gab. Für den
  gcc dagegen ist m_lstObjects->Null ganz einfach unbekannt. Habe alles angepaßt und hoffe, dass es nun so unter beiden
  Compilern funktioniert.



>> 05.03.2008
[CO]
- Wie besprochen geben nun die Container Referenzen statt Zeiger zurück... die Klassen waren schnell verändert, das hatte
  ich gestern bereits fertig -  alle Projekte entsprechend anzupassen war allerdings 'etwas' mehr Aufwand der sich allerdings
  definitiv gelohnt hat. Stellen wo Zeiger genutzt werden müssten unproblematisch sein da soetwas wie 'if (!...)' oder nur
  'if (...)' weiterhin klappt. Sollte allerdings in den Containern ohne Zeiger gespeichert sein, so können diese Abfragen
  teils immer noch übersetzt werden - aber das was abgefragt wird ist dann nicht mehr ob das zurück bekommene Element gültig
  ist, sondern dann wird direkt der Wert dieses Elements getestet. Bei soetwas wie 'int' gespeichert meckert das dann natürlich
  der Compiler nicht an - das kann ganz böse nach hinten losgehen. Eine solche Stelle fand ich bereits, aber um 'alle' zu finden
  müssen wir überall wo Container genutzt werden ohne Zeiger nochmal suchen und durchschauen. :/
  Bin schon schwer gespannt was ich so alles übersehen habe... entweder findet es Stefan oder die Zeit. *g*



>> 03.03.2008
[SB]
- Neuer PLGeneral-Datentyp 'handle'. Es ist irgendwie blöd, ständig auf uint32 casten zu müssen oder gleich
  void-Pointer zu übergeben, wenn es um System-Handles geht. Meistens sind diese auf einem System immer vom
  gleichen Datentyp, bei Windows wird HANDLE (DWORD) verwendet, bei Linux ist es meistens int. Daher definiere
  ich das nun in einem PLGeneral-Datentyp 'handle', der für alle Systemhandles verwendet werden soll. Ebenfalls
  wird auch INVALID_HANDLE je nach System für ungültige Handles definiert. Dieser Datentyp sollte nicht häufig
  Verwendung finden, aber manchmal braucht man eben auch die Möglichkeit, über unsere Datentypen wieder an
  System-Handles heranzukommen. Das können wir nun über diesen Datentyp machen, anstatt das völlig undefiniert
  zu lassen oder für verschiedene Situationen unterschiedliche Datentypen zu definieren (wie früher MODULE_HANDLE).
- FileStdStream erweitert: Es kann nun entweder ein beliebiger Stream-Pointer übergeben werden (FILE*),
  oder ein File-Handle des jeweiligen Systems (int unter Linux, HANDLE unter Windows). Falls ein File-Handle
  übergeben wird, muß hinterher die Datei noch geöffnet werden, wobei die bekannten Flags (Read/Write/Text/etc.)
  verwendet werden können. Im Falle eines FILE*-Pointers müssen die Access-Flags, die verwendet wurden um die Datei
  zu öffnen, mit übergeben werden. Somit ist es möglich, eine beliebige bereits geöffnete oder sonstwie zurückgegebene
  Datei trotzdem über unseren File-Wrapper anzusprechen. Die Standard-Streams (in/out/err) sind da nur ein Beispiel,
  es können jetzt aber auch beliebige andere Dateien oder Pipes so verwendet werden.
- Statt void* wird nun FILE* übergeben, da dieser Datentyp feststeht und sich auch nicht je nach System unterscheidet.

  Da dadurch jetzt leider schon in File <stdio.h> benötigt wird, habe ich die FILE-Vordefinition in eine eigene
  Headerdatei ausgelagert, wo nach Windows und Linux unterschieden wird. Damit wird <stdio.h> wirklich nur da
  eingebunden, wo es unbedingt nötig ist, ohne die Includes überall mit #ifdef's zu verunstalten :-)
- File: Konstruktoren zum Öffnen schon vorhanderer Streams/FileHandles via FileStdStream eingebaut bzw.
  öffentlich gemacht.
- File: IsOpen() hinzugefügt
- Überall Writeable durch Writable ersetzt. Es scheint zwar beides richtig zu sein, aber writable ist mir irgendwie
  geläufiger - und in meinem Dictionary ist diese Variante fettgedruckt :-)
- Neue Klasse Pipe eingebaut, über die System-Pipes (named und unnamed) erstellt und angesprochen werden können.
- Neue Klasse Process eingebaut, die benutzt werden kann, um externe Prozesse zu starten. Dabei kann die
  Ein- und Ausgabe umgeleitet werden und hinterher über unsere File-Klasse ausgelesen/geschrieben werden. Das ist
  eine Funktionalität, die man immer mal wieder braucht, und die mit OS-Funktionen ein absoluter Krampf ist. Darum
  möchte ich gerne PLGeneral soweit vollständig haben, dass man alles sowas schön einfach und komfortabel damit machen
  kann :-)



>> 02.03.2008
[CO]
- Änderte in den Container-Klassen 'AType' zu 'ValueType' damit das hier überall gleich geschrieben ist und somit
  Doxygen bei z.B. dem Iterator eine 'komplette' Klassenhierarchie zeigt und nicht nur die 'Container' Klassen
- Bugfix: Directory::CreateRecursive(): Trotz meiner bei der Implementation merkwürdigerweise erfolgreichen Tests
  (eventuell nicht sonderliche pralle Test Situation erzeugt :) war die Implementation noch nicht ganz ok... Stefan
  hatte ja schon die korrekte Funktionsweise angezweifelt, so 'müsste' es nun aber klappen.



>> 29.02.2008
[CO]
- "ConstIterator" hinzugefügt, bin mir allerdings nicht sicher ob das den 'Todo'-Punkt
  "Const_Iterator (currently we can't return some lists)" korrekt behandelt. Hoffentlich geht das so halbwechs,
  währe heftig wenn wir nochmal komplette Iterator Implementationen für 'const' schreiben müssten. :/
  Wenn das passt, wäre es sicherlich ne gute Idee bei 'Iterable::GetIterator()' und 'Iterable::GetEndIterator()'
  das 'const' hinten heraus zunehmen + die möglichkeit einen Iterator einem ConstIterator zuzuweisen.
  (anderst herum natürlich nicht *g*)



>> 28.02.2008
[CO]
Alle Projekte:
- Nahm wie besprochen überall dort wo 'inline' genutzt wird die Export Makros heraus. (siehe Eintrag 24.02.2008
  von Stefan) Damit man an diesen Stellen sehen kann das es absicht ist das hier kein Export Makro ist habe ich
  dort dann jeweils 'inline' reingeschrieben. (ist also nix 'funktionales', sondern als Hilfe/Gedächtnissstütze
  gedacht)
PLGeneral:
- 'SubString' und 'Sub-String' in 'Substring' umbenannt da man diese Schreibweise heute am häufigsten antrifft
- String::String(const utf8 *pnValue) muss natürlich raus da der Compiler hier nicht zwischen den zwei entsprechenden
  Konstruktoren unterscheiden kann (dank Default Einstellungen sieht das dann für ihn gleich aus :)
- String: "String operator +(utf8 nValue) const;" macht natürlich nicht wirklich viel Sinn da dies eigentlich immer
  ein 'Array von utf8' ist, nahm es heraus. Das gleiche bei "String::operator +=(utf8 nValue)" und
  "friend String operator +(utf8 nValue, const String &sString)" und "GetUTF8Char()" und "Replace(utf8 nOld, utf8 nNew)".
  "SetCharacter()" mit UTF8 braucht natürlich einen Zeiger.
- Bugfix: "String(const utf8 *pszString, bool bCopy, uint32 nLength, uint32 nNumOfBytes)": "UTF8Tools::GetNumOfCharacters()"
  sollte man natürlich auch die Anzahl der Bytes mitgeben...
- "Functions.cpp": "HashFunction::Hash(const String &sKey)": Hier sollten Fallunterscheidungen für die verschiedenen
  Formate gemacht werden... das könnte allerdings schnell zu problemen führen wenn man Formate mischt und sich dann
  wundert wieso man 'bei doch eigentlich scheinbar gleichem String' unterschiedliche Schlüssel bekommt. Das sollte
  man sich also dann eventuell nochmal genauer anschaun.
- RegEx: 'Mode' zu etwas universelleren Flags gemacht in denen 'Match' und 'Encoding' gespeichert wird, so braucht
  man für 'Encoding' keine weiteren Parameter. Setzt man kein spezielles 'Encoding'-Flag, so wird das interne
  String Format (ASCII oder UTF8) des übergebenen Ausdrucks verwendet. 'Subject' bei 'Match()' wird in dieses
  interne RegEx Format 'gezwängt'. 'Meistens' macht man sich über 'Encoding' keine Gedanken und nutzt nur ASCII,
  in dem Fall kann man das auch hier wie gehabt als Benutzer ignorieren. :D
  UTF8 Support in RegEx Implementation eingebaut, allerdings funktioniert das noch nicht richtig da u.a.
  "UTF8Tools::Unescape()" noch Probleme mit soetwas wie "\\s*(\\w+)\\s*" hat was es dann zu z.B. "s*(w+)s*" umformt +
  einige entsprechenden Funktionen in der String-Klasse noch nicht richtig Implementiert sind. Aber der Anfang wäre
  gemacht, taste wir uns also mal voran bis das alles korrekt auch mit UTF8 läuft...



>> 27.02.2008
[SB]
- Linux-Implementationen der Konsolen- und Memoryfunktionen getestet und wo nötig angepasst. Die Datei /proc/meminfo
  sieht bei mir völlig anders aus als offenbar in dem Beispiel, da sollte man sich also offenbar nicht drauf verlassen,
  dass der x-te Wert das und das bedeutet. Deswegen Parse ich nun nach den entsprechenden Strings. Worauf ich mich allerdings
  verlasse ist, dass der Wert immer in Kilobyte angegeben ist - hoffe, das ist auch so, ansonsten müsste man auch noch nach
  "kB|MB|B" parsen.
- System::ConsolePrint hinzugefügt, damit alle Konsolenfunktionen beisammen sind und man nicht nur, um eine kleine
  Konsolenausgabe tätigen zu können, auch noch File einbinden muss. So wird die Funktion auch gefunden, ansonsten würde
  man sich wohl wundern, dass zwar alle möglichen Konsolenfunktionen in System zu finden sind, nur ein simples Print fehlt.



>> 27.02.2008
[CO]
- Bugfix: "XmlBase::XmlBase(void *pData)", "((XmlBase*)m_pData)"... autsch, das sollte natürlich
  "((TiXmlBase*)m_pData)" heißen, muss irgendwann einmal durcheinander gekommen sein... gab natürlich ein
  Speicherleck + ein Test wie 'GetFirstChild() == GetLastChild()' um zu sehen obs nur ein Kind gibt ging natürlich
  nicht da jedesmal ein anderer PL XML Knoten zurückgegeben wurde.
- Iteratoren: Überarbeitete die Implementation nochmal so das Iteratoren beliebig 'kopiert' werden können. Intern
  wird ähnlich wie bei bei den Strings gearbeitet - Implementationen werden gemeinsam genutzt so lange das möglich
  ist und erst wenn sich etwas ändert muss 'geklont' werden. Ansonnsten hätte man einen ziemlichen Overhead in der
  'Standard Anwendung' z.B. "Iterator<int> cIterator = lstMyList.GetIterator()" da intern dann mehrmals dynamisch
  Speicher angelegt und wieder freigegeben werden müsste.
- Neue Funktion: System::SetConsoleCursorPosition(): Wie von Stefan gewünscht eine Funktion zum setzen des
  Konsolen Cursors. Fügte auch 'GetConsoleCursorPosition()' hinzu damit das vollständig ist.
  Die Linux Implementationen von 'ClearConsoleScreen() & SetConsoleCursorPosition()' müsste man noch testen - hab
  hier mal den Weg über ANSI Sequenzen gewählt, diese Lösung findet man im Internet recht häufig. Für
  'GetConsoleCursorPosition()' konnte ich auch nach längerem Suchen keine einfache akzeptable Lösung finden.
- SystemWin32: 'GetComputerName()' und 'GetUserName()' ermitteln den nötigen Speicher nun automatisch passend.
  'GetProgramName()' hat leider weiterhin eine 'feste' größe die ich allerdings von '1024' auf 'MAX_PATH' setzte
  da ich für 'GetModuleFileName()' nix finden konnte das einem zurück gibt wieviel Speicher man denn nun eigentlich
  wirklich braucht.
- System-Klasse um einige Funktionen erweitert über die man Informationen über den Speicher bekommen kann. Dies dürfte
  praktisch für Resource Manager sein da diese solche Informationen nutzen können um rauszufinden wann es sinnvoll
  ist etwas länger nicht mehr genutzte Resourcen über Bord zu werfen. Diese Funktionen 'könnte' man auch in
  'MemoryManager' halten, allerdings passt es doch am Ende etwas besser in die 'System'-Klasse. Habe in der
  'MemoryManager'-Klasse allerdings ein kleines Kommentar eingefügt falls jemand dort zuerst nach diesen Funktionen
  suchen sollte. Die Windows Implementation ist 'sehr' einfach, bei der Linux Implementation ist es ein 'wenig'
  mehr (wie irgendwie fast immer...) aber immer noch im bereich des erträglichen. Den Linux Code müsste man noch
  testen ob das so korrekt läuft.
  Da es recht viele Funktionen für Speicher Informationen sind überlegte ich zuerst ob man diese Informationen nicht
  besser gesammelt in einer Struktur speichert, entschloss mich dann aber dagegen da es über Funktionen irgendwie
  'schöner' zu nutzen ist.



>> 26.02.2008
[CO]
- CmdLineParser::CmdArrayToString(): "int argc, const char **argv"-Parameter zu "const Array<String> &lstArray"
  gemacht... das ist universeller so herum. Ansonnsten hätte man etwas für 'wchar_t' und 'utf8' hinzufügen müssen...
  "#include <string.h>" hinterherwink *g*



>> 24.02.2008
[SB]
- Seit den letzten Änderungen ließ sich die Engine bei mir unter Windows nicht mehr compilieren, da es beim
  Linken unresolved references auf Tools::FloatToUInt32 und Tools::UInt32ToFloat gab. Das Problem konnte
  durch das Entfernen von PLGENERAL_API vor diesen Funktionen behoben werden. Ich nehme an, dass das
  deswegen erst jetzt auftritt, weil in PLGeneral nun der Header selbst nicht mehr eingebunden wird und
  der Compiler diese Funktionen daher nicht mehr sieht und somit auch nicht compilieren und exportieren kann.
  Da die Funktionen als inline deklariert sind, sollte hier aber sowieso nichts export werden, sondern erst
  beim Einbinden durch den Compiler an die entsprechende Stelle eingesetzt werden. Damit da nichts durcheinander
  kommt (und das inline dadurch nutzlos wird), sollte bei Inline-Funktionen also künftig kein Export-Makro
  mehr verwendet werden.



>> 23.02.2008
[CO]
- PLMain(): 'MODULE_HANDLE hModule' ersatzlos heraus genommen da wir selbst es noch nirgends verwendet haben
  und ich im Augenblick auch nicht wüsste wofür wir das noch brauchen - zumal es dies unter Linux scheinbar
  erst gar nicht gibt. Sollte ein Windows Nutzer es mal für etwas spezielles brauchen, muss er einfach die
  entsprechende Windows Funktion nutzen um an den Module/Instanz-Handle zu kommen... in dem Fall macht er dann
  eh etwas Platform spezifisches. :D
  "PLGeneralLinuxIncludes.h" könnte man nun herausnehmen da komplett leer.
- Habe in PLMain() 'lstArgs' zu 'lstArguments' gemacht, 'args' ist zwar 'geläufig'... aber das muss hier nicht
  sein diese zwanghafte Abkürzung. Wird eh nur selten genutzt und daher ist "Schreibaufwand" kein Argument,
  lesbarkeit aber schon. :D
- ParseIntegerArray(), ParseFloatArray(), ParseDoubleArray(), GetFlagsFromString() und GetStringFromFlags() von
  der 'Tools'-Klasse in eine neue 'ParseTools'-Klasse verschoben die sich im 'String'-Ordner befindet
- 'Tools::FlipRB3()'-Funktion in 'PLGraphics::Color3' verschoben + dieses Funktion heißt dort nun 'SwapRB'
- 'Tools::FlipRB4()'-Funktion in 'PLGraphics::Color4' verschoben + dieses Funktion heißt dort nun 'SwapRB'
- Ein paar Copy-Operators und Copy-Constructors hinzugefügt
- Ein paar Copy-Operators und Copy-Constructors entfernt da unnötig, sprich, die automatische erzeugten sind
  völlig ausreichend. Klassen: Version, Time



>> 18.02.2008
[CO]
- Directory::CreateRecursive() Implementation nochmal überarbeitet so das nur Url-Funktionen genutzt werden



>> 17.02.2008
[SB]
- PLGeneral läßt sich nun wieder unter Linux übersetzen. Und manchmal frage ich mich wirklich, wozu ich
  Dinge dokumentiere ...
  Aus FileWin32.h:
    // Hmmmpf, not nice. But better than to include <stdio.h>, and as it must only work on Windows, it might be ok :-)
    struct _iobuf;
   typedef struct _iobuf FILE;
  Hier habe ich doch explizit geschrieben, dass dieser Hack *nur unter Windows* funktionieren wird. Deswegen steht
  da auch "as it must only work on Windows". Und darum war auch im Linux-Header entsprechend <stdio.h> eingebunden,
  weil das da nunmal leider nicht so geht (evtl. kann man es dort anders vordefinieren, aber da die Header da zig
  if's und defines enthalten, wird dies wohl auf jedem System anders aussehen). Und nun wird einfach dieser Kommentar
  kopiert, "Windows" durch "Linux" ersetzt und geglaubt, so ginge das.
  Entschuldigung, aber sowas verstehe ich einfach nicht. Kann man nicht bitte mal vor dem Ändern davon ausgehen, dass
  andere Programmierer (ich, in diesem Falle) sich auch etwas *dabei denken*, was sie schreiben, und es somit wohl einen
  *Grund* hat, wenn die Forward-Declaration zwar im Windows-Header drin ist, aber im Linux Header nicht? Und wenn man dann
  trotzdem meint, dass das alles Quatsch ist und man das ändern muss, dann *muss* man das bitte auch unter Linux übersetzen
  und dort ausprobieren, und nicht einfach davon ausgehen, dass das schon gehen wird (insbesondere dann, wenn ich im Kommentar
  extra darauf hingewiesen habe, dass dies so nur unter Windows geht).
- Var.cpp: Habe ebenfalls die Änderung mit PLGeneralLinuxWrapper.h wieder rückgängig machen müssen, da es eben
  '_atoi64' unter Linux leider nicht gibt. Wo die Information herkommen soll, dass es diese Funktion unter Linux
  nun auch in stdlib.h geben 'müsste', ist mir schleierhaft, eine Suche per Google gibt jedenfalls nur zig mal die
  Information, dass es das unter Linux eben nicht gibt. Vielleicht könnten wir das nun einfach mal so lassen, und
  nicht in einem halben Jahr wieder behaupten, dass es nun gehen müsste, ohne auszutesten, dass das auch wirklich so ist.



>> 17.02.2008
[CO]
- LogFormaterConsole: Nutzt wieder 'printf' direkt anstatt 'File::StandardOutput' da es ansonnsten dank der statischen
  De-initialisierungs Reihenfolge in PLSampleChat einen Crash beim beenden geben kann :/
PLNetwork:
- Copy-Operators und Copy-Constructors hinzugefügt



>> 16.02.2008
[CO]
- File: ESeek andere Werte vergeben damit diese mit SEEK_CUR, SEEK_END, SEEK_SET aus 'stdio.h' zusammenpassen, das ist sicherlich
  eine gute Sache... in z.B. 'PLSoundFMOD/SoundManagerFMOD.cpp' musste man extra 'stdio.h' einbinden 'nur' um an diese Definitionen
  zu kommen was ich irgendwie dämlich fand. ("Mit Kanonen auf Spatzen schießen")
- Var.cpp: Nahm den speziellen Linux Include '#include "PLGeneral/PLGeneralLinuxWrapper.h"' heraus, auch dort 'müsste' '_atoi64'
  in 'stdlib.h' definiert sein
- System: Neue Funktion: GetConsoleCharacter(): Liest ein einziges Zeichen von der Konsole, für die Linux Fassung musste ich mal
  wieder Code 'aus dem Internet' nehmen... das so einfache Dinge so kompliert und nicht Plattform unabhängig sein müssen. *gruml*
  Wie üblich wieder ausführlich dazu geschrieben woher das kommt.
- System: Neue Funktion: ClearConsoleScreen(): 'Löscht' den Inhalt der Konsole, ebenfalls etwas sehr praktisches... aber auch wieder
  etwas das obwohl so Grundliegend, nicht wirklich so einfach ist daher auch hier wieder 'gefundener Code' sammt woher er kommt...
- FileHttp genauso wie die anderen File Implementationen alles private gemacht da man da von außen nicht mehr rankommen können sollte
  (es sprichts nichts dagegen, oder?)
- SystemWin32::GetEnvironmentVariable(): Nahm das [TODO] heraus und erweiterte das Kommentar 'etwas' damit man nachvollziehen kann
  warum das so 'merkwürdig' aussieht... das ist eine reine Optimierung. (nicht Performance 'kritisch', aber wenns möglich ist...)
  Würde man nur "GetEnvironmentVariableW(sName.GetUnicode(), NULL, 0)" schreiben, müsste 'sName' intern zwanghaft in Unicode
  konvertiert werden auch wenn das überhaupt nicht nötig ist da ASCII gegeben ist und eine solche Umgebungs Variable nicht
  existiert, existiert diese muss dann natürlich konvertiert werden da wir nicht vorher feststellen können ob für den Wert
  ASCII reicht oder nicht. (würd ich also gerne so lassen auch wenns 'Erbsenzählerei' ist, das zeigt das man da mit liebe
  fürs Detail rangeht :)
- Directory::CreateRecursive() Implementiert. Weis nicht ob das mit "System::GetInstance()->GetCurrentDir()" so prall ist, wüsste
  aber im Augenblick nicht wie man das anderst machen sollte, auf jedenfall funktioniert es recht gut.
- 'Directory.h': "PLGeneral/File/FileSearch.h" durch 'Forward declaration' ersetzt. Ich erwähne es da ich mir gerade nicht sicher
  bin ob das so absicht war oder nicht. (Regel sollte sein 'Forward declaration' wo geht, das hält die Compile dauer + das neu
  Compilieren bei Header Änderungen schön niedrig was die Produktivität steigert, bei der Sache bin ich wirklich stark hinterher
  da es sich wirklich auszahlt *g*)



>> 15.02.2008
[CO]
- Klassen im 'Container'-Ordner nochmal durchgeschaut (hauptsächlich nur Zeilen umbrüche)
- Heap & Map und Implementierungen um Copy-Operator und Copy-Constructor erweitert, auch wenn diese erstmal nicht Implementiert
  und daher private sind. Diese Operationen sind nicht ganz ohne... man könnte zwar einen Iterator nutzen, aber dann hätte man
  nur 'Werte' aber ohne die dazu gehörenden 'Schlüssel' - da muss ich mir noch etwas Einfallen lassen.
  Aber so ist's schonmal besser als überhaupt nix drinnen zu haben... dadurch viel sofort ein Bug im 'FileAccess' Copy-Constructor
  auf der bereits eifrig den nicht vorhandenen HashMap Copy-Constructor nutzte. :/
- SimpleMap: Speziellen Copy-Operator hinzugefügt, im grunde würde der automatische reichen wie beim automatischen Copy-Constructor,
  aber der Rückgabewert sollte hier ein universelles 'Map' sein
- HashMap: Speziellen Copy-Constructor und Copy-Operator hinzugefügt, wird bereits von 'FileAccess' verwendet
- File: "Standard Stream"-Dateien, nächster Anlauf nach Stefans Idee - klappt denke ich so recht gut und ist überschaubar.
  Habe dies als File Implementation Namens 'FileStdStream' realisiert damit das sauber Implementiert ist und es nicht zu viele
  Sonderfälle gibt die man ständig Abfragen muss.
- System: GetTime(), GetMilliseconds() und GetMicroseconds() Funktionen runter zu Sleep() verschoben damit Funktionen mit gleichen
  oder zumindestens sehr ähnlichen Jobs 'räumlich' beisammen sind
- System: Neue Funktion: IsConsoleKeyHit(): '_kbhit()' Funktion die bei Konsolen Anwendungen recht praktisch sein kann. PLSoundTest
  nutzt diese Funktion bereits. Dort wurde bisher 'im Internet gefundener' Code direkt verwendet - forschte etwas nach woher dieser
  Code stammte und es stellte sich heraus das dieser Code auf flipcode (es ruhe in Frieden) veröffentlicht wurde und recht bekannt
  ist. Fügte beim Linux Port ausführliche Copyright Informationen hinzu. (nutzen 'müsste' man es können)



>> 14.02.2008
[CO]
- SystemLinux::GetCurrentDir(): Ist nun nicht mehr auf 'MAXPATHLEN' beschränkt sondern ist Dynamisch
- Ging die System und XML Klassen nochmal ganz genau durch und fügte wo nötig Copy-Constructor und Copy-Operator
  hinzu. In z.B. 'DynLibLinux' ist dies jedoch nicht wirklich nötig da der User da nicht rankommt. (oder sollen wir
  hier dann trotzdem soetwas hinzufügen?)
  Schaute auch das jede Anweisung in einer eigenen Zeile steht - das machts einfacher wenn man mal einen Break-Point
  setzen will auch wenn das die Anzahl der Zeilen etwas aufbläht, die Vorteile überwiegen.
- File-Klassen nochmal genau durchgeschaut
- FileSearchImpl: 'm_pSearch' herausgenommen (bin mir zu 99% sicher das dies noch ein alter Überbleibsel war :)
- FileSearch: Copy-Operator hinzugefügt... hier erwähne ich es da es etwas umfangreicher ist, auch im Copy-Constructor
  änderte ich eine kleinigkeit. (sah etwas merkwürdig aus, funktionell natürlich kein Unterschied)
- FileObject: Destruktor virtuell gemacht
- FileAccess: 'NullEntry' zu einer öffentlichen Klassenvariable gemacht damit man von außen testen kann ob das als Ergebniss
  zurück kam + FileAccess braucht weniger Speicher (das erste Argument war ausschlag geben *g*)
- SocketAddress: "SocketAddress::SocketAddress(const String &sHost, uint32 nPort)" auskommentieren Code entfernt, schien mir
  wirklich 'tot' zu sein (sprich Nutzlos :)
- 'CmdLineParser' vom 'Tools'- in den 'String'-Ordner verschoben da es dort viel besser reinpasst, ist ja nur ein einfaches
  String Parsing. (also würde ich wohl auch genau in diesem Ordner danach suchen :)
  Wollte auch zuerst die 'Localization'-Klassen in den 'String'-Ordner verschieben da diese ebenfalls 'nur' dazu da sind um
  einen String von einer Sprache in eine andere zu bringen... aber da diese Klassen bereits das Loadable-System nutzen das
  zukünftig wie es aussieht in PLCore liegen wird, wird das Localization-System wohl auch mit in PLCore wandern müssen. Bei
  Zeiten sollten wir mal für das Localization-System ein Loader Plugin schreiben das die Sprachen/Übersetzungen aus einer
  Datenbank ausliest. *g*
PLNetwork:
- 'SocketAddress' und 'Socket' heraus genommen da diese mittlerweile in PLGeneral liegen. (oder gabs einen speziellen Grund wieso
  das auch dort noch lag?) Wenn ich das richtig sehe gibts kein 'Socket::Create()' mehr und das wird inter automatisch erzeugt,
  darum entfernte ich die entsprechenden Funktions aufrufe.



>> 13.02.2008
[CO]
- File: Um "Standard Stream"-Dateien erweitert... das bot sich direkt an das "Dinge auf Konsole ausgeben"  hierüber zu
  realisieren anstatt seperate Funktionen z.B. in die System-Klasse zu stecken. (könnten wir natürlich immer noch, aber ich denke
  das ist erstmal unnötig) Intern ist das sowieso so realisiert + damit kommen andere Dinge wie man im Punkt unten sehen kann
  'for free'... hat also durchaus seine Vorzüge. *g*
  Erweiterte dafür "EAccess" in der File Klasse damit das ohne große Änderungen ins Interface passt. In "File::Open()",
  "FileWin32::Open()" und "FileWin32::Linux()" musste etwas Code eingefügt werden - Stefan, schau dir das bitte genau an, nicht
  das diese Änderung überhaupt nicht ins Konzept passt und alles durcheinander bringt. Hatte mir schon überlegt ob eine extra
  "StandardStream"-Datei Implementation angebracht wäre... aber irgendwie war mir das dann mit Kanonen auf Spatzen geschossen.
- "Print()"-Funktion aus den XML Klassen genommen da sich dies nun über eine "Standard Stream"-Datei realisieren lässt.
  In der PLBaseTest Funktion "XmlTest::Test()" kann man sehen wie das Schreiben 'in die Konsole' darüber zu realisieren ist.
- XmlDocument: "LoadFile()" und "SaveFile()" Funktionen in "Load()" und "Save()" umbenannt damit das konsistent zu den anderen
  Funktionen ist.



>> 12.02.2008
[CO]
- Iteratoren wie besprochen umgeschrieben so das diese problemlos immer auf dem Stack liegen können damit man kein 'delete' mehr
  nutzen muss was man ja leider schnell mal vergisst. Alle Projekte entsprechend angepasst und darauf geachtet das die Iteratoren
  immer im kleinst möglichen Bereich genutzt werden damit so wenig wie möglich schief gehen kann. Dafür habe ich hier und da auch
  extra Blöcke hinzugefügt was ich allerdings nicht 'schlimm' finde da es für mehr 'Sicherheit' sorgt, (Thematik veränderung der
  Datenstruktur auf die der Iterator gerade arbeitet) das ersetzt praktisch das 'delete'. :)
  Im Iterator Copy-Constructor ist momentan noch ein kleiner Hack drinnen der den konstanten Parameter auf nicht Konstant umbiegt
  damit dort die Iterator Implementation zurück gesetzt werden kann - macht man den Parameter nicht Konstant erhält man tonnenweise
  Compiler Warnungen... momentan weis ich noch nicht wie man das anderst lösen könnte. (bei nicht konstant kann man ein Temporäres
  Objekt ändern das der Compiler nicht mag da Seiteneffekte möglich)
  Aber die Bedienung der Iteratoren ist so nun auf jedenfall 'deutlich' Eleganter und weniger Speicherleck anfällig. :D



>> 09.02.2008
[CO]
Gelaber:
- Nachdem ich gestern meine letzte Prüfung im total überfüllten 3'ten Semester geschrieben habe kann ich nun
  ENDLICH wieder mehr an PL machen. Am 17.03.2008 gehts dann weiter mit dem 4'ten Semester das hoffentlich nicht
  mehr so heftig wird wie das aktuelle. Bis dahin nur noch PL und daher wieder mehr Tagebuch Einträge meinerseits. :D
Alle Projekte:
- Auf Visual Studio 2008 umgestellt damit man 'relativ problemlos' auch unter Vista arbeiten kann ohne erstmal
  die Entwicklungsumgebung mit x Vista-Patches vollzudröhnen die dann doch nicht gehen (zumindestens bei mir nicht)
- In den 'sln'-Dateien hat sich nix groß geändert, nur die Versionsnummer:
      Microsoft Visual Studio Solution File, Format Version 9.00
      # Visual Studio 2005
  wurde zu
      Microsoft Visual Studio Solution File, Format Version 10.00
      # Visual Studio 2008
  In den 'vcproj'-Dateien hat sich zum Glück auch nicht wirklich viel verändert. In "<VisualStudioProject"
      Version="8,00" wurde zu Version="9,00"
  und
      TargetFrameworkVersion="131072"
  kam neu hinzu.
-     <Tool
          Name="VCWebDeploymentTool"
      />
  Wurde automatisch entfernt da "Web deployment to the local IIS server is no longer supported", für was auch
  immer das gut war, nicht mehr unterstützt wird - wir werden es sicher nicht vermissen. *g*
- Bei "<Tool Name="VCLinkerTool"" gibts zwei neue Optionen die automatisch hinzugefügt wurden:
      RandomizedBaseAddress="1"
      DataExecutionPrevention="0"
- "Data Execution Prevention (DEP)" auf "Image is compatible with DEP (/NXCOMPAT)" gestellt, das ist eine gute Sache
  und sollte bei uns keine Probleme geben (konnte jedenfalls keine feststellen)
- Folgende Warnung erschien nun öfters mal:
      "Command line warning D9035 : option 'Wp64' has been deprecated and will be removed in a future release"
  Da diese Meldung leider wie es aussieht nicht Deaktivierbar ist und das 'etwas' störrend ist deaktivierte
  ich "/Wp64 (Detect 64-Bit Portability Issues)". 64 Bit Compilieren ist momentan bei uns kein Thema... und falls
  man das doch mal ausprobieren will muss sich einer von uns erstmal ein 64 Bit Windows Installieren (zum Testen)
  + den 64 Bit VC Compiler. (sehe momentan aber keinen Grund das zu tun, gibt wichtigeres momentan :)
- Ging die Projekt-Abhängigkeiten (Menu bar -> Project -> Project Build Order... -> Dependencies)
  nochmal durch und korrigierte wo nötig. Damit geht das komplett Übersetzen wieder beim ersten mal sauber durch
  ohne das Fehlermeldungen kommen das z.B. 'PLGeneral.lib' nicht gefunden werden konnte da z.B. PLNetwork vorher
  'fertig wurde' mit dem Übersetzen. (Multi-Threading sei dank *g*)
- "LINK : warning LNK4224: /OPT:NOWIN98 is no longer supported;  ignored" -> "Optimize for Windows98"
  auf Default gesetzt... das Unterstützen wir eh nicht. (selbst MS hat mittlerweie den Support dafür
  fallen gelassen)
PLGeneral:
- "LIBCMT,MSVCRT" zu den zu ignorierenden Bibliotheken hinzugefügt um Linker Warnungen zu beseitigen
- "PLGeneralWin32Includes.h": WINVER und _WIN32_WINNT werden, falls bereits Definiert, 'undefiniert' - ansonnsten
  bekam ich hier unter Vista mit VC 2008 Warnungen
- TinyXML: Neuste Version 2.5.3 (intern steht bereits 2.5.4) aus dem Repository genommen und mit VC 2005 übersetzt.
  "TiXmlBase::PutString()" wurde mittlerweile in "TiXmlBase::EncodeString()" umbenannt und öffentlich gemacht - darum
  haben wir nun nur noch 3 anstatt 4 eigene Änderungen in TinyXML. :D
  Für Linux und VC7 müsste man das noch übersetzen.
PLNetwork:
- Warnung "warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead.
  To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details." beseitigt indem ich 'strncpy'
  durch 'MemoryManager::Copy' ersetzte - da wird nicht lange gezögert *g*



>> 05.02.2008
[SB]
PLCore:
- Auf Basis der Funktoren ein Event-System im Signal/Slot bzw. Event/Delegate Stil erstellt.
  Das ganze funktioniert so:
    void TestEvent(int nParam) { /* do something here */ }
  Event<int> cEvent;
  EventHandler<int> cHandler1(TestEvent);
  cEvent.Connect(&cHandler1);
  cEvent.Emit(1);
  Dabei ist zu beachten, dass ein EventHandler natürlich ein ganz normales Objekt ist, das dementsprechend verwaltet werden muß.
  Wenn man also z.B. ein EventHandler per new erzeugt, muß man diesen auch wieder löschen. Um das zu vereinfachen, gibt es
  die Basisklasse EventObserver und die spezialisierte Klasse ManagedEventHandler. Wann immer ein ManagedEventHandler für eine
  Memberfunktion einer Klasse erzeugt wird, die von EventObserver abgeleitet ist, kümmert sich diese automatisch um das spätere
  Löschen des Handlers:
    class Test : public EventObserver {
      Test() {
        // Diese Instanz wird automatisch später gelöscht
        g_pMainWindow.OnAlienEvent.Connect(new ManagedEventHandler<int>(&Test::OnAlien, this));
    }
    void OnAlien(int nParam) {
    }
  }
- Projekt PLCore begonnen und zunächst Functor und Event dorthin verschoben.



>> 04.02.2008
[SB]
WOW. Mit den C++ Templates kann man echt viele tolle Dinge machen - man muß nur aufpassen, auf dem Weg dahin
nicht Amok zu laufen ;-)
- Habe meinen ersten Test von Funktionsobjekten entfernt und durch eine neue Implementation ersetzt. Es ist jetzt
  nicht mehr nötig, die Anzahl der Parameter beim Template mit anzugeben - das merkt das Template nun von selbst.
  Auch kann man jetzt die Klasse Functor direkt verwenden, und der einfach einen beliebigen gültigen Zeiger
  auf eine Funktion hineingeben - egal ob statisch oder Memberfunktion einer Klasse. Beispiel:
  Functor<int, int> cFunc(TestFunction);
  Functor<int, int> cFunc(&Class::TestMethod, &cObject);
  int nRes = cFunc(10);
  Dank vieler verrückter Template-Tricks müßte das ganze Typensicher sein - man kann die Klasse also nicht austricksen
  und z.B. einen Zeiger auf ein Objekt falschen Typs hineingeben oder aus einem int(int) ein int(float) machen.
  Es war jetzt auch nicht mehr nötig, noch Makros zu verwenden - das ganze geht komplett nur mit Templates. Allerdings
  steht zur Zeit noch der Test aus, ob auch alle Compiler die wir verwenden das ganze mögen (VC8 mag es jedenfalls).
  Da der ganze Template-Mechanismus beim Compilieren abläuft braucht übrigens auch keine Angst zu entstehen, dass das
  ganze ein zu großer Overhead wäre und daher die Performance beeinträchtigen könnte. Die ganzen Hilfsklassen sind nur
  dafür da, damit der Compiler die richtigen Typen zur richtigen Zeit findet, da sie aber weder Daten beinhalten noch
  jemals Instanzen davon erzeugt werden, bleibt davon zur Laufzeit nichts mehr übrig :-) Das ganze reduziert sich
  dann auf das Dereferenzieren zweier Pointer :-) 



>> 22.01.2008
[CO]
Alle Projekte:
- Überall den Style der Konstruktor Initialisierer-Liste wie vor geraumer Zeit besprochen angepasst



>> 22.01.2008
[CO]
- ClassManager::LoadPlugin(): Hier hatte sich ein Fehler eingeschlichen so das manche Plugins nicht gefunden
  werden konnten. Man kann innerhalb der '.plugin'-Datei auch absolute dll-Pfade nutzen, z.b. zu Testzwecken -
  ansonnsten sind die dll's IMMER relativ zum Verzeichniss in dem sich die '.plugin'-Datei befindet.



>> 19.01.2008
[CO]
- Fügte wie von Stefan gewünscht eine 'Set'-Funktion zur 'Map'-Klasse + deren Implementationen hinzu. Lies die 'Add'
  und 'Remove' Funktionen jedoch drinnen da ich finde das diese durchaus ihre Existenzberechtigung haben. (sonst hätten
  wir wohl schon vvviiiiel früher die 'Set'-Funktion eingebaut :)
  Z.B. kann man über 'Add' mehrmals den gleichen Schlüssel einfügen, das verhält sich im Grunde dann wie ein 'Stack' +
  'Replace' ersetzt wirklich nur einen Wert wenn dieser bereits in der Map war, ansonnsten wird nix gemacht.
- PLMain: Unicode-Support für die Kommandozeilen-Parameter hinzugefügt, für Linux könnte ich nix spezielles finden...



>> 18.01.2008
[CO]
Alle Projekte:
- Überall "Predefinitions" durch "Forward declarations" ersetzt
- Ein paar unnötige Includes entfernt ("Include-Sparsamkeit" ist mir extrem wichtig :)
- "uint32 HashFunction::Hash(const char szKey[])" und "uint32 HashFunction::Hash(const String &sKey)":
  Variable 'g' in die Schleife gezogen + die Zuweisung in der Abfrage entfernt
- Alle 'doxyfile'-Dateien an die 'Doc'-Ordner verschiebung angepasst
- "Config/" in Dateinamen beim Laden/Speichern von Konfigurationen entfernt, das regelt das Loadable System
  intern selbst wo diese Dateien standardmäßig landen
PLGeneral:
- Bugfix: Fand gerade den Grund dafür das es z.B. beim laden der Szene 'PhysicsPlayground.scene' Crashte:
  "FileWin32::Open()": Hier konnte es eine Situation geben in der 'szMode' nicht Initialisiert wurde. In dieser
  kombination muss 'ungültig' zurück gegeben werden. ("FileLinux" natürlich das gleiche)
    (!(nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend))
- Bugfix: "FileWin32::Open()": Bei folgender Kombination klappte das noch nicht wie erwartet:
    (nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend)
  Wenn man nicht "FileRead" gesetzt hatte gab die Funktion 'ungültig' zurück obwohl eine Datei bereits
  existierte in die man hätte schreiben können. Daher wird hier nun erstmal geprüft ob die Datei bereits
  vorhanden ist, wenn ja kann man den "w"-Modus nutzen, ansonnsten wird 'ungültig' zurückgegeben.
  ("FileLinux" natürlich das gleiche)
- "File::Open(uint32 nAccess = 0)" zu "File::Open(uint32 nAccess)" gemacht da '0' eine ungültige Flag-Kombination ist
- Loader::OpenFile(): Muss Dateien auch korrekt erzeugen können beim Speichern, das müsste so nun hoffentlich
  passen... nach den oberen Änderungen konnte ich keine Probleme mehr feststellen
- LoadableManagerLoaderPL: 'FileSystemSettings' entfernt und 'BaseDirectories' nach 'LoadableManagerSettings'
  verschoben
- "Loader::OpenFile()": Kennt nun 'nur' noch Basis Verzeichnisse, also kein '-1 = das aktuelle Verzeichniss'... dies
  war höchst Problematisch da dies nicht mit den 'Prioritäten' der Basis Verzeichnisse zusammen passte. War etwas im
  aktuellen Verzeichniss, also standardmäßig wo das Programm selbst liegt, wurde diese Datei 'immer' genommen, auch
  wenn man z.B. im Falle des Scene Viewers dem Verzeichniss in dem die aktuelle Szene liegt die höchste Priorität geben
  wollte damit 'zuallererst' geschaut wird ob die gesuchte Datei dort liegt.
- LoadableManager: "", also ein leerer String ist nun ebenfalls ein gültiger Basis-Pfad und steht für das
  'aktuelle Verzeichniss'
- LoadableManager:SetBaseDirPriority(): Bei den URL-Umstellungen hatte sich hier ein kleiner Fehler eingeschlichen
  so das die Prioritäten nicht korrekt geändert wurden



>> 14.01.2008
[SB]
- Beim Lesen aus Archiven mit dem Flag FileMemBuf gab es Probleme, weil die Zeilenenden auch dann konvertiert wurden,
  wenn die Datei als Binary geöffnet wurde. Nachdem ich dieses Problem behoben hatte, scheinen auch wieder alle Daten
  richtig geladen zu werden :-)
- Habe das Flag FileBinary komplett gelöscht, da dieses nur Probleme machte. Generell werden Dateien im Binärmodus geöffnet,
  wenn dies nicht gewünscht ist, muss FileText angegeben werden.
- Registry-Klasse in einen eigenen Ordner verschoben.
- Url::Collapse: Hier gab es einige Probleme, wenn ein ".." am Ende des Pfades stand. Diese sind nun hoffentlich behoben ...
- Änderungen aus dem Rewrite-Branch in den Trunk übertragen. Gab so weit ich sehen kann keinerlei Probleme - die einzige
  Datei mit einem Conflict war "Diary.txt" :-))



>> 13.01.2008
[CO]
- Ein paar Mini-Änderungen an der "Registry"-Klasse



>> 12.01.2008
[SB]
- Wrapper für die Registry hinzugefügt. Ich möchte einfach *nirgendwo* mehr direkt auf die Windows-API zugreifen müssen,
  da das immer total nervt und meist extrem unübersichtlich ist. Auch muß man dann ja meist wieder direkt mit irgendwelchen
  String-Buffern hantieren, Speicher allozieren etc. *brrr*. Die Klasse Registry bietet also Zugriff auf die Windows-Registry
  und wrappt einfach die API-Funktionen in eine hübsche Klasse. Später könnte man das evtl. noch erweitern, um auch auf andere
  Registry-Systeme zugreifen zu können (z.B. Gnome hat ja auch so etwas). Allerdings würden dann natürlich auch die ganzen Pfade
  darin vollkommen anders aussehen, das muß man also mal sehen, ob das überhaupt sinnvoll wäre. In jedem Fall kann man nun auch
  über die Registry-Klasse abfragen, ob überhaupt eine Registry auf dem System vorhanden ist, falls nein kann man dann auf andere
  Methoden zurückgreifen und sich so ein #ifdef sparen :-)



>> 11.01.2008
[SB]
- Einige kleinere Fehler in RegEx behoben.



>> 10.01.2008
[SB]
- Neue Toolklasse Version eingebaut. Diese speichert die Versionsnummer eines Projektes und kann diese z.B. als
  String ausgeben. Auch können Versionsnummern miteinander verglichen werden. Dies soll später verwendet werden,
  um die Versionen der einzelnen Komponenten zu verwalten.



>> 21.12.2007
[SB]
- Neue Klasse RegEx zum Parsen regulärer Ausdrücke eingebaut. Diese sollten wir verwenden, um uns ansonsten schnell
  kompliziert werdende Parsing-Aufgaben zu erleichtern. Ich denke, dass wir damit an manchen Stellen das Parsen
  von Text deutlich vereinfachen können, z.B. für Vektoren, Listen usw. (a b c) . Der Tokenizer ist zwar recht leistungsfähig,
  aber selbst damit ist es immer noch sehr aufwendig, so etwas zu parsen, und die entsprechenden Stellen werden meist
  sehr groß und sind schwer zu lesen. Reguläre Ausdrücke dürften hier weiterhelfen und sind sowieso an vielen Stellen sehr
  nützlich :-) Das ganze benutzt den Perl-Syntax für reguläre Ausdrücke und darf noch kräftig erweitert werden, im Moment
  können nur einfache Vergleiche ausgeführt werden. Die Klasse ist ein Wrapper für die PCRE Library (Perl Compatible
  Regular Expressions), die unter einer BSD-Lizenz steht.
- SearchFilterRegEx: Neuer Suchfilter zum Suchen mit regulären Ausdrücken.



>> 15.12.2007
[CO]
- Loadable System Änderung vom 08.12.2007 im Main-Branch wieder rückgängig gemacht da nicht alles wieder ging wie vorher
  und Stefan das im seperaten Branch komplett überarbeitet. So haben wir zumindestens wieder eine voll lauffähige Version.



>> 09.12.2007
[SB]
- Einige Unklarheiten beseitig, die beim Umstellen auf das neue FS deutlich wurden.
- Url: Die Methoden zum Zurückgeben der URL etwas umsortiert und umbenannt, damit deren Verwendung verständlicher wird.
  Man sollte eigentlich immer Url::GetNative() verwenden, denn dies gibt den Pfad im nativen Format zurück, sofern dies
  ein lokaler Pfad ist, ansonsten als URL, wenn es sich z.B. um http:// handelt. Das scheint mir der natürlichste Weg zu
  sein, weil der Pfad für den User "normal" angezeigt wird, und nur dann z.B. ein Protokoll hinzugefügt wird, wenn das
  auch wirklich nötig ist. GetUrl() dagegen gibt in jedem Fall file:// heraus, was man aber normaler Weise nicht haben
  möchte und auch nicht braucht. Als Faustregel würde ich daher sagen:
  - Zur Übergabe von URLs (z.B. zum Laden/Speichern): GetUrl()
  - Zur Ausgabe von URLs an den Benutzer: GetNative()
- Url: Zugriff auf die einzelnen Teile einer Url etwas verändert und Funktionen für die häufigsten Zugriffsformen
  hinzugefügt (z.B. nur Pfad oder Dateiname ohne Endung) 
- FileObject, File, Directory: GetUrl() gibt *immer* eine URL ohne "/" am Ende zurück. Dies ist wichtig zu wissen, denn
  dann kann man z.B. ohne Bedenken cDir.GetUrl() + "/filename.txt" schreiben, ohne noch selbst auf "/" testen zu müssen.
  Einzige Besonderheit: Beim Mounten von ZIP-Dateien muß das "/" angegeben werden, damit das FS überhaupt weiß, dass diese
  ZIP-Datei als Verzeichnis angesprochen werden soll und nicht einfach die Datei geöffnet werden soll. Das ändert aber nichts
  an der Regel, dass GetUrl() auch in diesem Fall ohne "/" zurückgegeben wird!
- FileObject: Erweiterte die Funktionen zum Zugriff auf die URL, damit man die häufig benötigten Funktionen direkt zur
  Hand hat und nicht ständig Url's dafür erzeugen muss. Die Funktionen sind analog zur Url-Klasse und wrappen diese:
  GetUrl() gibt nun das Url-Objekt zurück, damit dieses nicht unnötig neu erzeugt werden muß
  GetPathUrl() gibt die Url als String zurück
  GetPathNative() gibt den Native-Path als String zurück
  GetPathWindows() gibt den Windows-Path als String zurück
  GetPathUnix() gibt den Unix-Path als String zurück
  GetFilename() gibt nur den Dateinamen zurück
- Threads etwas umgebaut und GetMainThread() in System eingebaut.
- File: FileBinary und FileText vertauscht, damit ist FileBinary nun wieder der Standard.
- Die Engine auf das neue FS umgestellt. Dabei sind mir einige Stellen aufgefallen, die noch deutlich überarbeitet werden
  sollten, z.B. werden noch viel zu Oft irgendwelche Dateipfade auseinandergebröselt, hier sollte zumindest versucht werden,
  das möglichst transparent nur an einer Stelle zu tun. Manche Dateitypen suchen dann wieder selbst die Basispfade durch
  oder geben einen festen Pfad vor (z.B. "data/sounds"), das sollte auf jeden Fall raus. Viele Dinge habe ich nur blind
  umstellen können und fürchte, dass das nicht mehr richtig funktionieren wird. Dies war aber schlecht anders möglich, da
  mir teilweise die Funktionsweise der entsprechenden Funktion nicht wirklich klar wurde und ein komplettes Neuschreiben
  on-the-fly zu aufwendig wäre.
- Es läßt sich nun wieder alles compilieren, allerdings funktionieren die Loader noch nicht wieder richtig, weshalb viele
  Dateien noch nicht gefunden werden können. Als nächstes werde ich daher die für später geplanten Arbeiten vorziehen und
  das Config- und das Loader-System überarbeiten. Es dürfte sinnvoller sein, dies nun gleich neu zu machen, als erstmal
  das alte wieder mühselig zum Laufen zu bringen um es dann hinterher doch noch neu zu schreiben.



>> 08.12.2007
[SB]
- PLGeneral/System überarbeitet: Globale Manager entfernt, direkte Instanzen der Klassen sind jetzt möglich und
  Impl-Klassen nach dem gleichen Pattern wie in File überarbeitet.
- Folgendes Pattern für Implementationsklassen soll nun überall möglichst identisch verwendet werden:
  - Eine plattformunabhängige Klasse besitzt einen Zeiger auf eine (versteckte) Implementationsklasse
  - Diese wird im Konstruktor (oder evtl. erst später, wie in FileObject) erzeugt, aber innerhalb dieser Klasse
  - Die Implementationsklasse besitzt keinen Zeiger zurück auf die plattformunabhängige Klasse!
  - Das gesamte Interface der Implementationsklasse sollte protected sein, auch die virtuellen Funktionen.
  - Mittels friend darf die plattformunabhängige Klasse darauf zugreifen.
  - Konkrete Implementation werden abgeleitet, auch diese mit protected-interface.



>> 08.12.2007
[CO]
- Base Path Dinge von FileSystem in LoadableManager verschoben. Ist noch nicht wirklich Prall realsiert, sollte so aber
  erstmal reichen. Nachdem das überarbeitet FS drinnen ist sollte man sich das hier nochmal anschaun.



>> 05.12.2007
[SB]
- Map: Auf die Values einer Map kann nun auch nicht-const zugegriffen werden. Dies ist nützlich, wenn es sich um abstrakte
  Datentypen (z.B. Klassen) handelt, von denen man nur ein Attribut ändern möchte und nicht das gesamte Objekt per
  Replace austauschen möchte. 
- SearchFilter implementiert. Beim Auflisten von Dateien wird über die Klasse SearchFilter getestet, ob der gefundene
  Dateiname dem Filter entspricht. Als Standard wird ein WildCard-Filter verwendet, es können aber auch individuelle
  Filter implementiert werden.
- GetCurrentDirectory und SetCurrentDirectory in PLGeneral::System implementiert.



>> 04.12.2007
[SB]
- HttpHandle und ZipHandle: Beide Klassen besitzen nun nur noch einen leeren Konstruktor und öffnen zunächst keine
  Datei bzw. Verbindung. Dafür gibt es nun jeweils eine Funktion Open(). 
- Habe mal etwas mit den Ideen herumgespielt, wie man beim FS den Zugriff auf z.B. passwortgeschützte Inhalte
  realisieren könnte. Die bisherige Methode, Open(Name, Passwort) gefällt mir aus folgenden Gründen nicht:
  - Die Signatur von Open wird um einen Parameter erweitert, den vermutlich die meisten User zunächst nicht verstehen
  - Es wird nur von einem Passwort ausgegangen, in vielen Fällen kann es aber noch mehr Parameter geben
    (Username/Passwort, Crypto-Keys u.v.m.)
  - Wenn man z.B. eine Datei "http://www.pixellight.org/test.zip/dir/test.txt" laden möchte, kann man an verschiedenen Stellen
    einen Zugriffsschutz haben, z.B. einmal für den http-server (username/passwort), und dann noch einmal für die Zip-Datei.
    Mit dieser Lösung ist es aber nicht möglich, mehrere Passwörter zu übergeben, ausserdem vermittelt Open(Name, Passwort)
    in diesem Falle den Eindruck, dass das Passwort für test.txt benötigt wird, was aber gar nicht der Fall ist.
  Es sollte also die Möglichkeit geben, mehrere Authentifizierungsdaten gleichzeitig anzugeben, falls die Dateisysteme wie
  im obigen Beispiel verschachtelt sind. Ausserdem wäre es nett, noch weitere Daten übergeben zu können, z.B. dass bestimmte
  Zugriffsflags verwendet / nicht verwendet werden sollen (z.B.: Zip-File nicht memory-buffered öffnen), oder weitere
  unbestimmte Informationen (annotation like).
- FileAccess implementiert, dies soll so funktionieren wie oben angegeben. Kleines Beispiel:
  FileAccess sAccess;
  sAccess["www.pixel-light.de"].SetAuth("username", "password");                // Username und Passwort für HTTP
  sAccess["http://www.pixellight.org/test.zip"].SetPassword("password");        // Passwort für die ZIP-Datei
  sAccess["http://www.pixellight.org/test.zip"].SetFlags(File_::FileMemBuf, 0); // ZIP-Datei ohne FileMemBuf öffnen
  File cFile("http://www.pixellight.org/test.zip/dir/test.txt", sAccess);
  Etwas problematisch ist es zur Zeit noch die Frage, welcher Name für welche Zugriffsoptionen verwendet werden soll.
  FileZip sucht nach dem exakten Namen der Zip-Datei, also z.B. "http://www.pixellight.org/test.zip",
  FileHttp sucht dagegen nach der Domain, also z.B. "http://www.pixel-light.de". Gerade im Falle von HTTP ist das schwierig,
  da man ja nicht genau weiss, wo auf dem Server der Passwortschutz eingerichtet ist.
- FileAccess um bCaseSensitive erweitert. Dies wird von FileZip ausgelesen, somit kann man bestimmen, ob eine Zip-Datei
  case-sensitive behandelt werden soll oder nicht. Standardwert ist jetzt 'true', da wir dies anderswo auch meist so behandeln!
- Ebenfalls prüft FileZip nun, ob ein Wert für FileMemBuf angegeben wurde. Ist dies der Fall, wird dieses Flag übernommen,
  damit kann also das automatische Buffern von Zip-Dateien ausgeschaltet werden. Das Prinzip der Flags in FileAccess funktioniert
  so: Alle Flags, die in FlagsMask angegeben werden, gelten als "gesetzt" (egal ob 1 oder 0). Deren Wert wird dann in FlagsValue
  bestimmt. Beispiel: (Mask = Read | MemBuf, Value = Read) bedeutet, dass Read = 1 gewünscht ist und MemBuf = 0. Alle anderen
  Werte sind nicht weiter bestimmt. Allerdings sind die ganzen Angaben in FileAccess nur "Wünsche", die berücksichtigt werden
  können aber nicht müssen. Im Moment wird also nur bei Zip-Dateien auf MemBuf geachtet, alle anderen Flags werden ignoriert.
  Man kann dies also nciht nutzen, um z.B. eine Zip-Datei auch zum Schreiben zu öffnen oder ähnliches.
- Mir ist aufgefallen, dass man auf die Values einer HashMaps nur noch als const zugreifen kann, man also die Werte später
  nicht mehr ändern kann. Gerade beim FileAccess brauche ich aber auch die Möglichkeit, die Objekte später noch zu ändern.
  Habe das daher erst einmal eingehackt, Christian sag bitte mal bescheid ob das so ok ist oder ob ich das anders lösen
  sollte.



>> 03.12.2007
[SB]
- HttpHandle: Beim Lesen von Daten über das Netz kann es häufig vorkommen, dass noch nicht genügend Daten im Stream
  vorhanden sind, in dem Fall gibt Socket.Read() einfach so viel zurück, wie bereits vorhanden ist, auch wenn dies
  weniger ist als angefordert. Dies ist so ok und sollte denke ich auch nicht geändert werden, wenn man mit Sockets
  arbeitet muss man dies einfach einplanen. Beim Arbeiten mit Dateien wird jedoch davon ausgegangen, dass Read() genau
  so viel liest wie angefordert, wenn weniger gelesen wird, ist dies ein Fehler. Daher habe ich dies in HttpHandle::Read()
  so geändert, dass so lange immer wieder vom Socket gelesen wird, bis die gewünschte Datenmenge erreicht wurde, es
  kann also hier nicht mehr vorkommen, dass zu wenig gelesen wird. Bei grossen Dateien könnte dies also einen Moment
  lang dauern :-) 
- HttpHandle: Fehler behoben, es muss die gesamte URL übermittelt werden, damit ein Webserver, der mehrere Domains hostet
  (wie bei uns) weiß, welche gemeint ist.
- HttpHandle: Es wird nun auch Http-Auth (Basic) unterstützt, damit kann also per Username und Passwort auf geschützte
  Webseiten zugegriffen werden.
- Memory buffered files implementiert: Wird eine Datei mit dem Flag FileMemBuf geöffnet, so wird der gesamte Inhalt der
  Datei eingelesen und im Speicher behalten, alle weiteren Lesezugriffe finden dann nur noch auf diese Buffer statt.
  Ich habe mich für die Bezeichnung "Memory Buffered" entschieden, da "Memory Mapped" viele unterschiedliche Bedeutungen
  hat (z.B. auf OS-Ebene, um mittels gemappter Dateien IPC zu betreiben), da scheint mir "Memory Buffered" eindeutiger
  und daher leichter verständlich. Der Buffer und der Zugriff darauf befindet sich in der Klasse File, und kann nur zum
  Lesen verwendet werden.
- ZipHandle: Das Zip-File wird nun mittel FileMemBuf geladen. Hier sollten wir uns noch überlegen, ob man das evtl. von
  der Dateigröße abhängig machen sollte, oder irgendwie eine Möglichkeit geben sollte, dies wenn gewünscht zu deaktivieren.



>> 02.12.2007
[SB]
- Habe die Basisklassen von PLNetwork nach PLGeneral/Network verschoben, da Sockets und Netzwerkkommunikation eigentlich
  zu den System-Basisklassen gehören. Alles weitere, also die Struktur der Netzwerkkommunikation in PL, wird wie geplant
  in PLNetwork implementiert werden, die Basisklassen können jedoch auch an anderen Stellen nützlich sein. 
- Netzwerk-Basisklassen überarbeitet und wo möglich vereinfacht.
- HTTP-Client hinzugefügt. Analog zu den ZIP-Dateien gibt es eine Klasse HttpHandle, die benutzt werden kann, um eine
  HTTP-Verbindung mit einem Server aufzumachen und Dateien zu übertragen. Diese Klasse kann bislang nur das nötigste, also
  nur das Übertragen einer Datei per HTTP/1.0 sowie das auslesen der wichtigsten Header-Informationen. Alles andere kann
  später erweitert werden.
- HTTP-Implementation für das FS hinzugefügt. Damit kann per HTTP auf Dateien aus dem Netzwerk zugegriffen werden, was ich mir
  sehr nützlich vorstelle, um z.B. News von der Webseite zu laden (oder auch Updates). Dank der Schachtelung ist natürlich auch
  etwas wie "http://www.pixellight.org/test.zip/test.txt" möglich, was auch gut funktioniert, allerdings nicht zu empfehlen ist :-)
- Linux-Implementation für das FS hinzugefügt.
- Generische Funktionen für das Kopieren und Verschieben von Dateien hinzugefügt. Zunächst wird versucht, die systemspezifische
  Implementation für die entsprechende Funktion zu verwenden, wenn dies fehlschlägt, wird es mit der generischen Variante
  versucht: Wenn man z.B. eine Datei aus einer Zip-Datei irgendwo hin kopieren möchte, wird dies mit der Systemfunktion
  natürlich nicht gehen. Das Herunterladen einer Datei aus dem Netz kann man nun also z.B. so erledigen:
    File("http://www.pixellight.org/test.zip").Copy("C:\\test.zip")



>> 01.12.2007
[SB]
- Funktionalität von ZipHandle vervollständigt.
- FileZip und FileSearchZip unter Verwendung von ZipHandle wieder implementiert und getestet. Das Verhalten je nach
  Lesemodus (Binary oder Text) an die Systemfunktionen angepasst.
- Beim Öffnen einer Datei wird die Implementationsklasse automatisch ermittelt: Entweder mittels des Protokolls,
  oder durch Suche nach ".zip/" oder ".pak/" im Dateinamen. Dadurch muß eine Zip-Datei als Verzeichnis so geöffnet
  werden: Directory("test.zip/"), da "test.zip" an sich auch eine valide Datei wäre. Innerhalb der Zip-Datei sind aber
  z.B. "test.zip/test" und "test.zip/test/" identisch.
- Eine Problematik beim Verwenden von Zip-Dateien: Mir ist aufgefallen, dass in einer Zip-Datei nicht unbedingt alle
  Unterverzeichnisse auch aufgelistet werden. Wenn ich unter Windows direkt oder mit TugZip eine Zip-Datei packe, gibt es
  z.B. die Einträge "test/dir1/test1.txt" und "test/dir1/test2.txt", aber weder "test/dir1/" noch "test/". Je nachdem,
  welches Programm man verwendet, ist dies mal so und mal so, aber offensichtlich kann man sich nicht darauf verlassen,
  dass alle Verzeichnisse auch direkt aufgelistet werden. Dieses Problem in den Zip-Klassen zu lösen wäre denke ich etwas
  aufwendig, da man die Pfade auseinandernehmen und eine eigene Liste erstellen müßte, anstatt einfach nur alle Einträge
  in der Zip-Datei durchzugehen. Später sollte man dies wohl tun, damit es keine Probleme mit "schlechten" Zip-Dateien gibt,
  im Moment würde ich aber einfach darauf achten, dass die Zip-Dateien vernünftig sind - zip unter Linux trägt beispielsweise
  alles korrekt ein :-)



>> 21.11.2007
[SB]
- Übertragen der Zip-Implementation begonnen.
- Neue Klasse ZipHandle erstellt, welche auf einer Zip-Datei arbeitet. Vereinigt die Funktionalität von StreamZip und IteratorZip,
  denn diese getrennten Klassen arbeiteten letztlich beide auf dem File-Handle von DirectoryZip, was ich sehr undurchschaubar
  finde. Weitere Zip-Funktionalität war auch noch innerhalb von DirectoryZip und FileZip verstreut, das wurde ebenfalls in diese
  Klasse übertragen. ZipHandle besitzt nun selber den File-Handle für die Zip-Datei und soll als generelles Interface dienen, um
  den Inhalt der Zip-Datei aufzuzählen und anschliessend z.B. auf den Anfang einer Datei zu springen und diese auszulesen.
- Neue eingebettete Klasse ZipHandle::ZipEntry hinzugefügt. Diese Klasse enthält die Informationen zu einem Eintrag
  innerhalb der Zip-Datei. Damit sind diese Informationen nicht mehr direkt in ZipHandle (übersichtlicher), außerdem kann so
  leichter eine Liste von Zip-Entrys erstellt werden, was man z.B. innerhalb der FS-Abkapselung machen könnte, um den Zugriff
  auf das Directory schneller zu machen. 
- Da die verteilten Zip-Funktionen recht verwirrend waren, bin ich mir nicht 100% sicher, ob ich alles richtig übertragen habe.
  Christian: Bitte schau nochmal genau drüber und teste wenn möglich ZipHandle etwas, ob noch alles richtig funktioniert.
- ZipHandle überarbeitet und versucht, das Interface sowie die Variablennamen verständlicher zu machen. Diese Klasse soll für
  sich alleine genommen schon leicht verwendet werden können, um auf eine Zip-Datei zuzugreifen und diese auszulesen. Die weitere
  Abstraktion über FileZip und FileSearchZip dient dann nur noch dazu, Zip-Files auch transparent über das FS-Interface nutzen
  zu können. Es soll aber auch ganz ohne gehen, die gesamte Zip-Funktionalität soll also in ZipHandle vorhanden sein.  
- Kleinen Test implementiert, der den Zugriff auf Zip-Dateien nur über ZipHandle demonstriert testet. Konnte bisher keine Fehler
  feststellen, das Verzeichnis eines Zip-Files sowie der Inhalt der enthaltenen Dateien werden mir korrekt angezeigt. 



>> 20.11.2007
[SB]
- Basisklassen und Win32-Implementation für das Dateisystem sind weitgehend vollständig (bis auf Suchfilter).
  Das Klassenlayout wurde stark vereinfacht und gleichzeitig teilweise erweitert, so ist das Erstellen, Löschen,
  Umbenennen, Verschieben usw. nun direkt über ein File- oder Directory-Objekt möglich. Dabei gibt es nun auch
  ein Muster, welches wir sonst selten haben: Gleichnamige Funktionen in abgeleiteten Klassen, die *nicht* virtuell
  sind. File::Create erstellt eine neue Datei, während Directory::Create ein Verzeichnis erstellt. In der Basisklasse
  gibt es diese Funktion nicht, daher dürfte dies kein Problem darstellen, und über das verwendete Interface legt
  der Programmierer deutlich fest, was von beidem er tun möchte, das ganze scheint mir so also auch am intuitivsten zu sein.
- Mittels Assign kann das Datei-Objekt auf einen neuen Dateinamen gelenkt werden. Dabei werden automatisch vorher
  geöffnete Dateien geschlossen, das Objekt "zeigt" also dann auf eine andere Datei (diese muß nicht mal vorhanden sein).
  Beispielsweise kann so eine Datei oder ein Verzeichnis angelegt werden: Directory("test").Create();
- Dateiflags vervollständigt und in hoffentlich üblicherer Weise verwendet (z.B. gibt es nun neben FileWrite auch FileRead,
  ebenso gibt es FileBinary und FileText).
- Die Url-Klasse wird nur noch intern eingesetzt, im Interface werden dagegen nur noch Strings übergeben. Ansonsten müßte
  man ständig Methoden doppelt machen, obwohl der User wohl meist sowieso Strings übergeben wird. Ausserdem sollte Url
  sowieso so selten wie möglich eingesetzt werden, um unnötiges Parsen des Dateinamens zu verhindern.



>> 19.11.2007
[SB]
- Klasse Url überarbeitet und vereinfacht. Ein Pfad wird nun *immer* intern in URL-Form gespeichert, d.h. mit Protokoll
  und mit '/' als Trennzeichen. Beim Umwandeln werden auch nicht mehr unterschiedliche Url-Instanzen kopiert, sondern
  direkt die Strings wie gewollt umgewandelt. Dies scheint mir am einfachsten und ist in der Benutzung konsistent, da
  es keine Unterschiede mehr geben kann, in welcher Form verschiedene Url-Instanzen ihre Werte vorliegen haben. Im allgemeinen
  möchte man eine Url meist im einheitlichen Url-Format angeben, dieser Zugriff ist daher auch immer der schnellste, da nur
  ein String zurückgegeben werden muss. Will man dagegen in ein spezielles Format umwandeln, ist dies etwas aufwendiger, dafür
  macht man dies meist nur einmal (z.B. beim Erzeugen einer FileWin32-Instanz). Da diese dann nur als String und nicht mehr
  als Url gespeichert wird, entfällt dafür aber auch der Overhead, noch einmal die umgewandelte Url in ihre Bestandteile
  zu zerlegen.
- FileObject: Die URL eines jeden Objektes wird jetzt immer ohne ein abschließendes '/' gespeichert. Damit ist der Dateiname
  eines FileObject immer korrekt, und man kann sich sicher sein, wie dieser verwendet werden muß (z.B. kann der Suchpfad
  eines Verzeichnisses jetzt immer korrekt durch Hinzufügen von /*.* erzeugt werden). Eine URL kann aber weiterhin Pfade
  speichern, die mit / enden, da dies für eine URL von Bedeutung sein kann.



>> 13.11.2007
[SB]
- Rewrite des Dateisystems begonnen.
- Globale Klasse FileSystem entfernt.
- Die Klassen FileObject, File und Directory bleiben von der Funktionsweise sehr ähnlich, werden nun aber direkt verwendet,
  müssen also nicht mehr dynamisch erzeugt werden und beinhalten auch keine virtuellen Funktionen mehr.
- Die systemspezifischen Implementationen werden von der Klasse FileImpl abgeleitet und kapsel sowohl die Datei- also auch
  die Verzeichnisoperationen ab. Ein FileObject erzeugt eine Instanz einer von FileImpl abgeleiteten Klasse und verwendet
  diese.
- Das Auflisten/Suchen von Dateien wird wie bisher über eine eigene Klasse gehandhabt, wobei SearchHandle in FileSearch
  umbenannt wurde. Diese Klasse verwendet ebenfalls das Backend-Schema, zu einer Instanz von FileSearch gehört daher
  immer eine systemspezifische Implementation welche von FileSearchImpl abgeleitet ist.
- Alle Dateifunktionen sollen über die Klassen FileObject/File/Directory zu verwenden sein, z.B. auch das Erstellen
  neuer Dateien oder Verzeichnisse ebenso wie das Löschen. Dies sollte einfacher zu verwenden sein als vorher, wo manche
  Funktionen nur über das globale Filesystem-Interface ausgeführt werden konnten.



>> 12.11.2007
[SB]
- Rewrite begonnen. Ziel ist es, die Basisklassen deutlich zu vereinfachen und zu verschlanken, wobei folgende Ziele
  verfolgt werden:
  * Alle Klassen sollten möglichst direkt instanziiert werden können, damit es dem Programmierer frei steht, ob er eine
    Klasse direkt verwendet oder dynamisch erzeugt, was auch eine effizientere Nutzung ermöglicht. Es sollte daher nicht mehr,
  wie bisher, eine dynamische Erzeugung von Objekten erzwungen werden, da dies auch die Problematik der späteren
  Speicherfreigabe beinhaltet und generell komplizierter in der Verwendung ist.
  * Möglichst keine globalen Manager mehr, welche alle Instanzen einer oder mehrerer Klassen verwalten. Dies ist zwar manchmal
    sinnvoll (z.B. für Ressourcenmanager), aber oftmal auch komplett unnötig (z.B. Dateisystem, Systemklassen allgemein).
  * Die Basisklassen sollten möglichst schlank sein, also direkt möglichst einfach zu verwenden sein und dabei möglichst
    wenig Overhead erzeugen. Dies bedeutet vor allem, dass die Basisklassen vom RTTI unabhängig sein sollen und
    daher deutlich von den RTTI Klassen getrennt werden, diese arbeiten dann auf einer höheren Ebene über den Basisklassen.     
- Ausserdem werde ich versuchen, folgende Konventionen einzuhalten:
  * Keine Verschachtelung mehr von Unterverzeichnissen, da dies eher wieder unübersichtlicher wird als übersichtlicher. Also
    wird es z.B. nur noch das Verzeichnis FileSystem geben, darin jedoch keine weiteren Unverzeichnisse für Zip, Win32, Linux etc.    
  * Das Backend-Prinzip wird konsequent umgesetzt, also überall dort, wo es Systemspezifische Implementationen gibt, wird
    es nach aussen eine Systemunabhängige Klasse geben, welche die Details über eine systemspezifische Implementationsklasse
    abkapselt (1:1-Beziehung). Dieses Vorgehen bringt am wenigsten Probleme mit sich und ist sehr flexibel und ist daher besser,
  als z.B. direkt die Systemspezifischen Klassen abzuleiten (zumal dies nicht damit vereinbar ist, die Klasse direkt zu
  instanziieren).



>> 23.10.2007
[SB]
- Definition von _CRT_SECURE_NO_DEPRECATE in CMakeLists.txt hinzugefügt. Dabei ist mir aufgefallen, dass im VC-Projekt
  diese Definition nicht auf die übliche Weise unter "Präprozessordefinitionen" hinzugefügt wird, sondern per
  "zusätzliche Optionen" der Kommandozeile. Habe das mal geändert, da ich keinen Grund sehe das hier anders zu machen
  als bei den sonstigen Definitionen und man so nur unnötig suchen muss.



>> 20.10.2007
[SB]
- zlib.dll auch aus den Installationsanweisungen in der CMake-Datei entfernt.



>> 19.10.2007
[CO]
- zlib wird im VC8 Projekt nun genauso wie in der CMake-Datei statisch eingebunden. 'zlib.dll' aus dem Runtime-Ordner gelöscht.



>> 13.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefügt
- Einige '#define' entfernt
- Ein paar Absätze eingefügt



>> 07.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefügt um dem Compiler das Leben etwas einfacher zu machen und möglichen unerwünschten Manipulationen
  vorzubeugen
- Dort wo es problemlos möglich war machte ich beim Speichern das zu speichernde Objekt Konstant. Bei ein paar Loadern wie z.B.
  Mesh Loadern ist dies leider nicht möglich da Index Buffer beim Lock verändert werden.
PLGeneral:
- String(const Variant &cVariant) entfernt da überflüssig, da nutzt man lieber Variant::GetString() :D
- Variant: Entfernte alle 'char*'-Funktionen da intern sowieso als 'String' gespeichert wird und man es daher gleich auch
  so übergeben kann ohne das es einen wirklichen Unterschied macht. Die 'GetString()'-Funktion erzeugt nun auch gleich den
  String und gibt diesen zurück ohne das dieser eventuell in 'm_sString' gespeichert wird... das macht die Sache zwar langsamer
  wenn öfters diese Funktion hintereinander aufgerufen wird - allerdings hat diese Funktion wirklich konstant zu sein.
- Parameters::GetParams() entfernt da dies einen Iterator zurückgab über den man die Variablen hätte verändern können +
  diese Funktion wurde nirgends verwendet.



>> 17.09.2007
[CO]
- Nahm das aktuelle Experimentelle Error System heraus da dies erstmal wohl nicht weiterverfolgt wird. Hab dafür im
  lab-Repository ein entsprechendes Projekt mit diesem System angelegt.
- Entfernte nach Rücksprache mit Stefan 'PLBool'. Wir wollten zwar das noch solange drinnen lassen bis die Sache wie/ob
  wir ein 'Error System' implementieren geklärt ist - allerdings ist es nicht abzusehen ob/wann das gemacht wird. Darum
  kommt das nun raus damit die Codes nicht mehr ganz so unfertig/höchst Experimentell wirken. Sollte man dann irgendwann
  ein 'Error System' haben, müsste man eh nochmal alles im Detail durchgehen.
  Das war nun zwar wieder einiges an Fleißarbeit, aber so isses wieder viel besser da übersichtlicher + weniger Overhead...
  die einzelnen dll's sind gleich um ein paar KB (eine davon sogar um 30! :) kleiner geworden. *g*



>> 15.09.2007
[CO]
- XML-Klassen: Die Konstruktoren noch etwas aufgeräumt - keine Ahnung wieso ich das damals so umständlich machte. 'void *'
  hab ich allerdings als Parameter gelassen, man 'könnte' zwar eine direkte Referenz auf das TinyXml Objekt übergeben, aber
  dann 'müsste' diese TinyXml Klasse als 'Predefinition' in unseren XML-Headern stehen... und das will ich nicht. :D
  Nur die 'XmlDocument' Klassen Dokumentation weist darauf hin das intern TinyXml verwendet wird, ansonnsten sollte das wie
  gehabt absolut verborgen bleiben WIE das Implementiert ist.
- CmdLineParser nochmal etwas aufgeräumt



>> 14.09.2007
[CO]
- Element & Resource: 'Delete()'-Funktion liefert als Rückgabewert nun ob alles gut ging oder ein Fehler auftrat



>> 13.09.2007
[CO]
- Da ich in Jens 'Kabiene'-Szene hin und wieder recht heftige stocker habe wenn ich einen neuen Raum betrete (wie es aussieht
  muss die GPU viele Textur Daten umschaufeln) das dazu führt das alles kurz 'einfriert' und ich danach weit außerhalb der
  Szene bin, versuchte ich solche unregelmäßigkeiten im Timing etwas zu Kompensieren.
  In 'Timing::Update()' wird die Änderung des Zeit unterschiedes mit dem des letzten Frames verglichen und wenn diese Werte
  ZU stark voneinander abweichen wird hier 'geglättet'. Über die neue Funktion 'GetTimeDifferenceNoCompensating()' kann
  man sich den 'wirklichen' Zeit unterschied ohne 'Korrekturen' zurückgeben lassen um z.B. feststellen zu können ob
  unregelmäßigkeiten auftraten.



>> 08.09.2007
[CO]
- DirectoryZip::SearchCentralDir() vereinfacht, der Zwischenbuffer liegt nun direkt auf dem Runtime-Stack
- DirectoryZip::OpenObject(): Der verwendete ZIP-Iterator liegt nun direkt auf dem Runtime-Stack



>> 24.08.2007
[CO]
- SystemWin32::ErrorCodeToString() statisch gemacht da man wirklich keine Instanz der System Klasse dafür braucht
- DynLibWin32::Load(): Gibt nun über 'SystemWin32::ErrorCodeToString()' eine Fehlerbeschreibung aus
- Localization::SetLanguage(): Nahm hier das [TODO] raus. Diese Funktion setzt wirklich nur einen String, für das Laden
  der konkreten Sprachen ist die jeweilige Implementation selbst verantwortlich. Generell wird die Sprache am besten NUR
  beim Programm-Start gesetzt und geladen, denn das jederzeit ändern zu können wäre ziemlich Tricky... denn man müsste dann
  irgendwie ALLES Informatieren das sich die Sprache geändert hat, alle Strings in allen Programmteilen müssten sich updaten
  etc. - sehr viel sehr unschöne Arbeit für wenig Nutzen. Das sparen wir uns lieber und gehen den einfachen Weg. :D



>> 22.08.2007
[CO]
- Machte ein paar Änderungen an der Time-Klasse:
  - Ein paar statische Zeiten spendiert, 'Null' wird z.B. in PLNetworkIRC::IRCConnection::ProcessServerMessage()
    verwendet.
  - Fügte eine Funktion Namens 'ToString()' hinzu über die man sich eine String Repräsentation der Zeit zurückgeben lassen kann.
  - m_nDay in m_nDayOfMonth + die entsprechenen Funktionen umbenannt damit eindeutig ist WAS das ist
  - 'EMonth' fängt nun wie EDay bei 0 (wie bei Linux und nicht wie bei Win32 SYSTEMTIME) an damit das einheitlich ist + man
    sich direkt die in ToString() verwendete String Representation des Monats/Tages über ShortMonthName[Month] bzw. ShortDayName[Day]
    zurückgeben lassen kann.
  - Einfache vergleichs-Operatoren hinzugefügt.
  - Funktion IsLeapYear()' hinzugefügt die ermittelt ob ein gegebenes Jahr ein Schaltjahr ist oder nicht.
  - Funktion 'SetUnixDate()' hinzugefügt.
  - Funktion CalculateDayOfWeek()' hinzugefügt die den Wochentag berechnent auf den ein Datum fällt. SetDOSDate() nutzt
    diese Funktion.
  - 'Unkown' aus 'EDay' entfernt da man sich diese Information nun berechnen lassen kann wenn man diese nicht direkt hat.



>> 21.08.2007
[CO]
- "NoMemoryManager.h" entfernt da wir das derzeit so nicht brauchen da wir keine Memory-Makros nutzen
- Konnte in "Checksum::Get(const String &sClass, File &cFile, PLResult *pResult)" das [TODO] entfernen da es mittlerweile
  möglich ist zu prüfen ob man aus einer Datei lesen kann.



>> 07.08.2007
[CO]
- FSTools: ValidatePath(): War leider etwas Problematisch da man nicht genau wusste ob nun am ende ein '/' eingefügt werden
  sollte oder nicht. Darum zerlegte ich diese Funktion in zwei Funktionen:
  - Einmal ValidateFilePath() welche einen Dateinamen korrekt macht
  - Und ValidateDirectoryPath() welche auf ValidateFilePath() aufbaut + sicherstellt das am Ende ein '/' ist
  -> Gefällt mir zwar nicht wirklich gut, alledings wüsste ich nicht wie man das anderst handhaben sollte... der User MUSS
     wissen WAS dieser 'Pfad' Darstellt, darum muss er uns das auch mitteilen damit man nicht irgendetwas falsches annimmt.
     "C:/MyDirectory/Test" könnte ein Verzeichniss sein, aber auch eine Datei ohne Dateiendung, darum MÜSSEN Verzeichnisse
     bei uns ausdrücklich mit '/' am Ende gekennzeichnet werden damit keine Mehrdeutigkeiten vorhanden sind. Allmählich fände
     ich es irgendwie erleichternd wenn wir überall bei Datei/Verzeichniss Namen die 'Url'-Klasse nehmen würden - das würde an
     vielen  Stellen einiges einfacher machen da man nicht mehr irgendeinen Mehrdeutigen Schrott übergeben bekommen kann.
     Derzeit sind an vielen Stellen immer ähnliche Abfragen, und an ein paar Stellen auch nicht wo es dann schnell mal zu
     Problemen kommen kann. :(
  -> Auf jedenfall sind sind nun keine FS Basis Pfade mehr 'doppelt' eingetragen (dort kam gerade durch eventuell fehlende
     '/' einiges durcheinander)



>> 03.08.2007
[CO]
Allgemein:
- Nahm überall
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginSet,  true);
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginMode, PLGraphics::Image::Origin_UpperLeft);
  vor dem Laden von Bildern raus - diese Einstellungen sind/waren bei uns bereits Default, und innerhalb von PL sollte da
  auch nix umgestellt werden. (0, 0) ist bei uns also überall 'links oben'. (u.a. DirectX nutzt diese Regel) Texturen die
  der GPU übergeben werden nutzen bis jetzt "(0, 0) ist links unten". (wie in OpenGL) Bis jetzt war das 'nur' inkonsistent,
  aber da wir nun verstärkt dds nutzen (um die Textur Massen halbwechs bewältigen zu können) zeigte sich das dies hier sehr
  unhandlich ist da dds von DirectX kommt. Zwar passt DevIL immer braf 'oben/unten' für uns an, aber bei den DXTC Daten die
  wir, wenn verfügbar direkt zur GPU jagen, wird nix verändert. (war auch wenig Sinnvoll wäre da man sich dadurch wieder
  den Geschwindigkeitsvorteil kaputt machen würde :)
  Dadurch hatte man dann 'geflippte' Texturen. Darum nun dieses Änderung, damit das zum einen bei uns einheitlich wird +
  das man die Vorteile die dds bietet richtig nutzen kann.
  Musste nun zwar sorfältig prüfen wo z.B. Textur Koordinaten verwendet werden und dort über "1-y" vertauschen, oder "1-y"
  rausnehmen wo nun nicht mehr vertauscht wird - aber das lohnte defintiv. Endlich ist da Ordnung drinnen und in
  PLMesh::Texture::Load() konnte ich nun endlich einen doofen Hack rausnehmen der sowieso nicht zu 100% funktionierte.
  (über dieses 'flip'-Problemchen stolperte ich schon früher im Zusammenspiel mit cube dds Texturen)
- Stellte überall wo möglich/sinnig Texturen auf das dds-Format um. (Texturen != OS Gui Bitmaps, da macht das natürlich weniger
  Sinn da man dadurch keine Vorteile hat :)
-> Es wird sicherlich noch einige Tage dauern bis ich 'soweit alle' Stellen angepasst habe die von diesen Änderungen betroffen
   sind. Aber im großen und ganzen geht alles wieder wie vorher - nur halt flotter zu laden + Grafiker haben direkt selbst
   Kontrolle über die MipMaps und was genau für Kompression verwendet werden soll. :D
   (ohne dds geht das im Grunde nur automatisch -> man hat weniger Kontrolle)



>> 02.08.2007
[CO]
Allgemein:
- Alle Doxygen Konfigurations-Dateien über "doxygen -u" auf den neusten Stand gebracht
- Machte bei allen Loadern alle Funktionen const. Da es von diesen Loader Klassen jeweils nur eine globale Instanz gibt darf
  keine der Funktionen etwas an diesen Objekten ändern oder man bekommt spätestens bei Multi-Threading probleme. Ein paar
  wenige Loader nutzen nun einfach 'pro Instanz'-Daten.



>> 01.08.2007
[CO]
- 'SearchHandleZip' hatte nicht das gleiche Verhalten wie die anderen Implementationen die zuerst '.', anschließend '..' und
  erst dann die 'richtigen' Dateien auflistet... das viel in 'PLSceneViewer.exe' auf wenn man im Datei-Dialog in ein
  'zip-Verzeichniss' wechselte, aber keine '..' mehr da waren zum zurück gehen.



>> 30.07.2007
[CO]
- Loadable: Merkt sich nun auch den 'original' Dateinamen der zum Laden verwendet wurde
- LoadableType::AddLoader: Wenn ein Format bereits im Manager durch einen anderen Loader eingetragen wurde so ist das kein
  Fehler, sondern heist nur das man nicht eindeutig über die Dateiendung rausbekommen kann welcher Loader für dieses Format
  zuständig ist. Dies ist allerdings KEIN Problem da sowieso immer bekannt sein sollte WAS man denn eigentlich laden will,
  also obs ein Mesh, eine Scene etc. ist. Das DirectX Format kann z.B. als Mesh verwendet werden, aber da es sehr flexibel
  erweiterbar ist + Hierarische Strukturen hat kann es genauso auch als Scene genutzt werden.
  Was allerdings auch vorkommen kann ist, das z.B. zwei verschiedene Mesh Formate die gleiche Dateiendung haben, ja eventuell
  sogar im Grunde das gleiche Format sind, aber unterschiedliche Versionen davon. Derzeit wird soetwas noch nicht Unterstützt,
  müsste sich später aber erweitern lassen... macht die Sache allerdings bestimmt nicht einfacher oder übersichtlicher. *g*
- Nahm die String Duplizierung aus Loadable::Reload() heraus, in Loadable::Load() ist nun ein universellerer 'Sicherheits'
  Test drinnen



>> 22.07.2007
[CO]
- 'Function': Machte den Konstruktor protected und Dokumentierte kräftig da ich gerade ein paar Stunden damit verbrachte
  rauszubekommen was 'genau' (hatte vorher nur eine sehr grobe Vorstellung) das ist bzw. wie man es verwendet. In PLBaseTest
  gibts nun einige Tests für diese Funktionalität... anhand dieser Tests hab ich mich an die Sache rangetastet - Stefan,
  gib mir irgendwann bitte bescheit ob ich das soweit richtig verstanden habe und es auch wie vorgesehen nutze. :)
  Die Investierte Zeit hat sich auf jedenfall gelohnt, denn nun versteh ich was da abläuft - wirklich eine sseeehr feine
  Sache. :)
- Container-Klassen abermals durchgeschaut und kleinigkeiten verbessert



>> 21.07.2007
[CO]
Alle Projekte:
- Die paar 'realloc' welche noch verwendet wurden durch 'MemoryManager::Reallocator()' ersetzt + stellen an denen noch z.B.
  'memcpy' verwendet wurde ebenfalls umgestellt damit wirklich alles über den Memory Manager läuft. Das mag zwar auf den
  ersten (und eventuell zweiten und dritten und... *g*) Blick 'extrem' erscheinen, hat aber durchaus so seine Vortelle da
  alles eine 'Zentralverwaltung' passiert. (...big brother is watching you...)
PLGeneral:
- SystemWin32: Erste Öffentliche Funktion eingebaut: ErrorCodeToString(): Wandelt einen Win32 Fehler Code den man über
  GetLastError() erhalten hat in einen PL-String den man dann z.B. direkt ins Log schreiben kann... das hatte ich vor einiger
  Zeit schonmal irgendwo lokal reingehackt als ich mir beim Debuggen Win32 Fehler als String zurückgeben lies.
  In SystemLinux hab ich soetwas nicht eingebaut da es unter Linux eine Funktion namens 'strerror' gibt die sich sehr leicht
  weiternutzen lässt.
- System: Neue Funktion: IsLittleEndian(): Damit kann man feststellen welche Byte-Reihenfolge die aktuelle Maschine für
  größere primitive Datentypen verwendet. Zukünftig können wir diese Funktion nutzen um zu entscheiden wie man z.B. ein
  'float' in eine Binär Datei schreiben oder auslesen muss. Das bringt allerdings erst 'wirklich' etwas sobald wir nicht mehr
  wie momentan direkt über die Write/Read-Funktionen der File-Klasse diese Daten schreiben/lesen... da muss dann ein kleiner
  Wrapper her damit wir 'wirklich' Plattform unabhängig werden, also auch damit klarkommen wenn die Byte-Reihenfolge anderst
  herum ist. :)
  Ich habe die Funktion 'IsLittleEndian()' und nicht 'IsBigEndian()' genannt da wir derzeit eigentlich nur auf Little-Endian
  Geräten arbeiten und ich denke auch diese Anordnung in unseren Binär Formaten behalten werden - der Funktionsname deutet
  also so bereits an mit welcher Anordnung PL 'intern' arbeitet.
- Nahm die auskommentierten Memory-Makros aus 'MemoryManager.h' nun komplett raus da wir das denk ich mal so nicht nutzen
  werden da es einfach 'unschön' und fehleranfällig ist - es wäre einfach nur doof 'überall' 'MemoryManager.h' einbinden zu
  müssen nur damit die Makros 'wirksam' werden. Wenn man brav mit new/delete arbeitet braucht man das auch nicht wirklich.



>> 19.07.2007
[CO]
Alle Projekte:
- Wenn über new Instanzen von Klassen erzeugt werden, aber dem Konstruktor nix übergeben wird, war die Schreibweise nicht
  einheitlich. Überwiegend hatten wir z.B. "new MyClass()" -> also mit "()" am Ende. So sieht man im Grunde sehr häufig,
  und mittlerweile bin ich diese Schreibweise auch durch Jave gewohnt. Daher änderte ich das entsprechend. (aber nicht
  wenn z.B. Primitive Datentypen oder Strukturen erzeugt werden... das kommt mir da etwas merkwürdig vor und das sieht
  man auch praktisch nie so geschrieben :)
PLGeneral:
- Fand noch zwei Stellen wo ich sehr einfach malloc/free durch new/delete ersetzen konnte. Wo immer möglich (also praktisch
  überall :) sollte man lieber new statt malloc etc. nutzen - dadurch braucht man sich dann auch keine Sorgen zu machen 'wo'
  bzw. 'wer' den Speicher anlegt. 'new' lässt sich ja sehr einfach überladen was auch bereits gemacht wird... aber 'malloc' &
  CO kann man nicht wirklich überladen. Zwar könnte man ein Makro schreiben, (was ich zum probieren auch machte :) das führt
  allerdings dann zu mehr Problemen (teils sogar zu Compiler fehler in Third-Party libs) als es Nutzen bringt.
  An ein paar Stellen wird noch realloc genutzt, diese Stellen werde ich bei Zeiten noch ändern damit wir in PL wirklich
  nur new/delete nutzen um möglichen Problemen der Speicherverwaltung gleich von Anfang an aus dem Weg zu gehen.
  (man muss soetwas ja nicht provozieren :)



>> 08.07.2007
[CO]
Alle Projekte:
- Entfernte einige &<Name>[0] da & und [0] automatisch vom Compiler hinzugefügt wird und das ohne besser Lesbar ist :)
PLGeneral:
- Fügte ein paar  #error "Unsupported platform"  ein (z.B. in SystemImpl.cpp)



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der FS Implementationen folgten nicht der Benennung der anderen PL Dateien



>> 24.06.2007
[CO]
Alle Projekte:
- Merkte gerade das in den meisten Dateien der inline Implementationen z.B.
    #ifndef __PLRENDERER_SHADERCGBACKEND_INL__
    #define __PLRENDERER_SHADERCGBACKEND_INL__
  etc. steht, also wie bei den Headern. Dies ist hier allerdings völlig überflüssig da diese Dateien NUR von den jeweiligen
  Headern selbst eingebunden werden dürfen und dort bereits im 'geschützten'-Teil liegen. (dem Compiler unnötige Arbeit
  sparen iss immer ne gute Sache, auch wenn das absolut nicht ins Gewicht fällt *g*)
PLGeneral:
- 'PL_F2DW()' und 'PL_DW2F()' aus 'PLRenderer/Types.h' entfernt und in 'PLGeneral/Tools/Tools.h' als FloatToUInt32() und
  UInt32FloatTo() eingefügt. Zum einen fand ich es schon lange nicht mehr sonderlich prall das diese zwei Funktionen (früher
  Makros :) so lieblos irgendwo in der Gegend herumstehen + die Namen selbst waren nicht mehr ganz korrekt und nicht
  sonderlich aussagekräftig.



>> 23.06.2007
[CO]
Alle Projekte:
- Verbesserte an einigen Stellen groß/kleinschreibung. Wenn z.B. mit 'windows' das Betriebssystem und nicht etwa 'GUI Fenster'
  gemeint sind sollte das 'Windows' geschrieben werden da Name. 'win32' konsequent zu 'Win32' gemacht. 'linux' ist ebenfalls
  ein Name, also 'Linux'.
- Bei 'Abkürzungen' wurde so richtig wild gemischt und ich selbst war auch immer sehr unsicher 'wie' man das nun 'überlicherweise'
  schreibt. Da wollte ich schon lange mal was machen damit das halbwechs konsequent ist. Daher googelte ich erstmal etwas +
  informierte mich auf Wikipedia wie man üblicherweise diverse Dinge schreibt. Danach änderte ich u.a. 'url/Url' -> 'URL',
  'xml/Xml' -> 'XML', 'html/Html' -> 'HTML', 'zip/Zip' -> 'ZIP', 'gui/Gui' -> 'GUI' (bis auf die Dateiendung 'gui') - nur in den
  Dateinamen änderte ich erstmal nix da dies die Lesbarkeit etwas verschlechtert - da können wir uns später überlegen ob wir das
  so lassen, oder ob wir das überall durchwech konsequent schreiben wollen damit keine Unklarkeiten reinkommen. Das alles könnte man
  natürlich als 'belanglose fusselei' abtun... allerdings empfinde ich soetwas als wichtig da es gerade in der Informatik mittlerweile
  sooo viele Abkürzungen gibt und ich es auch in Mathematik höchst verwirrend und störend empfinde wenn ein und dieselbse Sache
  immer wieder etwas anderst geschrieben wird - das hilft definitiv nicht Anfängern sich in die Materie einzuarbeiten! :(
  Zudem ist PixelLight generell 'case-sensitive' so das wir da (vorallem den Grafikern *g*) mit gutem Vorbild vorausgehen sollten.
PLGeneral:
- FileSystem vom Style und der Ordnung her aktualsiert. Also Dinge privat gemacht die privat zu sein haben, Konkrete
  Implementationen werden wo das nicht benötigt wird oder wünschenswert ist nicht Exportiert. Wo möglich Zeiger zu Referenzen
  gemacht damit man den NULL-Fall nicht berücksichten muss. Einige Kommentare verbessert oder genauer gemacht. Einige short
  zu int16 und long zu int32 (+ unsigned Variationen) gemacht damit das in PL überall gleich ist + das ist deutlich besser
  lesbar + man weis wirklich ganz genau was das für größen zu sein haben.
- Bei der File-Klasse ein 'IsReadable()' hinzugefügt. Dies wurde bereits im Loadable-System benötigt + ist das passende
  Gegenstück zu 'IsWritable()'
- LogFormater Implementationen umbenannt da diese nicht dem PL Namens Style folgten und es mich auch schon mehrmals störte
  das ich erstmal kurz die einzelnen Implementationen zusammensuchen musste - durch die Namens-Änderung sind diese Dateien
  wenn man Alphabetisch Ordnen lässt immer nett beisammen was enorm Handlich ist.
- BufferedReader Implementationen umbenannt da diese nicht dem PL Namens Style folgten
- CMakeLists.txt: LogFormaterConsole.cpp fehlte
- 'PLEFileSeek' von FileSystem.h in die File-Klasse verschoben und in 'ESeek' umbenannt. 'PLEFileAccess' von FileSystem.h
  in die File-Klasse verschoben und in 'EAccess' umbenannt. Dadurch konnte man auch gleich wieder Header abhänigkeiten
  reduzieren. :)
- FileSystem: GetRootDirectory() und GetCurrentDirectory() liefern nun Referencen statt Zeiger zurück denn diese Dinge
  MÜSSEN immer gültig sein... ansonnsten läuft gerade etwas soetwas von total daneben. Durch diese Änderung wird an einigen
  Stellen der Code nun etwas Übersichtlicher da man keine NULL-Abfragen mehr machen muss/sollte.
- FileSystem: GetCurrentDirectory() fügt nicht mehr automatisch eine Referenz zum aktuellen Verzeichniss hinzu



>> 22.06.2007
[CO]
- Entfernte aus Timing die Funktionen Start(), Stop() und GetEllapsedTime() und führte eine neue Klasse Namens 'Stopwatch'
  ein welche diese Funktionalität bereitstellt. Stellte gleich eine Handvoll Stellen in verschiedenen Projekten auf diese
  neue Klasse um - das ist wirklich sehr Handlich. :)
- Time um SetDosDate()-Funktion aus ZipDate erweitert und ZipDate anschließend entfernt da doppelte Funktionalität



>> 16.06.2007
[CO]
Alle Projekte:
- Entfernte bei allen virtuellen und nicht Implementierten Funktionen (=0) das Export Makro da in diesen Fällen nicht benötigt
PLGeneral:
- 'PL_UNUSED'-Makro entfernt da dieses mittlerweile gerade im Zusammenhang mit ungenutzten Referenzen wo man dann zwanghaft
  Header einbinden muss obwohl nix benötigt wird sehr unhandlich wird - zudem wollte Stefan das sowieso vor einigen Montaten
  raushaben. :)
  Das war eine Zeitlang recht nett dieses Makro um überall zu checken ob Parameter überhaupt benötigt werden bzw. korrekt
  genutzt werden, mittlerweile ist das aber nicht mehr wirklich nötig. Die 'nicht verwendet' Warnung erscheint üblicherweise
  nur in der allerhöchsten Warn-Stufe, wenn das jemand aktiv haben will, muss er es für sein Projekt wieder per Hand aktivieren.



>> 12.06.2007
[CO]
- Sleep() von der System Klasse in ThreadManager verschoben da dies dort Thematisch besser reinpasst (der aktuelle aktive
  Thread wird schlafen gelegt...)



>> 09.06.2007
[CO]
- MemoryCopy() & MemorySet() & MemoryCompare() aus Wrapper.h in MemoryManager.h verschoben, das ist dort denke ich recht
  gut aufgehoben
- MemoryManager.h: Defines auskommentiert: Diese Definitionen sind leider recht problematisch und verursachen recht schnell
  Fehler in 'Fremd-Header'.



>> 08.06.2007
[CO]
- BufferedFileReader: Laut Konstruktor Dokumentation wird die übergebene Datei automatisch freigegeben, das war allerdings
  nicht der Fall wenn das Dateiende bereits erreicht war - vereinfachte/verallgemeinerte daher den Konstruktor etwas
- An einigen Stellen wo möglich/sinnig Zeiger durch Referenzen ersetzt. Uh, verstehe gar nicht wieso ich das früher noch
  nicht gesehen habe das es 'meistens' über Referenzen viel eleganter und sicherer geht da man den 'NULL'-Fall nicht
  berücksichtigen muss wenn er eigentlich gar nicht erst vorkommen sollte. :)
  Ist zwar einiges an Arbeit nun alle Codes/Interfaces nochmal genau durchzuschaun, aber es lohnt definitiv + nebenbei
  fallen mir auch noch immer einige andere Dinge auf die nicht mehr ganz Up-To-Date sind... ganz nebenbei stehen in ein paar
  Wochen bei mir mal wieder Prüfungen im Studium an und da sind solche Arbeiten genau das richtige da man das nebenbei
  machen kann ohne sich Gedanklich voll reinhängen zu müssen was zur Prüfungszeit weniger optimal ist.



>> 07.06.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'childs' in 'children' geändert (das war an einigen Stellen noch falsch :)
PLGeneral:
- XmlAttribute: QueryIntValue() & QueryDoubleValue() ändern den Wert der übergebenen Variable im Fehlerfall nicht, damit
  ist das Verhalten vergleichbar zu den ähnlichen Funktionen in XmlElement
PLNetwork:
- Wo möglich/sinnig Zeiger durch Referenzen ersetzt



>> 05.06.2007
[CO]
- Time für die Tage Enums spendiert
- Semaphore: m_nValue wurde nicht initialisiert (?)
- Thread::Thread(bool bMainThread): Hier wurden die Variablen nicht initialisiert



>> 29.05.2007
[CO]
- Erweiterte das Var-Interface etwas damit man besseren Zugriff auf die Enumeration-Daten hat



>> 26.05.2007
[CO]
- Das mischen von Debug/Release Builds gestern klappte nicht wirklich gut. Es gab merkwürdige Crashs etc. da beide Builds
  intern unterschiedliche VC Memory Manager nutzen die nicht wirklich kompatibel zueinander sind. Da ich das aber wirklich
  wirklich endlich mal sauber am laufen haben wollte befasste ich mich heute etwas mit der Speicherverwaltung. Heraus kam
  ein eigener minimal Memory Manager der im 'PLGeneral/Core'-Ordner liegt und der die C++ new/delete Operatoren 'überläd'.
  Solche Operationen werden nun direkt in unseren eigenen Memory Manager 'umgeleitet' der fürs erste nur malloc/free nutzt.
  Alles Speicher anlegen/freigeben findet nun also NUR noch innerhalb von PLGeneral statt und dadurch verschwinden diese
  merkwürdigen Speicherproblemen + wir haben viele weitere möglichkeiten wie Speicher-Statistiken, Sicherheits-Checks -
  oder das die Implementation einer komplett eigenen Speicher-Verwaltung!
  Der einzige Hacken bei der Sache ist, das jedes Projekt nun per Hand 'PLGeneral/Core/MemoryManager.inl' einmal irgendwo
  einbinden müsste damit diese Operatoren sauber überladen werden...
- Fügte einen Header Namens 'PLGeneral/ModuleMain.h' hinzu. Dieser ist das gegenstück von 'PLGeneral/Main.h' welches für
  Anwendungen verwendet wird. Verschob aus 'RTTIDefs.h' die paar Module-Makros in diese neue Datei - das sind Dinge die
  genauso wie in 'PLGeneral/Main.h' NUR einmal pro Projekt für den Einstiegspunkt benötigt werden. 'PLGeneral/Main.h'
  baut somit auf 'PLGeneral/ModuleMain.h' auf, welches wiederum 'RTTIDefs.h' nutzt - so müsste das recht Überschaubar sein.
  Ich muss allerdings zusgeben das 'Überschaubarkeit' nicht der eigentliche Grund für diese kleine Änderung war, sondern
  meine aktuellen arbeiten am Memory Manager. NUR einmal pro Projekt sollte 'PLGeneral/Core/MemoryManager.inl' eingebunden
  werden welches dann new/delete Operatoren mit PL eigenen Implementationen 'überschreibt'. Allerdings wollte ich das nicht
  jedesmal an zig verschiedene Stellen schreiben müssen da man es mal schnell vergisst und dann der Memory Manager nicht
  korrekt in diesen Modulen arbeiten kann. Daher wird dieser eine Header gleich automatisch in 'ModuleMain.h' eingebunden das
  so oder so genutzt wird - wenn man sich an die PL Richtlinen hält und 'PLMain' etc. nutzt... wer das nicht tut und meint
  er müsste selbst beim Einstiegspunkt herumwurschteln der muss sich halt auch selbst um andere Dinge kümmern. *g*
  Somit muss sich der User also überhaupt nicht um diese Speicher-Geschichte kümmern.
-> Als Folge dieser Änderungen ist das mischen von Release/Debug Builds nun endlich möglich. Da im Grunde im PL-SDK IMMER
   Release genutzt wird und mir die Plugin-Datei Änderungen von gestern nicht soo gut gefielen da es dadurch etwas
   unübersichtlich und unnötig aufwändig wird, machte ich diese Plugin-Datei Änderung wieder rückgängig... lies es aber
   hier im Diary stehen damit man nachlesen kann was wieso etc.
   Nutze ich die Release Versionen von PL kann ich aber immer noch mein eigenes Programm wie gehabt Debuggen - das klappt
   sogar mit Dll's. Natürlich kann man mit dem Debugger nicht in die PL Funktionen 'einsteigen', aber das würde sowieso nicht
   wirklich gehen da im SDK die cpp-Dateien von PL nicht liegen. :)
   Leider ist derzeit ein zu 100% mischen nicht möglich. Trage ich z.B. als Release Library eine Debug Version ein, wird
   die dll zwar ohne Crash etc. geladen, aber die RTTI Klassen werden nicht Regestriert... genau weis ich noch nicht was
   da im Detail abläuft. Aber das was mir wichtig war, also z.B. Debuggen einer dll im zusammenspiel mit einer release exe
   klappt ganz wunderbar.



>> 25.05.2007
[CO]
Alle Projekte:
- In den letzten Tagen lies ich in allen Projekten nach 'DEFINE_VAR_LIST' suchen und stellte sicher das die am RTTI
  hängenden Variablen direkt in der Konstruktor Initialisierer-Liste initialisiert werden.
PLGeneral:
- Base: CreateInstance(): 'bSetVars'-Parameter entfernt. Das kann man als User selbst nachträglich machen wenn man will -
  zudem würde das nicht Initialisieren nicht wirklich Sinn machen bzw. wäre höchst Gefährlich da man undefinierte Zustände
  hätte. (bzw. früher hatte) Generell sollten IMMER alle Klassen ihre Variablen selbstständig auf korrekte Default Werte
  setzen (also unabhängig ob diese am 'RTTI' eingehängt sind oder nicht) die mit den in den RTTI Makros angegeben Werten
  übereinstimmen. Gefällt mir zwar nicht wirklich dieses 'doppelte' reinschreiben von Default-Werten, wüsste aber momentan
  nicht wie man das anderst lösen sollte. Auf diese weise kann man u.a. bereits in den Klassen Konstruktoren diese Variablen
  nutzen was voher nicht so ohne weiteres möglich war da die Variablen erst 'nach' dem erzeugen auf die Default-Werte gesetzt
  wurden... das war eine sehr unglückliche Situation in die ich in den letzten Jahren natürlich immer mal wieder reinstolperte.
  'DEFINE_VAR_RO' ging früher nicht korrekt da SetVars() genutzt wurde was dann natürlich das setzen der 'read-only'
  Variablen zu verhindern weis.
  Auch war das Initialisieren von am RTTI hängenden Variablen in der Initialisierer-Liste der Konstruktoren inkonsistent.
  Einmal wie z.B. in Vector3 wurde dort initialisiert da man diese auch ohne RTTI nutzen kann, und bei anderen Klassen wie
  z.B. SceneNode nicht da diese 'nur' über das RTTI Instanziert werden können.
  Zusammenfassend hat man mehr 'Sicherheit' da immer Variablen in bekannten Initialzuständen - da muss wie üblich natürlich
  JEDER Klassen-Schreiber dafür sorgen! CreateInstance() ist schlanker + weniger 'Overhead' beim erzeugen von Instanzen -
  da das RTTI System mittlerweile sehr intensiv genutzt wird ein sicherlich nicht ganz unerheblicher Faktor... wird z.B.
  eine *wirklich* große Szene mit mehreren tausend Nodes eingeladen spart man sich nicht gerade wenig Arbeit ein und auch
  wenn man mit dem Debugger Schrittweise den Code Analysiert ist das nun um einiges durchschaubarer.
  Hab mal noch kleine Performance Tests in 'PLSampleScene.exe' gemacht - größte Szene (F3) die 4098 Nodes hat, aber nur
  'sehr' wenig verschiedene Daten nutzt und daher optimal für diesen Test ist: (jeweils zwei anläufe)
  - Vorher: 6.483 sec & 6.191 sec 
  - Nacher: 5.571 sec & 5.232 sec
  -> Also in dieser Szene mit 'etwas mehr' Nodes 'minimal' schneller, jedes bischn bringt uns weiter. :)
- Plugin XML Dateien: Ich überlegte mir bereits seit geraumer Zeit wie man das mit Debug/Release Builds 'mischen' am besten
  auf die Reihe bekommt - denn im öffentlichen PL-SDK liegen NUR Release Builds (bzw. sollten!) und trotzdem soll man auch
  seine auf PL aufbauenden Projekte korrekt Debuggen können. Wenn man die Debug Builds hat sollen diese auch genutzt werden
  können. Von 3ds Max hab ich auch 'nur' die Release Version, und kann trotzdem meine Exporter Plugins dafür korrekt Debuggen,
  also irgendwie ist das sauber realisierbar. :)
  Schlägt das einladen einer 'Library' fehl, so können nun alternative 'Fallback Libraries' verwendet werden. Konkret ist
  das bei Debug-Libraries sinnvoll. Im öffentlichen PL-SDK sind üblicherweise keine Debug Versionen von PixelLight dabei,
  folglich schlägt der Versuch diese zu laden fehl - als Fallback wird nun versucht die entsprechende Release Library zu
  laden. Hat man also die Debug Version (warum auch immer *g*) wird diese korrekt genutzt, ansonnsten die Release Version.
  Als 'normaler PL-User' bin ich aber denk ich ganz froh die Release-Builds von PL beim Debuggen nutzen zu können, denn
  diese sind um einiges (!!) flotter und so kann man sich recht gut auf das Debuggen seines eigenen Projektes konzentrieren.
  Somit kann man problemlos und ich denke mal recht Intuitiv Release & Debug Builds mischen - das Plugin System über diese
  XML Dateien müsste nun soweit alles können das wir derzeit brauchen.
  Nahm den Parameter der 'PLGetPluginInfo'-Funktion im 'DEFINE_MODULE_PLUGIN'-Makro heraus und fügte dafür eine weitere Funktion
  namens 'PLIsPluginDebugBuild' hinzu über die ermittelt werden kann ob das Plugin als Release oder Debug übersetzt wurde.
  ClassManager::LoadPlugin() kann dann auf wunsch einen Build Type Test erzwingen so das NUR zusammen passende Builds verwendet
  werden können - als Default ist dies allerdings deaktiviert da dies normalerweise nicht nötig/üblich ist bzw. sein sollte.



>> 22.05.2007
[CO]
- Bugfix: Class::GetVar(): Meine Änderung der Implementation vom 18.03.2007 war natürlich nicht ganz korrekt da nicht
  berücksichtigt wurde das es sehr wohl sein kann das die Variablen der Basis Klasse noch nicht Initialisiert sind - korrigiert.



>> 21.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'choosen' in 'chosen' geändert



>> 19.05.2007
[CO]
Alle Projekte:
- In Funktionen wo häufiger Instanzen von RTTI Klassen erzeugt werden und 'zur Sicherheit' geprüft wird ob die Basis Klasse
  korrekt ist machte ich eine kleine rein Funktions interne Optimierung:
  Statt Class::HasBaseClass(String) wird nun Class::HasBaseClass(Class) genutzt wodurch man sich HashMap Operationen spart
  und sofort immer einen korrekten Zeiger auf die Basis Klasse hat. (der IMMER korrekt ist da Kern-Komponenten!) Zusätzlich
  kann nun unsere String Klasse ihre Muskeln spielen lassen: Class::HasBaseClass(Class) nutzt intern String::Compare()...
  und hier muss dann am ende NUR noch ein einfacher Zeiger Test gemacht werden um festzustellen das die Basis Klasse gefunden
  wurde ohne die Strings selbst wirklich miteinander zu vergleichen - noch Effektiver gehts wohl kaum! *g*
  An Stellen wo teils nur ein einziges mal pro Programm start Class::HasBaseClass() verwendet wird lohnt soetwas natürlich
  nicht - aber bei z.B. PLEngine::SceneContainer::Create() ist das durchaus eine feine Sache.
PLGeneral:
- Loader: RTTI Variablen sind nun endlich 'read only'. Dies erreichte ich dadurch das nicht das RTTI die Variablen anfangs
  Initialisiert, sondern das die Variablen sauber wie man es gewohnt ist in der Initialisierer Liste der Konstruktoren
  initialisiert werden. Von Loader abgeleitete Klassen 'überschreiben' indem diese den jeweiligen Konstruktoren entsprechend
  neue Werte übergeben - das ist so wirklich deutlich besser. :)
- HtmlLogFormater: Funktionen etwas umsortiert so das die Reihenfolge der Daten immer gleich ist
- Machte bei LogFormater Implementationen einiges 'private' da man nicht weiter davon ableiten können soll + ein paar
  öffenliche Funktonen wurden nicht exportiert



>> 17.05.2007
[CO]
- Stack & Queue: Pop(): Kommentar erweitert (für eine Situation wo man aufpassen sollte)



>> 15.05.2007
[CO]
- System::DeleteEnvironmentVariable() Implementation fehlte
- Bei den System-Klassen einige Dinge 'private' gemacht wo entweder nix von außen drauf zugreifen soll oder wo man nicht
  weiter Ableiten können soll
- Ein paar 'const' hinzugefügt
- Im Loadable System einige Zeiger zu Referenzen gemacht, so muss man bei den Kommentaren nicht mehr 'NEVER NULL!'
  dazuschreiben da es bereits von anfang an unmöglich ist NULL-Zeiger zu übergeben.



>> 12.05.2007
[CO]
- Class::GetBaseClasses() entfernt da es hierfür keine Implementation (mehr) gab (?)
- ClassManager::GetClasses() gibt keine Liste mehr zurück, sondern bekommt eine als Parameter übergeben. Zum einen ist
  das so nun konsistent mit z.B. Class::GetVarList(), aber noch viel wichtiger ist, das so herum nun nicht mehr aufwändig
  viel herumkopiert werden muss. Das gleiche in der Module Klasse.
- Var: Machte ein paar grundliegende Funktionen protected. NUR Class darf hier direkt drauf zugreifen, so ist gewährleistet
  das z.B. wirklich IMMER eine Variable zu einer Klasse gehört.
- Machte an den RTTI Klassen einige 'Sicherungs'-Maßnahmen indem ich einige Parameter & Funktionen const machte (an vielen
  Dingen hat der User einfach selbst nix zu ändern :) und dort wo
  man nicht 'umbedingt' einen Zeiger als Parameter übergeben muss wird nun stattdessen eine Referenz verwendet - denn die kann
  ja nie NULL werden und so kann der User schonmal weniger Schrott übergeben + man spart sich Sicherheits-Abfragen. (die teils
  nicht vorhanden waren)
- Durch die Änderungen kann man sich nun sogar in 'RTTIDefs.h' das Einbinden von 'Var.h' sparen :)



>> 11.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'socked' in 'socket' geändert
- Rechtschreib-Korrektur: 'terminal NULL', ich glaub damit meinte ich 'terminating zero' (jeder lacht aber keiner sagts :)
PLGeneral:
- String: In der Funktions-Beschreibung von GetLength() fehlte eine ganz entscheidende Information, 'terminating zero'
  ist in der Länge nicht enthalten. Überall anderst stand das bereits wenn ich nix übersehen hab.
PLNetwork:
- Im Server-Destruktor muss man noch zur Sicherheit 'StopHost()' aufrufen da dieser Aufruf vom Host-Destruktor aus
  dummerweise in der Host Implementation von StopHost() landet und daher wenns mal mies läuft nicht sauber aufgeräumt wird
- Im Destruktor von Socket() wird nun zur Sicherheit 'Close()' aufgerufen... etwas später nach merkwürdigen 'Problemen'
  merkte ich das ich nicht ganz verstanden hatte was bei Sockets abgeht. Natürlich darf man das hier NICHT automatisch
  schließen. Damit ich das nicht nochmal mache fügte ich ein entsprechendes Kommentar in diesem Destruktor ein. *g*
  Das gleiche in der Create()-Funktion wo es ebenfalls nicht angebracht ist automatisch Close() aufzurufen.
- Socket::Close() liefert nun anstatt 'int' ein 'bool' zurück welches nur angibt ob alles gut ging oder nicht, denn mit der
  Implementations abhängigen Fehler ID sollte der User nicht in Kontakt kommen bzw. er kann damit im allgemeinen nix
  anfangen da er nix von der konkreten Implementation weis. (bzw. wissen sollte *g*)
  Das gleiche beim Rückgabewert der Bind() und Listen() Funktionen.
- Socket::Create() gibt nun einen Fehler-Code zurück
- Socket::m_nSocket ist nun auf INVALID_SOCKET wenn 'ungültig'
- Connection::OnReceive(): Der übergebene Buffer mit den erhaltenen Daten ist nun 'const' da dieser Buffer selbst nicht
  direkt manipuliert werden 'sollte' (könnte wenns dumm läuft irgendwann mal unfeine Seiteneffekte erzeugen)
- Stellte auf PLBool um damit das erstmal Einheitlich ist
- Erweiterte die Kommentare so das möglichst keine Fragen mehr offen bleiben was z.B. Parameter machen/was zurückgegeben
  wird etc. Einiges muss man aber bei Zeiten auf jeden Fall noch genauer Beschreiben, vorallem ein paar kleine hintergrund
  Informationen.



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Einträge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Sortierte ins Diary alte Einträge aus "PLSDK/internal/old_diaries.zip" von ab "02.04.04" ein
- Neue abstrakte Basis-Klasse eingeführt: 'Iterable': Alles was einen Iterator Implementiert sollte von dieser Klasse
  abgeleitet sein. 'Map', 'Heap' und 'Container' sind somit nun also von 'Iterable' abgeleitet - so bekommt man eine noch
  etwas schickere und stimmigere Klassen-Hierarchie. :)



>> 21.04.2007
[CO]
PLNetwork:
- Socket::Recv() in Socket::Receive() umbenannt (man spart nicht wirklich was und muss sich nen kürzel merken)
- Klassen Beschreibungen anhand von Stefans Konzept vom 08.03.2007 hinzugefügt/erweitert



>> 20.04.2007
[CO]
- Timing::Update(): Auf PLBool umgestellt



>> 18.04.2007
[CO]
Alle Projekte:
- Nach kurzer Rücksprache mit Stefan gestern änderte ich (automatisch, also ') = NULL;' zu ') = 0;' gleiche mit const,
  ersetzen lassen, insgesammt an 688 Stellen + 1 wobei diese eine Stelle nur unglücklich Formatiert war so das man per Hand
  ranmusste :) alle z.B. 'virtual void Test() = NULL' in 'virtual void Test() = 0' da 'NULL' in OS-Headern leider nicht immer
  zwanghaft als '0' oder '(void*)0' definiert ist - unter Linux ist das schonmal als '__null' definiert und dann gibts
  Compiler Fehler im Zusammenspiel mit z.B. 'virtual Test() = NULL' und man muss dann immer genau nachprüfen wo/wie NULL in
  Headern einfach umdefiniert wurde das nicht wirklich die Übersichtlichkeit fördert. :(
  Neben diesen Compiler-Problemen war dies über 'NULL' auch hin und wieder etwas unhandlich wenn man wie in
  'PLGeneral::Iterator.h' eigentlich überhaupt kein Include benötigt, aber durch 'NULL' dann eben doch den PLGeneral-Header
  einbinden musste. Ich googelte etwas und schaute mir verschiedene C++ Codes durch, fand aber irgendwie nichts wo bei
  virtuellen-Funktionen 'NULL' statt '0' verwendet wurde. Wenn ich mich recht erinnere sah man das 'früher' häufiger,
  heute aber nicht mehr wirklich oft.
- Nahm '-U__GNUG__' Linux Compiler Definition aus allen CMake-Dateien heraus
PLNetwork:
- Sobald man in 'PLGeneralLinuxIncludes.h' das von z.B. 'gethostbyname' benötigte '#include <netdb.h>' einband bekam man
  in '/usr/include/netdb.h:661' einen merkwürdigen Compiler-Fehler.
  Stephan und ich fanden zusammen über herumstochern heraus das die Compiler Option '-U__GNUG__' dafür verantwortlich ist,
  nahm man diese jedoch heraus wurde 'NULL' zu '__null' umdefiniert und man bekam bei virtuellen-Funktionen Probleme wenn
  '= NULL' verwendet wurde, daher die '= NULL zu = 0'-Änderungen von oben. :)
- PLNetwork & PLNetworkIRC lassen sich nun auch unter Linux übersetzen



>> 14.04.2007
[CO]
- Base::SetVars() verbessert so das man z.B. auch 'Flags=""' in z.B. einer Szene-Datei schreiben kann ohne eine Fehlermeldung
  zu bekommen das ein abschließendes '"' fehlen würde
- Thread::Join() Kommentar etwas erweitert... wie ich gerade in PLPhysicsNewton::WorldThread::~WorldThread() feststellen
  musste ist ein 'join' ohne Timeout mit Vorsicht zu geniesen...



>> 09.04.2007
[CO]
- Nahm weitere 'return' heraus
PLNetwork:
- Nahm weitere 'return' heraus



>> 08.04.2007
[CO]
- Formte einge Codes um so das man weniger 'return' benötigt was die Sache etwas übersichtlicher macht
- ClassManager.cpp: 'NO_GROUP'-Definition entfernt da dies mittlerweile nicht mehr verwendet wird
- ZipSearchHandle::CheckFileInDirectory(): Hier wird nun 'm_pZipDir->m_bCaseSensitive' berücksichtigt
- ZipDirectory: Neue Funktion: IsCaseSensitive() wird von ZipSearchHandle::CheckFileInDirectory() benötigt
- Base::IsVarDefault(): Arbeitet nun Case-Sensitive da PL generell Case-Sensitive ist
PLNetwork:
- Formte einge Codes um so das man weniger 'return' benötigt was die Sache etwas übersichtlicher macht



>> 07.04.2007
[CO]
- Dort wo in der String Klasse 'isdigit()' oder 'isalpha()' verwendet wird, wird zur Sicherheit auf 'unsigned char' gecasted
  da man sonst schnell ein Assert bekommen kann wenn man z.B. 'ß' im String stehen hat. :(



>> 31.03.2007
[CO]
PLNetwork:
- Host::RemoveConnection(): Hm, hier fehlte das austragen der Connection aus der Liste (absicht?)
- OS/Standard-Header werden nun nur noch in den Implementationen eingebunden
- Ein paar Sicherheits-Tests in 'Socket'-Klasse eingebaut
- Globale 'Initialize()'-Funktion entfernt da es etwas unhandlich ist das Manuell aufzurufen. Das läuft nun wie bei Image
  über einen globalen Guard.



>> 29.03.2007
[CO]
PLNetwork:
- Einige einfache Stellen auf unsere String-Klasse umgestellt
- Connection: SendMsg() ist durch unsere String Klasse nun überflüssig
- Connection: In Send() gabs wenn ich das richtig sah ein Speicherleck da der Daten-Speicher nicht wieder freigegeben wurde
  - durch die String Klasse natürlich nun kein Thema mehr :)



>> 27.03.2007
[CO]
- Linux Port etwas aufgeräumt



>> 25.03.2007
[CO]
- Types.h entfernt. Überall wo X, Y, Z, W genutzt wurde durch entsprechende Vektor-Enums ersetzt damit man weiterhin sofort
  erkennen kann welche Komponente verändert wird. R, G, B wurde nur an einer einzigen Stelle verwendet. PL_UNUSED-Makro
  in die OS-Header verschoben.
- NULL-Definition in die OS-Header verschoben



>> 24.03.2007
[CO]
Alle Projekte: Alle CMake Dateien:
- Einige Leerzeichen/Tab Änderungen in den CMake Dateien
PLGeneral:
- System: Neue Funktion: GetPlatform(): Diese Funktion gibt im Gegensatz zu GetOS() nur einen übergeordneten Plattform
  Namen wie z.B. 'Win32' für ein 32 Bit Windows System etc. zurück
- Xml Plugin Format nach Stefans Vorschlägen vom 25.02.2007 geändert. Es gibt nur noch eine Plugin Datei und keine für
  Release und Debug. In der Datei kann es beliebig viele 'Platform'-Blöcke geben, jedoch werden nur die berücksichtigt
  welche mit System::GetPlatform() zusammenpassen. (daher diese neue Funktion :) Innerhalb eines 'Platform'-Blockes kann
  es verschiedene 'Library'-Einträge geben welche jeweils einen Release oder Debug Type haben können. Diese Dateien können
  absolute Pfade haben (nicht wirklich immer Sinnvoll *g*) oder relativ zur Plugin-Datei liegen.
  Passte alle Plugin-Dateien entsprechend an. Diese Änderungen machen wie Stefan schon sagte die Sache übersichtlicher und
  ganz nebenbei mächtiger da ein Plugin nun z.B. aus mehreren Bibliotheken bestehen kann und diese nicht mehr zwangsläufig
  im gleichen Ordner liegen müssen wie die Plugin-Datei selbst. :D
  Dependencies werden in diesen Plugin-Dateien pro Library wie gehabt eingetragen. Das ist jedoch rein optional und soll
  wirklich nur dazu dienen das man immer den Überblick behält was von wem abhängt so das man nicht lange herumsuchen oder
  gar herumprobieren muss.



>> 23.03.2007
[CO]
Alle Projekte: Alle VC-Projekt Dateien:
- Deaktivierte die Linker Option '/INCREMENTAL' (nur geänderte Methoden neu übersetzen) da diese in Konflikt mit '/LTCG'
  (gesammte Projekt Optimierung) stand. Damit ist nun folgende Linker Warnung wech:
  "LINK : warning LNK4075: /INCREMENTAL wird aufgrund der Angabe von /LTCG ignoriert."
PLGeneral:
- Im Release Build wird die Bibliothek 'LIBCMT.lib' ignoriert da diese laut Linker Warnung in Konflikt mit einer anderen
  stand.



>> 18.03.2007
[CO]
Da wir mittlerweile sehr viele RTTI Klassen haben und später gerade bei konkreten Projekten sicherlich nochmal einige
hinzukommen versuchte ich die vom RTTI verbrauchten Resourcen 'etwas' in den Griff zu bekommen OHNE das System komplett
umzubauen. Also minimalste Änderungen mit größt möglicher Verbesserung damit das nicht mehr ganz so zäh läuft was mich
ehrlich gesagt mittlerweile etwas stört.
Auf die Hash Map Optimierung vom 14.03.2007 kam ich erst als ich mir mal angeschaut hatte warum bereits einfachste
Programme vergleichsmäßig viel Speicher verbrauchten und beim starten auch viel zu lange brauchten. Es stellte sich heraus
das die Enum Dinge in der Vars Klasse sehr viel Overhead erzeugten. Es wurde gerade für die Enum Hash Map viel zu viel
Speicher verschwendet obwohl diese bei nicht Enum Variablen absolut nie benötigt wurde. Ich überlegte mir dort ob man
die Hash Map da nicht gleich ganz rausnehmen sollte, lies das aber erstmal da es nun nicht mehr so heftig ist und ich meine
Änderungen an diesen Komponenten so klein wie möglich halten will.
Eine andere Sache ist die, das wir zwar viele RTTI Klassen haben, aber ebenfalls viele in den meisten Anwendungen überhaupt
nicht nutzen. Daran DAS RTTI Klassen da sind, da kann man nix ändern außer nicht benötigte Plugins zu deaktiveren. Aber über
das bewärte 'Lazy Evaluation'-Muster das schon so gut im Scene Graph klappt konnte man das ohne zu große Eingriffe Resourcen
schonender machen:
- Class: In 'Init()' werden die Variablen der Basis Klasse NICHT mehr zu der aktuellen Klasse hinzugefügt da dies einfach
  nur unnötig ist. Stattdessen gehen die Funktionen 'GetVarList()' und 'GetVar()' einfach bei Bedarf Rekursiv zu der Basis-
  Klasse weiter - Funktionsmäßig also keine Änderung, aber Resourcen schonender und auch übersichtlicher.
- Class::AddVar(): "Overwrite an already existing variable?"-Teil entfernt da dies nun durch die Änderung von oben
  überflüssig ist
- Die Klassen Variablen werden nun nach dem 'Lazy Evaluation'-Schema Initialisiert, sprich, erst wirklich dann wenn diese
  zum ersten mal wirklich benötigt werden... was öfters NIE der Fall ist und dann müssen die Variablen auch NIE Initialisiert
  werden :D
-> Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Änderung einen Speicherverbraucht von '31.368 K'
   an, danach '29.980 K' + es startet minimal flotter. (hab derzeit bei mir alle nicht umbedingt benötigten Plugins während
   der Entwicklung deaktiviert, sonst wären das nochmal ca. 10 MB mehr Speicher)



>> 16.03.2007
[CO]
Alle Projekte: Einige Inkonsistensen behoben:
- In Headern wurde beim Einbinden von '*.inl' im Block einmal 'Implementation' oder 'Inline includes' geschrieben. Änderte
  das überall in 'Implementation' da dies häufiger verwendet wurde... so braucht man nur nach '//[ Implementation' zu
  suchen um all diese Stellen angezeigt zu bekommen.
- 'filename' wurde nicht überall gleich geschrieben, einmal 'FileName', oder 'file name'. Da 'filename' bei uns am meisten
  verwendet wird und das u.a. so auch auf Wikipedia geschrieben wird und mein Übersetzungs-Tool das so ebenfalls kannte
  machte ich das einheitlich da es mich nun schon ein paar mal verunsicherte wie man das schreiben soll - zudem ist das
  irgendwie doof wenn das innerhalb eines Projektes immer mal wieder anderst geschrieben wird, auch wenn beide schreibweisen
  'richtig' sind... so muss man nicht pro Funktion schaun wie es jeweils geschrieben wird. *g*
- Entfernte den Begriff 'dll' bei z.B. dem 'Import/Export'-Block oder Header Titeln damit das verallgemeinert und nicht
  Begrifflich Windows bezogen ist.
- Bei einigen Klassen sind die Methoden in einzelne 'Blöcke' unterteilt, versuchte den Block Titel soweit einheitlich einzurücken



>> 14.03.2007
[CO]
- HashMap Speicher Optimierung: Die internen Slots werden NICHT mehr sofort angelegt, sondern erst dann wenn das erste Element
  eingefügt wird... denn es kann durchaus vorkommen das eine HashMap warum auch immer mal überhaupt nicht genutzt wird, und in
  dem Fall braucht diese intern keinen weiteren Speicher anzulegen. :)
  Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Änderung einen Speicherverbraucht von '35.596 K' an,
  danach '31.368 K'.



>> 12.03.2007
[CO]
Alle Projekte: PLBase:
- Mit den Header Änderungen bin ich in PLBase nun erstmal soweit durch - mittlerweile wird von TortoiseSVN fast alles rot
  Dargestellt da geändert. Also nicht über die Masse an geänderten Dateien wundern, das zieht sich wirklich durch alle Projekte
  durch. Ich finde das nun wirklich um 'einiges' besser als vorher - auch wenn es noch Details zu verbessern gibt.



>> 10.03.2007
[CO]
- Container + Implementationen: Add() & Remove() & Copy() & Compare(): 'nCount' ist nun uint32, wenn 0, so wird alles hinter
  Start kopiert. <0 war sehr ungeschickt und auch teils fehlerhaft Implementiert - zudem machte das wenig Sinn, wenn jemand
  nix machen will, so hat er erst gar nicht diese Funktionen aufzurufen! :)
- Machte die besprochenen Header Änderungen die auch in PLNetwork schon so gut klappten. In PL Headern sollten unter keinen
  umständen mehr direkt oder indirekt z.B. Standard-Header reinkommen, also u.a. kein direktes 'memcpy' mehr in Headern/Inline
  Implementationen. Da ich die Codes nochmal komplett durch schauen musste, änderte ich dabei gleich Dinge die wir mittlerweile
  anderst schreiben. (u.a. 'strukturierter') Wo möglich reduzierte ich die Abhängigkeiten von z.B. Headern durch Predefinitions
  oder verschieben von Inline in cpp noch weiter. Auch machte ich die besprochenen Änderungen bei der Verwendung von Namespaces,
  also überall 'using namespace' in cpp sobald etwas einmal benötigt wird.
- Kleine 'Wrapper'-Klasse im Tools-Ordner hinzugefügt für Dinge wie z.B. 'memset' die wir in Headern oder Inline-Implementationen
  nutzen. (was nur sehr selten der Fall ist!)



>> 09.03.2007
[CO]
Neues Projekt: PLNetwork:
Stefan schickte mir gestern per E-Mail PLNetwork das er vor 3 Jahren oder so schon mal geschrieben und immer mal wieder kurz
aktualisiert hatte. Wie besprochen Integrierte ich dieses Projekt in PixelLight. Machte auch ein paar erste kleine Änderungen
die Funktionsmäßig aben nix ändern sollten: (solche Änderungen sind ganz nebenbei optimal zum in etwas einarbeiten *g*)
- Host: Ersetzte die stl vector Klasse durch unsere List Klasse
- Socket::Close(): Hier stimmte glaube ich etwas nicht ganz, da z.B. gleich bei 'closesocket' die Funktion verlassen wurde, und
  etwas weiter unten dann (nicht wirklich *g*) die Variablen zurückgesetzt wurden
- Änderte ein paar Variablen wie z.B. 'Port' in uint32 damit man gleich von vorne an keine negativen Werte bekommen kann
- Passte hier und da minimal den Code Style an die anderen Projekte an
- Machte hier gleich die Änderungen die wir für alle Projekte machen wollen, also nur 'using namespace...' in cpp, ein Header
  hat selbst wirklich ALLES zu definieren/includieren was er selbst braucht - inklusive des Lib-Headers der eigenen Lib



>> 02.03.2007
[CO]
- FileSystem::SetBaseDirPriority() & LoadableType::SetSearchPathPriority() Implementiert
- Loader::OpenFile(): Da das File System bei absoluten Dateinamen nicht erst lange herumsuchen muss, versucht das Loadable System
  erstmal den wahrscheinlichsten absoluten Pfade zu nutzen - das klappt meistens und die Ladezeiten werden dadurch spürbar kürzer!
  Gerade in großen Szenen wie z.B. der aktuellen vom Dungeon Demo ist das Laden nun um einiges annehmbarer - zwar natürlich noch
  nicht Optimal (Memory Mapped Files müssten hier nochmals einiges bringen) aber zumindestens nicht mehr ätzend. *g*



>> 02.03.2007
[SB]
- Da es keine Header geben sollte, die nur dann fehlerfrei benutzt werden können wenn vorher noch andere Header eingebunden werden
  (also Abhängigkeiten des Headers nicht im Header selbt eingebunden werden), habe ich PLGeneralWin32Header.h überall dort, wo
  Win32-Datentypen in einer Klasse direkt verwendet werden, auch direkt in dem entsprechenden Header eingebunden. Zusätzliche
  Abhängigkeiten werden dadurch nicht erzeugt, da diese System-Header sowieso nur in den eigenen .cpp Dateien eingebunden werden
  und in der Factory-Funktion, die das benötigte System-Objekt erzeugt. An beiden Stellen mußten vorher also auch die System-Header
  eingebunden werden, um die Header-Datei überhaupt verwenden zu können, was wie gesagt niemals passieren sollte.   
- PLGeneralOSHeaders.h entfernt. Dieser Header wurde nur ein einziges Mal eingebunden, und sollte auch in Zukunft nur sehr selten
  gebraucht werden, da man meist gleich entweder eine Win32- oder Linux-spezifische Datei hat. Dieser Header ist daher unnötig,
  und kann in diesen seltenen Fällen durch eine direkte Fallunterscheidung ersetzt werden



>> 28.02.2007
[CO]
- FileSystem::Mount(): Unterscheidet nun zwischen groß/kleinschreibung wie es überall in PL der Fall ist
- ZipDirectory::GetName(): Gab etwas anderes zurück als ich erwartet hätte und als es die Dokumentation zu FileObject::GetName()
  beschrieb. Daher änderte ich es so das es passt und fügte eine neue Funktion 'GetNameWithinZipFile()' hinzu welche den Namen
  innerhalb der Zip-Datei zurückgibt.



>> 26.02.2007
[CO]
Alle Projekte:
- Ging die Namensgebung der Funktionen nochmal durch welche im Grunde nur 'ja' oder 'nein' zurückgeben. GetEnabled, GetActive etc.
  zu IsEnabled, IsActive etc. Da wir momentan noch PLBool drinnen haben musste ich nur nach bool Suchen ("bool Get") lassen. :)
  Ein paar Funktions-Namen lies ich jedoch, an Stellen wo 'Is' irgendwie noch unpassender als 'Get' ist und ein 'Has' auch irgendwie
  fehl am Platz ist - da müsste man eventuell nochmal schaun ob die Funktionnamen an sich überhaupt Sinnvoll sind.
  (wenn man mal gerade nix besseres zu tun hat *g*)



>> 25.02.2007
[SB]
- Neue Klassen-Templates für Funktions-Objekte hinzugefügt. Das sind recht praktische Zeitgenossen, mit denen Zeiger auf Funktionen
  als Objekte gespeichert werden können. Diese Objekte können dann genauso aufgerufen werden wie Funktionen. Im Gegensatz zu
  Funktions-Pointern können diese Objekte aber nicht nur Zeiger auf statische Funktionen sein, sondern auch Zeiger
  auf Member-Funktionen von Klassen, die zusammen mit einem Zeiger auf ein Objekt dieser Klasse gespeichert werden.
  Bitte beachten: FunctionTmpl.inl funktioniert etwas anders als unsere üblichen .inl Funktionen, daher auch der etwas andere Name,
  da es sich eben nicht nur um die Inline-Implementation von Function.h handelt. Das #ifdef in dieser Datei wurde NICHT vergessen
  sondern ist GEWOLLT weggelassen worden, da die Makros ansonsten nicht mehr richtig funktionieren würden! :-)   



>> 24.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaßt, daß sich wieder alles mit VC7 übersetzen läßt.
- Alle CMake Projektdateien angepaßt: Es wird jetzt ein anderes Kommando für die Postbuild-Kommandos verwendet, da es bei der
  alten Variante u.U. zu Problemen mit den Abhängigkeiten und der Reihenfolge der Projekte kommen konnte. Auch wird so der
  Postbuild-Vorgang nicht mehr als eigenes Target angezeigt.  
PLGeneral:
- Undef einiger weiterer Definitionen aus den Window-Headern in PLGeneralWin32Includes.h hinzugefügt, die benötigt wurden da es
  sonst Namenskonflikte mit eigenen Methoden aus SystemImpl gibt.



>> 23.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaßt, daß sich alles auch wieder unter Linux übersetzen läßt



>> 23.02.2007
[CO]
Alle Projekte:
- Da ich gerade vom Compiler in den PL Beispielen mal wieder gesagt bekommen hatte das es einen Namespace Konflikt gibt und
  nicht entschieden werden kann ob 'Rectangle' denn nun ein "Win32 Rectangle" oder ein 'PLMath::Rectangle' sei hatte ich einfach
  absolut KEINE Lust mehr auf dieses total bescheuerte herumgehacke mit den Namespaces etc. nur weil irgendwo ein OS Header
  reinkommt den man eigentlich überhaupt nicht braucht und dort halt Dinge definiert sind die man ebenfalls nicht braucht sondern
  wirklich nichts als Ärger machen. Daher baute ich das endlich mal so um das OS Header NUR noch dann reinkommen wenn man diese
  WIRKLICH braucht, also in den konkreten OS Implementationen. Überall sonst darf von nun an absolut NICHTS OS Abhängiges mehr
  reinkommen - und falls das doch mal 'nötig' sein sollte läuft etwas falsch, denn es MUSS ohne gehen.
  Bei den erstaunlicherweise sehr kleinen Änderungen damit das ohne ständige OS Header klappt gab es ebenfalls erstaunlicherweise
  praktisch keine Probleme da wir im laufe der Jahre bereits alles 'virtualisiert' hatten. :)
  Beim übersetzen unter Windows klappt das nun so ganz wunderbar, und man hat endlich in Projekten welche rein auf PL aufbauen
  praktisch (also bis auf das InputSystem, durch das leider noch derzeit OS Header reinkommen) keine Namespace Probleme mehr mit
  OS-Dingen. *freu*
  An ein paar Stellen bei denen Windows-Header genutzt werden, musste ich ein paar unschicke 'undefs' wie z.B. #undef MessageBox
  einfügen, (gerade in PLGeneralWin32Includes.h ist das krass) ansonnsten bekam ich einmal Compiler Fehler da wir Funktionen haben
  die genauso heißen, und beim anderen mal Linker Fehler das etwas nicht gefunden wurde was wir gar nicht nutzen. Diese define
  Dinge der OS Header sind wirklich übelst und ich bin total froh das wir diese nun nur noch an 'sehr' wenig Stellen einbinden
  müssen.
  Bei den Linux Headern hab ich gekennzeichnet was umbedingt raus sollte.
PLGeneralLinux.h & PLGeneralWin32.h:
- Nahm THREAD_HANDLE heraus da es nirgends mehr verwendet wird
- NativeDirectory liegt nun direkt in FileSystem.cpp, der Benuter sollte davon nix sehen
- RTTI: Wie kurz besprochen PL_VAR_STRING & PL_VAR_FILENAME welche mit klassischen C-Strings arbeiteten entfernt und dafür
  PL_VAR_PLSTRING & PL_VAR_PLFILENAME in PL_VAR_STRING & PL_VAR_FILENAME umbenannt. Alle Projekte daran angepasst.



>> 22.02.2007
[CO]
- ModuleID<T>::SetModuleName() & ModuleID<T>::SetModuleVendor() & ModuleID<T>::SetModuleDescription():
  Tests auf Buffer Überlauf eingebaut + statt strncpy wird nun memcpy genutzt damit einen VC 2005 nicht mit Warnungen
  in allen Projekten zumüllt.
- An Stellen wie z.B. SystemWin32::GetEnvironmentVariable() wird nun neben 'Unicode' auch 'UTF8' geprüft, ist es ein UTF8 String
  müssen die Daten als Unicode zurückgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran ändern. (ähnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- Win32File::Rename() auf unsere String Klasse umgestellt. Müssen wir bei Erfolgt ebenfalls auch den neuen Dateinamen speichern?



>> 21.02.2007
[CO]
Alle Projekte:
- Machte wie besprochen die Umstellungen auf die 'sicheren angeblichen Standard-Funktionen' vom 11.02.2007 wieder rückgängig,
  denn wie sich herausstellte sind diese leider nicht wirklich Standard - auf jedenfall wird das derzeit nicht von sonderlich
  vielen Compilern unterstützt und daher ist das leider unbrauchbar für uns. :(
  Schaute mir dabei gleich alle Stellen wo diese C-String Funktionen genutzt werden genau an damit es keine Buffer Überläufe
  geben kann. Überall außerhalb der String Klasse stellte ich soweit irgend möglich/sinnig die letzten Stellen die ich finden
  konnte auf unsere String Klasse um damit man sich gar nicht erst mehr mit den C-String Funktionen herumärgern muss. In den
  Projekten in denen VC 2005 trotzdem noch meckert das etwas 'potentiell unsicher' sein deakvierte ich diese Warnungen einfach,
  wir wissen (meistens :) schon ganz genau was wir tun und müssen uns da nicht von einem Compiler zujammern lassen. *g*
  -> *bin heute noch nicht ganz mit diesen Arbeiten fertig geworden*
PLGeneral:
- FSTools::ValidatePath(): Gleiche Änderung wie gestern in Win32FSTools::ConvertToWindowsPath()
- ZipDirectory::GetComment(): So geändert das kein 'strcpy' mehr verwendet wird, zudem übernimmt die String Klasse direkt den
  Buffer (habs getestet, funkt noch korrekt :)
- Ein paar Kommentare von ZipDirectory & ZipStream korrigiert oder genauer gemacht
- ZipIterator::GetCurrentFileInfo(): Die String Klasse übernimmt den Buffer mit dem Dateinamen und Kommentar direkt
- Fügte in diesem VC 2005 Projekt bei den Compiler Optionen "/D "_CRT_SECURE_NO_DEPRECATE"" ein damit keine unnötigen
  Warnungen kommen
- Formte in der String Klasse ein paar Ausdrücke um so das es etwas besser Strukturiert rüberkommt



>> 20.02.2007
[CO]
Alle Projekte: Machte wie besprochen den ersten Schritt bei den Plugin-Änderungen:
- ClassManager::ScanPlugins(): Sucht wie vorher auch nach Plugins, kann dies jedoch nun auch Rekursiv machen
- ClassManager::LoadPlugin(): Prüft ob es wirklich eine '.plugin'-Datei ist, lies die Meta-Informationen aus und prüft dabei
  gleich den 'Typ' auf gültigkeit/übereinstimmung oder ob ein Plugin aktiviert/deaktiviert ist. Danach wird der Name der
  Dynamischen Bibliothek ermittelt - derzeit wird der Plugin Name genommen und entsprechend geändert so das Plugin und
  Dynamischen Bibliothek also erstmal im gleichen Verzeichniss liegen müssen. Anschließent wird wie gehabt (also 1 zu 1
  übernommen :) die Dynamischen Bibliothek eingeladen.
- Verschob die Plugins der verschiedenen Projekte sammt benötigter externer dlls in einen Plugin-Unterordner + dort wo sinnig
  in weitere Unterordner + schrieb entsprechende '.plugin' Dateien in denen ebenfalls vermerkt ist welche dll's diese benötigen,
  was ich recht hilfreich finde. Hier müssen wir uns allerdings noch überlegen ob wir das drinnen lassen da z.B. unter Linux die
  Dateiendung natürlich anderst ist + auch teils die Namen der benötigten Dynamischen Bibliothek, oder ob wir für jedes OS
  Seperate Dateien machen oder ob das innerhalb der Plugin-Dateien nach OS unterteilt ist.
- DynLibManager::LoadLibrary() & DynLib::Load(): Damit man Plugins + abhängige Dynamischen Bibliothek problemlos auch in
  Unterordnern halten kann was durchaus Sinnig ist änderte ich das Verhalten dieser Funktionen minimal. Die Windows Funktion
  lässt netterweise zu das die anderen nötigen dll's zuerst im gleichen Verzeichniss wie die eingeladene dll zu suchen sind.
  Wenn es unter Linux soetwas nicht gibt muss man es so lösen wie ich es zuerst unter Windows machen wollte: Einfach das
  aktuelle Verzeichniss kurzzeitig entsprechend ändern. Dynamischen Bibliotheken sind also zuallererst im 'kleinsmöglichen Scope'
  zu suchen. *g*
- Passte die Post-Build Operationen aller VC & CMake Projekt entsprechend das herum kopieren)
PLGeneral:
- BufferedStringReader auf unsere String Klasse umgestellt. Diese Implementation ist sogar schlanker und übersichtlicher bei
  gleicher Effektivität. :)
- Win32FSTools::ConvertToWindowsPath(): Das 'großmachen' des Laufwerksbuchstaben 'Unicode sicher' gemacht
- ClassManager::GetVarType(const String &sType) Case-Sensitive gemacht da PL generell Case-Sensitive ist
  (da diese Funktion bis jetzt nirgends genutzt wird, musste man auch nichts prüfen ob das korrekt verwendet wird :)
- Hack: Class::Init() Registriert sich in LoadableManager damit dieser von neuen Loadern Wind bekommen kann. Das war leider
  nötig da ansonnsten u.a. in "PhysicsPlayground.scene" Sichtbar Dinge nicht korrekt Funktionierten. (was mich schon geraume
  Zeit störte, da die Ragdolls dort wirklich extrem cool rüberkommen *g*) In dem Falle bekam man die Meldung das die Ragdolls
  nicht eingeladen werden konnten da 'Radgoll' nichts sei was eingeladen werden könnte. Bei Config ist es im Prinzip genauso,
  aber da man da zum Glück derzeit nix von merkt war auch kein Hack dafür nötig. :)
  Klassen melden sich bei LoadableManager nicht ab, da dies derzeit nicht absolut nötig ist - ich wollte einfach die Hacks
  so gering halten wie möglich und fügte auch ausreichene Dokumentation dazu damit man später noch weis warum das drinnen ist.
- Loadable::Save(File *pFile, const Parameters *pParams) prüft ob die übergebene Datei beschreibbar ist
- SearchFilter::CheckMatch() auf unsere String Klasse umgestellt. Ich brauchte einige Zeit um in etwa nachvollziehen zu können
  was hier passiert. Ich hoffe das ich das Funktionsmäßig soweit verstanden und korrekt über unsere String Klasse realisiert
  habe so es Funktionsmäßig keinen Unterschied gibt.
  Stefan, wäre super wenn du das auch nochmal genau Durchdenken könntest ob ich da nicht doch nun eine Funktions Änderung
  drinnen habe... das war das komplizierteste was ich bis jetzt auf unsere String Klasse umgestellt habe und da kann schonmal
  was daneben gegangen sein. *bibber*
  (zumindestens einfache Dinge wie '*.pak' scheinen noch korrekt zu funktionieren, und das in '*' war der heftigste Teil :)



>> 16.02.2007
[CO]
- 'ConsoleLogFormater' hinzugefügt - stand schon so lange auf dem Plan obwohl so wenig Arbeit *g*
- ClassManager::ScanPlugins(): Musste hier leider einen Hack einfügen: "msvcr80.dll" und "msvcr80d.dll" sollte man nie per
  Hand einladen da ansonnsten eine dll Namens 'COREDLL.dll' verlangt wird (scheinbar WindowsC E) wovon ich nur eine nicht
  wirklich brauchbare Version im Netz nach langem suchen finden konnte. Hm, mit den Plugins müssen wir uns wirklich mal was
  überlegen, denn irgendwie häufen sich ähnliche Probleme wenn man alle dlls einläd und nach PL brachbaren Zeug durchforstet. :(



>> 12.02.2007
[CO]
- String: Neue Funktionen: IsValidInteger(), IsValidFloat(): Prüfen ob im String eine gültige Integer oder Float Zahl ist,
  solche Tests werden u.a. für die EditBox in PLGui benötigt.



>> 11.02.2007
[CO]
Alle Projekte: Auf VC 2005 'umgestellt':
- Als ich zum ersten mal etwas unter VC 2005 übersetze bekam ich natürlich viele 'Depriciated Fehlermeldungen' wie z.B.:
    c:\programme\microsoft visual studio 8\vc\include\string.h(73): Siehe Deklaration von 'strcpy'
        Meldung: "This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use
        _CRT_SECURE_NO_DEPRECATE. See online help for details."
  Zum Glück nutzen wir mittlerweile 'fast' überall (und wo das noch nicht der Fall ist und sinnig ist, wird das bald der
  Fall sein :) unsere eigene String Klasse so das sich dieses 'Warnungen' auf eine (große) Handvoll Stellen beschränkten.
  Da die 'Sicherheits'-Warnungen + die neuen zusätzlichen Warnungen durchaus Sinnvoll sind stellte ich u.a. auf 'sichere'
  Funktionen um dennen man die Buffer größe übergeben muss damit sich Buffer Überläufe vermeiden lassen. (ich denke da spricht
  absolut nix dagegen :) Es gibt noch aufwändigere Stellen wo man umstellen müsste oder wo wir sowieso bald unsere eigene
  String Klasse nutzen, das mache ich als zweiten Schritt - würde man das auf einmal machen könnten sich schneller Umstell-Bugs
  einschleichen... ich hoffe da sind bis jetzt keine reingekommen, denn bei dem +1 für mit/ohne \0 muss man immer verdammt
  aufpassen und sich genau Informieren wie die verschiedenen Funktionen das übergeben haben wollen. (bitte die Änderungen
  nochmal kurz überfliegen :)
- An Stellen wie z.B.
  .\src\Base\StringBufferASCII.cpp(285) : warning C4996: 'stricmp' wurde als veraltet deklariert
    C:\Programme\Microsoft Visual Studio 8\VC\include\string.h(213): Siehe Deklaration von 'stricmp'
    Meldung: "The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details."
  passte ich entsprechend an. ('Standardkonform' ist immer gut :) In 'PLGeneralLinux.h' kann man nun sicherlich einige 'stricmp' etc. entfernen.
- TinyXML: Mit VC 2005 neu übersetzt damit der Linker nicht meckert



>> 10.02.2007
[CO]
- SystemWin32::GetOS(): Erweitert damit auch Windows Vista + Service Packs erkannt werden



>> 01.02.2007
[SB]
Alle Projekte:
- CMake build system ist komplett, alle Projekte lassen sich sowohl für Windows als auch für Linux übersetzen
- Kleine Zusammenfassung, welche Probleme es mit CMake gab:
  - PROJECT_OUTPUT konnte nicht auf ein anderes als das Grundverzeichnis gesetzt werden (sollte eigentlich "bin" sein), da CMake
    ansonsten beim linux-build die Abhängigkeiten nicht mehr findet und sofort abbricht. Die Ausgabedateien werden also im
    Grundverzeichnis des Projektes erstellt, was aber nicht weiter schlimm ist, da es sich ja immer um max. 2 Dateien handelt
    und sich dort ansonsten nur die Projektdateien befinden.
  - Beim linux-build werden statische Bibliotheken, die eine Abhängigkeit von einer dynamischen Bibliothek darstellen, nicht nur
    zu dieser Bibliothek gelinkt sondern auch zu allen davon abhängigen Projekten (eine Erklärung hierfür findet sich in der CMake FAQ).
    Da die Pfade zu diesen Bibliotheken aber in den abhängigen Projekten nicht bekannt sind, werden diese nicht gefunden und das
    Übersetzen bricht ab. Um das zu vermeiden müssen die externen Bibliotheken immer mit absolutem Pfad angegeben werden, anstatt
  LINK_DIRECTORIES zu benutzen.
- Altes Linux-Buildsystem ausgebaut



>> 28.01.2007
[CO]
Alle Projekte:
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
Alle Projekte:
- Neues Build-System für Linux auf Basis von CMake eingebaut. Die Projektdateien können dafür benutzt werden,
  sowohl die Linux-Version zu erstellen als auch mittels Cross-Compiling mit VC7 die Windows-Version.
- PLBase Projektdateien sind komplett, jedoch lassen sich zur Zeit noch nicht alle Projekte auch für Linux übersetzen.
  Das Cross-Compiling für Windows funktioniert aber schon perfekt :-)



>> 26.01.2007
[CO]
Kleinere Aufräumarbeiten in PLGeneral:
- "Friend declarations" in "Friends" geändert
- z.B. "Public interface" in "Public functions" geändert
- Namespace Style vereinheitlicht
- Ein paar Leerzeichen/Tabs korrigiert
- In ein paar Konstruktoren wurden nicht alle Variablen Initialisiert + an ein paar Stellen wurde noch nicht die
  Initialisierungs-Liste genutzt
- Ein paar const eingefügt
- In ein paar Headern wo möglich Includes durch Predefinitions ersetzt
- Fügte in einigen cpp-Dateien 'Blöcke' hinzu damit man sofort sehen kann welche Funktionen public, private etc. sind
- Ein paar Kommentare korrigiert/vervollständigt (u.a. "@remarks:" zu "@note" gemacht, oder "@remarks" zu "@note")
- An ein paar Stellen Codes etwas vereinfacht/verschönert, z.B. "for (;;)" in "do/while" geändert oder 'tote' Codes entfernt
  oder ein [TODO] davor gesetzt wenn nicht eindeutig klar war das es nicht mehr benötigt wird
... An der Funktionalität sollte sich nichts geändert haben. Stellen wo man etwas Funktionell ändern/prüfen
    muss hab ich mir erstmal nur notiert um diese in einem zweiten Schritt abzuarbeiten. (damit nix durcheinander kommt :)
    Gerade einige Umbenennungen waren mir sehr wichtig da diese das durchsuchen aller Projekte nach bestimmten Begriffen
    sehr erleichtern.
- BufferedStringReader::GetString(): Hier kann der String Buffer direkt übernommen werden. Bringt jedoch nur 'im Augenblick'
  etwas, denn BufferedStringReader müsste man komplett auf die String Klasse umstellen ohne 'char *' zu nutzen *Unicode Sicher*
- CmdLineParser Code Style angepasst und 'printf' für Debugging rausgenommen, soetwas sollte nie im Code bleiben und auch nie
  nötig sein... man braucht hier *wirklich* einen brauchbaren Debugger damit man keine printf-Krücken nutzen muss die den Code
  durcheinander werfen. Ich fand auch ein paar Stellen wo man die Implementation etwas vereinfachen konnte + Variablen die nix
  machten entfernen konnte. An der Funktionalität hab ich nichts geändert.
- Bugfix: SearchFilter::SearchFilter(): "m_sFilter.ToLower()" entfernt da PL generell case sensitive ist
- Tokenizer: 'm_sSingleChars' Default Einstellung ist nun eindeutig wie gehabt "{}()[]<*>/=,;\"", in den Codes war auch noch
  "{}()[]<>+-*/=,;\"" auskommentiert drinnen und in der Klassen Dokumentation stand "{}()[]=,;\"" als Default. + und - machen
  im Zusammenspiel mit Zahlen welche ein Vorzeichen haben schwere Probleme, darum sollten diese Zeichen als Default keine
  einzelnen Zeichen sein.



>> 18.01.2007
[CO]
- Bugfix: FSTools::ValidatePath(): ".." und "." wurden nicht korrekt aufgelöst da FSTools::GetFirstPath() ebenfalls '\' am
  Ende stehen hat. (war früher mal anderst) Dies viel vorallem im Datei-Dialog auf. :)



>> 16.01.2007
[CO]
- Timer: SetTimeScaleFactor(), SetSlowMotionFactor() und SetCustomSlowMotionFactor(): Der übergebene Faktor MUSS größer als
  0 sein, ist das nicht der Fall, liefern diese Funktionen nun einen Fehler zurück. Ein Faktor von 0 oder gar ein negativer
  Faktor macht an verschiedenen Stellen nur probleme und logisch überhaupt seinen Sinn. 0 ist das gleiche wie Pause, also
  kann man gleich 'richtig' Pausieren wenn man das will, und negative Faktoren, hm, dann müsste ja automatisch alles
  rückwärts laufen... grrr... *g*



>> 23.12.2006
[CO]
- ChecksumCRC32 Checksum Implementation hinzugefügt
- ChecksumSHA1 Checksum Implementation hinzugefügt. Damit haben wir nun 3 Checksum Implementation (aller guten Dinge sind
  3... 3 Gui-Implementationen, 3 Renderer-Implementationen, 3 Sound-Implementationen... *g*)



>> 17.12.2006
[CO]
Alle Projekte:
- Bei den 'GetLoadableTypeName()'-Implementationen wird nun nicht mehr ein C-String zurückgeben, sondern diese Funktionen
  halten ihren Rückgabe-String in einem statischen PL String der zurückgeben wird. Auf die weise muss nicht jedesmal
  der *wirklich* statische String in einen PL String umgewandelt werden nur um kurz darauf wieder zerstört zu werden.
  Statt z.B.
    String SceneContainer::GetLoadableTypeName() const
    {
      return "Scene";
    }
  wird nun
    String SceneContainer::GetLoadableTypeName() const
    {
      static String sString = "Scene"
      return sString;
    }
  geschrieben. Von außen merkt man also nix, und intern isses eine geschicktere Implementation. Das mag zwar die Performance
  nicht um das tausendfache steigern, aber wenn man soetwas machen kann ohne das es alles total durcheinander bringt sollte
  man das machen. An ähnlichen Stellen sollten wir das immer genauso machen, bin daher mal die Codes durchgegangen und änderte
  es dort wo es sinnig ist. Wird nur "" zurückgeben, können wir das wie gehabt lassen da hier sowieso nix herum kopiert wird,
  oder wo der mehraufwand das überhaupt nicht rechtfertigt und es dadurch nur unübersichtlich wird sollten wir das ebenfalls
  wie gehabt lassen... z.B. bei pButton->SetText("Blah!").



>> 16.12.2006
[CO]
- Loadable: m_sAbsFilename muss leider protected sein da PLMesh::Texture und PLMesh::Material *sehr* spezielle Lade Funktionen
  komplett selbst Implementieren und entsprechend m_sAbsFilename in Eigenverantwortung setzen müssen.
- Loadable::Reload() darf der Lade-Funktion natürlich keine direkte Referenz auf 'm_sAbsFilename' übergeben da dieser String
  innerhalb der Lade-Funktion durch die Unload()-Funktion zurückgesetzt wird und dann natürlich nicht bekannt ist was denn
  nun geladen werden soll. :)



>> 13.12.2006
[CO]
Alle Projekte:
- Schaute mir alle Stellen in den Codes an in denen 'using namespace' verwendet wird: Nahm unötige 'using namespace'
  heraus, entfernte z.B. 'PLGeneral' vor 'PLGeneral::uint32' wenn gerade PLGeneral als Namespace verwendet wird, fand und
  entfernte dabei einige mittlerweile unnötigen Header-Includes.



>> 03.12.2006
[CO]
- Ich schaute mir nochmal kurz die verschiedenen Implementation von Container::Remove() (+ überall wo GetIndex() verwendet wird)
  an und merkte das diese bei weitem nicht Optimal war... denn da wurde ein int Wert von 'GetIndex()' ner Funktion übergeben die
  ein uint32 erwartete und konnte ein Element nicht gefunden werden wurde -1 in uint32 umgewandelt... ging zwar meistens gut
  da wir nie Container mit SO vielen Elementen haben, war aber natürlich nicht korrekt. Bei der Gelegenheit erweiterte ich die
  Container-Kommentare auch noch minimal so das möglichst keine Fragen offen bleiben.



>> 02.12.2006
[CO]
- Der Loadable-Manager ist nun ebenfalls ein Loadable und kann sich somit selbst Laden und Speichern. File System Basis
  Pfade werden momentan ebenfalls speichern, wenn das unnötig/ungeschickt sein sollte, können wir uns überlegen wie wir
  das am besten anderst lösen.
- Loadable um Reload()-Funktion erweitert, das ist zwar praktisch 'nur' ein pLoadable->Load(pLoadable->GetAbsFilename()),
  passt aber wunderbar rein und wird auch mehrmals genutzt. PLMesh::Material und PLMesh::Effect erweitern diese Reload()
  Funktion indem nach dem Neuladen zusätzlich noch die verwendeten Texturen neu geladen werden.
- Bugfix: BufferedFileReader: Beim beenden wurde Release() von File aufgerufen, aber beim Datei Zeiger speichern wurde
  keine Referenz hinzugefügt und so wurde in sehr unglücklichen Situationen die Datei einfach gekillt obwohl diese noch
  Referenziert und auch verwendet wurde. Fügte nur ein 'm_pFile->AddReference();' ein anstatt auf Smart Pointer umzustellen.



>> 01.12.2006
[CO]
Alle Projekte:
- Auf Anregung von Stephan änderte ich überall
    XmlDocument *pDocument = new XmlDocument();
  in
    XmlDocument cDocument;
  wodurch auch kein delete mehr nötig ist.
PLGeneral:
- Stack und Queue Kommentare minimal erweitert: Sucht man nun in PixelLight.chm z.B. nach 'FILO' wird man recht schnell
  das Stack Template finden. :)
- 'Timer' Klasse in 'Timing' umbenannt. Dieser Name ist passender - und ganz nebenbei kann's auch keinen Namenskonflikt mehr
  mit der neuen Timer Klasse in PLGui geben.
- Code im Destruktor von XmlNode entfernt da genau das gleiche in dessen Basis-Klasse XmlBase passiert (kein Fehler, nur unnötig)
- Fügte bei den Xml-Klassen in denen es noch 'keinen' Destruktor gab einen leeren ein (wir hatten uns vor einiger Zeit geeinigt
  das wir das so machen wollen, also immer Destruktoren reinschreiben)



>> 30.11.2006
[CO]
- ClassManager::GetVarType(): PL_VAR_PLSTRING fehlte hier, merkwürdig das dies bis jetzt noch nicht aufgefallen war :D
- XmlDocument::LoadFile() setzt nun ebenfalls den Dokument Wert auf den Dateinamen aus dem dieses Dokument geladen wurde
- Verschob FSTools::GetRelativePath() in den Loadable-Manager. Dieser schaut als allerersten Schritt nach ob's für diese Datei
  Endung überhaupt einen eingetragenen Loadable Type gibt, wenn ja, so wird die Anfrage einen 'relativen Pfad' zu erzeugen
  an diesen Loadable Type weitergeleitet.
FileSystem:
- Nahm folgende Funktionen heraus da nun das Loadable-System für diese Jobs zuständig ist:
  GetNumOfSearchPaths(), GetSearchPath(), IsSearchPath(), AddSearchPath(), SetSearchPathPriority(), RemoveSearchPath(),
  ClearSearchPaths(), GetNumOfFileTypes(), GetFileType(), RemoveFileType().
- OpenInPaths() ist nun unnötig und wurde daher entfernt
- Enfernte die Klasse FileType, Sie ruhe in Frieden *g*



>> 26.11.2006
[CO]
- Container Klassen etwas herausgeputzt: ein paar Klassen-Blöcke hinzugefügt, Prefix bei Klassen-/Stuktur-Namen entfernt,
  ein paar kleinere Kommentare etwas geändert
- XML-Klassen etwas herausgeputzt: Hauptsächlich Kommentare komplettiert/verbessert
- ClassManager::LoadPlugin(): Eine Datei wurde geöffnet, aber nicht wieder freigegeben -> Stefan schau bitte nochmal drüber
  nicht das ich da nun etwas vermurkst habe. :)
- LoadableManager & Config: Ich wunderte mich gerade das Ragdolls im Scene Viewer nicht mehr geladen werden können da angeblich
  'Ragdoll' ein nicht bekannter Loadable Typ ist... als ich der Sache nachging stellte sich schnell heraus das der Loadable
  Manager bereits nach Loadable Typen sucht und diese Registriert (in dessen Konstruktor) bevor der Runtime-Ordner nach Plugins
  durchsucht wurde. Das lässt sich momentan leider nicht 'beheben' da man sich nicht Informieren lassen kann wenn neue Plugins
  eingeladen wurden um anschließend diese 'Neulinge' nach zu Registrierenden Komponenten zu durchsuchen. :(



>> 25.11.2006
[CO]
Alle Projekte:
- Schaute 'NULL' in allen Headern nochmal durch und ersetzte es im zusammenhang mit PL-Strings durch 'empty'
  (das waren noch Zeiten als wir 'char*' nutzten :)
PLGeneral:
- Loadable: Da es bei Mehrfachvererbungen (siehe PLEngine::SceneContainer oder PLPhysics::SNRagoll) leider schnell zu cast
  Problemen kommt baute ich bis eine bessere Lösung gefunden ist virtuelle 'LoadLoadable()' und 'SaveLoadable()' Funktionen
  ein mit denen sich das Problem 'umgehen' lässt. Sehr schade, denn bis auf dieses Problem ist das Loadable-System mittlerweile
  recht nett, sehr einfach zu verwenden und zu erweitern.
- Localization Loader + Implementation für unser eigenes Format hinzugefügt
- Config Loader + Implementation für unser eigenes Format hinzugefügt



>> 24.11.2006
[CO]
- Vereinfachte das Loadable-System noch etwas und nahm einige Dinge aus 'Resource' heraus diese nun in dessen Basis-Klasse 'Loadable'
  liegen... Machte zuvor eine Kopie Namens 'ElementManager' etc. da sehr oft 'Resource' allein von Namen her in der Verwendung
  nicht korrekt war. (oder zumindestens nicht wirklich passend) Das ist zwar ingesammt immer noch nicht sonderlich prall, aber
  immerhin etwas besser als vorher. :)
  'Resourcen' sind 'Dinge' wie man Einladen & Speichern und von denen man überlicherweise viele im Speicher hat und diese
  daher 'Verwaltet' haben möchte. 'Elemente' sind ähnlich, aber einfacher und auch nicht lad oder speicherbar.
- Graph Loader + Implementation für unser eigenes Format hinzugefügt
- Graph Path Loader + Implementation für unser eigenes Format hinzugefügt



>> 11.11.2006
[SW]
- String: da die atof funktion unter linux auch locale abhängig ist, wird in den Funktionen GetFloat und GetDouble
      wie in den Format funktionen die locale auf "C" gesetzt.
- LinuxDirectory: ein Fehler bei der Überprüfung ob der Suchpfad mit einem "./" beginnt
  und dem löschen dieser 2 zeichen behoben. In der ursprünglichen Fassung wurde das Löschen durch die Stringfunktion Replace durchgeführt,
  was aber einen bösen nebeneffekt hatte, wenn der pfad auch "../" enthielt.



>> 04.11.2006
[CO]
- Win32File & LinuxFile: Kann es wirklich sein das im Destruktor die Datei nicht geschlossen wurde falls diese noch offen
  war? (was bei Reference Counting schonmal passieren kann... der letzte hat die Tür zuzumachen... :)



>> 03.11.2006
[CO]
- Entfernte ein paar 'PLGENERAL_API' wo das nicht nötig ist da es rein PLGeneral intern genutzt wird
- Fügte einige 'const' ein
- Virtual vor Destruktor entfernt da unnötig: (verwenden nur eingebettete Implementationen) Semaphore, Mutex, DynLib
- In einigen cpp-Dateien Kommentar Blöcke hinzugefügt damit man sofort sieht ob die Funktionen public etc. sind
- System: Neue Funktion GetLocaleLanguage(): Diese Funktion gibt den Namen der aktuell eingestellten Programm Sprache wie z.B.
  'English' zurück. Diesen String kann man dann nutzen um im Lokalisations-System eine korrekte Default-Sprache zu wählen.
- ~ThreadManager: Änderte das löschen noch vorhandener Threads da Theads sich beim löschen automatisch aus der Liste
  entfernen was beim Interator Probleme machen 'könnte'. In diesem speziellen Fall machte das zwar keine Probleme da der List
  Iterator intern direkt einen Zeiger auf das nächste Element hält, aber beim z.B. Array-Iterator würde das schon nicht mehr
  gehen... lieber auf Nummer sicher gehen. :)
- SystemWin32: SetThreadAffinityMask() aus PLEngine::PL::InitEngine() hierher verschoben
- Thread um SetPriorityClass() und SetPriority() erweitert, PLEngine::PL::InitEngine() nutzt diese Funktionen um das Programm
  mit einer gewünschten Priorität laufen zu lassen. (bis jetzt wurde dort mit einem ifdef gearbeitet)
  Stephan, bitte schau mal nach ob das mit der Thread Priorität unter Linux ähnlich abläuft, wenn nicht, so müssten wir uns
  zusammen überlegen wie wir das in PL handhaben wollen.



>> 28.10.2006
[CO]
- Loadable: Neue Funktion: GetAbsFilename() gibt den absoluten Dateinamen der Datei zurück aus dem dieses 'Ladbare Teil'
  geladen wurde. So einen absoluten Dateinamen braucht man öfters mal, z.B. in PLMesh::Texture::Load() um nach einer
  entsprechenden 'plt'-Datei zu suchen oder wenn eine Resource 'neu geladen' werden soll. Noch find ich die aktuelle
  Lösung noch nicht sooo prall, mal schaun ob wir das noch irgendwie besser & universeller hinbekommen können - aber für
  den Augeblick müsste das reichen.
- FS: Directory::OpenCanonical(): Das Laden aus einer Zip-Datei anhand eines absoluten Namens klappte nicht (mehr) korrekt



>> 27.10.2006
[CO]
Alle Projekte:
- Nahm an ein paar Stellen <Extension>.ToLower() und CompareNoCase() heraus da wir generell zwischen groß/kleinschreibung
  unterscheiden wollen. In den Beispielen musste ich dadurch ein paar 3ds-Meshs per Hex-Editor korrigieren da Max irgendwie
  absolut keinen Wert auf groß/kleinschreibung legt und bei 3ds wie es momentan aussieht IMMER zwanghaft großschreibt.
  (da müsste ich noch etwas Experimentieren ob dem wirklich so ist)
PLGeneral:
- 'Loader'-System eingebaut, dieses System lag bereits seit ein paar Monaten im Lab/PLResource-Ordner. Nahm 'File' aus
  den Klassen Namen heraus damit es etwas deutlicher wird das dies nicht 'direkt' etwas mit dem FS zu tun hat.
  Alles was irgendwie Lad- & Speicherbar ist sollte von nun an von 'Loadable' abgeleitet werden. Die konkreten Lade & Speicher
  Funktionen liegen in von 'Loader' abgeleiteten Klassen. Diese 'Loader' müssen sich wirklich NUR um das Laden & Speichern
  kümmern, und nicht um das öffnen/schließen der Datei - das vereinfacht an vielen Stellen einiges. Abfragen welche Typen & Formate
  unterstützt werden kann man universell & bequem über den 'LoadableManager'. Das muss nun also nicht mehr x mal neu
  geschrieben werden, sondern 'Loader' werden zentral automatisch Registriert und verwaltet. Das System ist noch nicht final
  und wird an ein paar Stellen noch etwas vereinfacht werden. Aber es ist denk ich schonmal etwas besser als vorher... leider
  brachte dies keine großartige Ladezeit Verbesserung, trotzdem ist nun beim Laden einiges an Overhead weg. :)
- XmlDocument: Lade-Funktion hinzugefügt der man dirkt eine Datei übergeben kann



>> 18.10.2006
[CO]
Alle Projekte:
- Fügte "#pragma once" in alle Header ein damit das Übersetzen "minimal" schneller geht. Da dies sowohl unter VC als auch
  gcc bekannt ist, müsste es damit keine 'Kompatibilitätsprobleme' geben.
- Mithilfe von "__pragma" kann man Pragmas auch in Makros nutzen. Änderte daher die PL_WARNING_PUSH & PL_WARNING_POP &
  PL_WARNING_DISABLE Makros entsprechend.



>> 17.10.2006
[CO]
Alle Projekte:
- Wie besprochen "PL_WARNING_POP", "PL_WARNING_PUSH", "PL_WARNING_DISABLE" Precompiler Makros eingebaut. Jedoch konnte man
  es leider nicht so realisieren das man direkt "PL_WARNING_DISABLE(4100)" schreiben kann... stattdessen muss man
  "#pragma PL_WARNING_DISABLE(4100)" schreiben. Nun müssten unter Linux die pragma-Warnungen weg sein. Wie genau man das löst
  wenn man bestimmte Warnungen unter Linux deakivieren will müssten wir sehen wenn das ein Thema wird.



>> 16.10.2006
[SB]
Alle Projekte:
- Habe mal versucht die Export-Makros etwas zu entwirren. In PLGeneral ist jetzt jedes dieser Makros auch noch etwas genauer
  beschrieben, damit hoffentlich keiner mehr verwirrt ist welches Makro wozu gut ist.



>> 14.10.2006
[SW]
Alle Projekte:
- Finale version für das visibility attribute feature vom gcc.



>> 14.10.2006
[CO]
- Error System, zweiter Ansatz: (Namen & Implementation noch nicht final :)
  Hat eine Funktion einen 'boolschen' Rückgabewert, so wird statt bool/PLBool 'PLReturn' genutzt welches ein Smart Pointer
  auf ein 'Result'-Objekt ist. (Experimentelle Implementation) Trat kein Fehler auf, so zeigt dieser auf 'Result::NoError',
  bei Fehler auf ein erzeugtes Result-Objekt. Dieses Result-Objekt kann man wie gehabt genauso wie einen einfachen boolschen
  Rückgabewert verwenden falls man sich 'nur' dafür Interessiert ob es einen Fehler gab. Interessiert einen selbst das nicht,
  wird dank dem Smart Pointer dieses Result-Objekt automatisch wieder 'freigegeben'. Gibt eine Funktion z.B. einen String
  zurück, so sollte es IMMER einen Optionalen PLResult-Zeiger geben der auf Wunsch das Ergebniss bekommt. Zwar bietet der
  Error-Manager die Möglichkeit sich den 'letzen' Fehler zurückgeben zu lassen, dies ist jedoch NICHT Multithreading-Safe...
  aber falls das einen nicht juckt, kann man diesen Optionalen Parameter auch ignorieren und z.B. Error::GetLast() nutzen was
  etwas 'bequemer' zu verwenden ist - das ist dem User überlassen ob er dieses 'Risiko' eingehen will. Wir selbst sollten in
  der Engine aber NIE Error::GetLast() nutzen. :)
  Das System unterstützt auch 'Rekursion' so das man sich den vorherigen Fehler zurückgeben lassen kann um zu sehen wo der erste
  Fehler passierte. Anhand von Checksum::GetFile() kann man sehen wie das mit der Fehler-Rekursion derzeit abläuft. Anhand von
  PLBaseTest::ChecksumTest() kann man sehen das dies bereits sehr gut klappt - wenn wir das so machen wollen, muss sich natürlich
  dann jede Funktion daran halten damit das durchgehend klappt und man Fehler bis an den Ursprung zurückverfolgen kann.
  Die übergebenen Funktions-Parameter sollten wenn möglich IMMER mit einem PL_ASSERT() auf gültigkeit geprüft werden und in der
  Funktions Dokumentation sollte genau beschrieben sein ob ein Parameter gültig sein MUSS oder nicht. Hier wird aber wirklich
  nur geprüft und gewarnt wenn etwas nicht stimmt, danach gehts fröhlich weiter bis zum Crash.



>> 13.10.2006
[CO]
- PLMain Dokumentiert damit wirklich klar ist was die Parameter und vorallem der Rückgabewert zu bedeuten haben
- UTF8Tools: Die 3 neuen Funktionen von Stephan vom Style & der Namensgebung her angepasst. Kommentar "One or both strings
  can be pure ASCII Strings" entfernt da dies eine allgemein gültige UTF8 Eigenschaft ist. 'FindSubString' könnten
  wir eventuell auch 'IsSubString' oder 'GetSubString' nennen... von der Funktionaliät her hab ich nix verändert - konnte
  mit den erweiterten Unit-Tests auch keine Bugs oder so finden. :)



>> 11.10.2006
[SW]
Alle Projekte:
- Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
PLGeneral:
- Neues Makro PLTEMPLATE_EXPORT hinzugefügt, mit denen unter Linux die Templates komplett exportiert werden können.
  Momentan betrifft das nur Array und Singleton



>> 06.10.2006
[CO]
Alle Projekte:
- Nachdem mich Stephan auf eine 'POD-Warnung' in "PLGui/Dialogs/ResourceManagerDialog.inl:288" aufmerksam machte,
  ging ich nochmals alle String::Format-Stellen durch und prüfte auf PLT()-Makro verwendung - denn dieses gibt mittlerweile
  einen PL String zurück. :)



>> 01.10.2006
[CO]
- Bugfix: XmlDocument::GetRootElement() -> Hier ging der Aufruf nicht über GetPLNode() und daher wurde keine korrekte eingebettete
  PL XML Node erzeugt. (gut das Stephan diese Funktion mal ausprobiert hatte *g*)



>> 28.09.2006
[SW]
Alle Projekte: PLBase:
- Die linux-projecte dateine an die Änderungen angepasst.



>> 27.09.2006
[CO]
- Auf PLBool umgestellt und wie üblich alle Projekte entsprechend angepasst. Stellte auch dort auf PLBool um wo das true/false
  bereits passte damit das 'Einheitlich' ist und das einbauen eines netten Fehler Systems leicher geht. (man muss fast nur noch
  nach PLBool suchen *g*)
  Beim Linux Teil *könnte* es noch Stellen geben wo man noch den Fehler Code anpassen muss.



>> 26.09.2006
[SW]
- In RTTIDefs.h an zwei stellen (void)0 anstelle von 0 geschrieben um eine gcc-4.x warnung zu beheben
- ClassManager::LoadPlugin da der DynLibManager momentan in der Hasmap von bereits geladenen Libs nur den Dateinamen speichert,
  wird nun der GetLibrary nur der Dateinamen übergeben und nicht der komplette pfad.
  Wenn jemand was dagegen hat soll es entweder wieder zurückändern oder mir bescheid geben. (diese änderung wieder auf wunsch von stefan revidiert)
- ein paar dumme printfs rausgeschmissen, die eigentlich nicht hochgeladen werden sollten



>> 26.09.2006
[CO]
- Machte ein paar kleinere erste Style anpassungen



>> 21.09.2006
[CO]
- Einfache Error-System Klasse hinzugefügt + diverse Makros die einem das Leben mit Fehlern etwas einfacher machen
- Checksum & Config Klasse auf bessere Fehlerbehandlung umgestellt um zu sehen ob wir das so machen können/wollen



>> 21.09.2006
[SB]
- Neue Klasse Url hinzugefügt. Diese Klasse verwaltet einen Pfad oder Dateinamen, kann zwischen den Unix/Windows Formaten sowie
  der URL Darstellung konvertieren und beinhaltet die üblichen Funktionen um einen Pfad in Verzeichnis, Dateiname, Extension aufzuspalten etc.
  Im Gegensatz zu den Funktionen aus FSTools ist die Klasse darauf ausgelegt, möglichst flexibel zu sein, und mit so vielen Eingaben
  wie möglich noch irgend etwas anfangen zu können. Kommt also z.B. ein Dateiname bunt gemischt mit \ und / herein stört das die
  Url Klasse nicht, der Pfad wird erstmal so gespeichert ohne gleich zwangsläufig konvertiert zu werden. Sobald man dann einen für das
  System gültigen Pfad braucht läßt man sich die Url umwandeln, damit sie korrekt wird.
  Im FS wird ab sofort nur noch diese Klasse verwendet und damit die alten FSTools Funktionen ersetzen. Außerhalb kann die Klasse natürlich
  auch verwendet werden, um z.B. an einen Pfad/Dateiname/Extension o.ä. heranzukommen, zum Speichern eines Dateinamens sollte sie allerdings
  nur sehr selten verwendet werden, da sie einiges an Speicherplatz braucht. Normalerweise sollte ein Pfad also weiterhin einfach als String
  gespeichert werden.
- FSRefCount entfernt. Die Basisklasse für alle FS Objekte (auch SearchHandle) ist nun FileObject, welches direkt von RefCount abgeleitet ist.
- FileObject: EType hinzugefügt, welches angibt um was für ein Objekt es sich handelt. Dies wird nun nur noch in der FileObject Klasse behandelt,
  die virtuellen Funktionen zu diesem Zweck wurden daher entfernt.
- FileObject: Hat nun keinen Pointer mehr auf FileSystem, da es davon nur eine Singleton-Instanz gibt, auf die jetzt direkt zugegriffen wird.



>> 20.09.2006
[SB]
- Neue Hilfsklasse PLBool hinzugefügt. Die macht nicht viel, außer einen bool zu speichern, und kann benutzt werden, um die
  true/false-Umstellung zu machen. Die Klasse ist so aufgebaut, daß sie *nicht* automatisch von/nach bool konvertiert,
  sondern bei jedem solchen Versuch einen Compilerfehler generiert. Das kann also so benutzt werden:
  - In der Funktion, die umgestellt werden soll, den Rückgabetyp von bool in PL_BOOL umändern
  - return true -> return PL_FALSE
  - return false -> return PL_TRUE
  - Alle Projekte compilieren, dadurch gibt es überall dort eine Fehlermeldung, wo die Funktion benutzt wird, z.B. bei
    if (TheFunction()), oder if (!TheFunction()) etc. Dort kann nun die Umstellung erfolgen:
  - if (theFunction()) -> if (PL_NOT theFunction())
  - if (!theFunction()) -> if (PL_IS theFunction())
  - Wenn sich wieder alles übersetzen läßt, kann man den Typus wieder auf bool setzen und per Suchen/Ersetzen alles zurück umwandeln
  - 'PL_FALSE' -> 'false'
  - 'PL_TRUE' -> 'true'
  - 'PL_NOT ' -> '!'
  - 'PL_IS ' -> ''
Auf diese Weise sollte die Umstellung wesentlich erleichtert werden, und dank der Compilerfehler müßte man auch *alle* Stellen finden,
an denen die jeweilige Funktion verwendet wird, man kann also nichts mehr übersehen. Natürlich müssen immer alle Projekte compiliert werden,
denn nach dem Umwandeln sieht für die Compiler wieder alles richtig aus, auch wenn man ein Projekt noch nicht angepaßt hat. Hoffe das macht
diese Umstellung etwas erträglicher ;-)



>> 19.09.2006
[CO]
- UTF8Tools: Neue Funktionen FromWideCharacterString() & FromWideCharacterString() + änderte ein paar Namen so das klar ist
  das es sich z.B. um einen 'wide character' handelt. Änderte den Datentyp von 'wide character' von uint32 zu wchar_t - das
  ist zwar irgendwie total doof da wchar_t keine fest vorgegebene größe hat, allerdings können wir mit uint32 'wide character
  Dingen nix anfangen da die Windoof Unicode Funktionen nunmal leider wchar_t und kein UTF8 oder uint32 nutzen. :(
  Hatte mir zuerst überlegt wchar_t UND uint32 Versionen der Funktionen anzubieten - aber das wäre dann doch etwas zuviel
  des guten geworden. Hat man mit wchar_t Problemen da es z.B. unter Windows zu klein ist, muss man ganz einfach NUR UTF8
  in seinem Projekt nutzen - es hindert einen ja bei unserer String Klasse bald (sobald fertig Implementiert) nix dran! *g*
- String Klasse: GetUTF8() müsste mittlerweile Problemlos funktionieren -> Stephan, wenn du willst kannst du mal den Linux
  Port entsprechend anpassen bzw. mit GetUTF8() durchtesten ob das wirklich bereits brauchbar klappt. Der Rest muss noch
  ausgearbeitet werden.



>> 18.09.2006
[CO]
- Neue Tool-Klasse: UTF8Tools: Diverse UTF8 Funktionen die man immer mal wieder benötigt. Hatte diese zuerst direkt als statische
  Hilfs-Funktionen in StringBufferUTF8 drinnen bis ich merkte das es immer mehr Funktionen wurden die man ebenfalls noch bräuchte...
  Daher entschloss ich mich diese Funktionen in einer seperaten Hilfs-Klasse abzulegen damit das nicht zuviel auf einmal wird.
- Fing damit an die String Klasse um UTF8-Support zu erweitern (noch nicht lauffähig!)



>> 13.09.2006
[CO]
Alle Projekte:
- Schrieb bei jedem "#pragma warning(disable : <Number>)" dazu was genau dieses deaktiviert (... zumindestens bei VC...)



>> 12.09.2006
[SW]
- in Main.h das setlocale(LC_ALL, "") hinzugefügt(unter Linux), da dadurch die systemlocale für den Prozess gesetzt werden, ist nötig,
  da sonst im PLSampleGui die jpanischen schriftzeichen nicht angezeigt wurden.
- Durch die Änderung in der Main.h tauchten problem auf, wenn man floats in String und zurück umwandelt, da im Deutschen das Trennzeichen ein ',' ist und im Englischen ein '.'.
  Um das problem zu lösen wurde in den Format-Funktionen des String-Klasse die locale auf "englisch" ("C") gesetzt und am ende der Funktion wieder auf die systemlocale zurückgesetzt.
  Das Problem und die Lösung(momentan nur für LINUX als test) habe ich zusammen mit Christian ausgearbeitet.



>> 11.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird:
 - Per Absicht nicht verwendete Variablen (da z.B. Virtuelle Funktionen) sollten mit PL_UNUSED() gekennzeichnet werden
   damit hier nicht angewarnt wird.
 - Beim Einbinden externer Header (z.B. tinyxml.h) deaktiviere ich diverse Warnungen da wir hier nix ändern sollten.
 - Musste das PL_LOG-Makro minimal umschreiben damit nicht immer angewarnt wird das ein Ausdruck dort Konstant ist.
 - Deaktivierte die Warnung "warning C4201: Nicht dem Standard entsprechende Erweiterung: Struktur/Union ohne Namen" da
   ich nicht rausbekommen konnte wie man das besser machen könnte ohne das diese Warnung erscheint. :(
   (einfach keine Unions nutzen ist KEINE Option! ;-)
-> In den Projekten in denen ich die Warnungen beseitige hab ich im Debug-Modus erstmal Warn-Leven 4 aktiv gelassen. Solange
   es nicht stört können wir das so lassen und bekommen ein paar weitere nützliche Tips vom Compiler wo möglicherweise
   etwas noch nicht ganz ok aussieht. Viele der 'zusätzlichen' Warnungen sind durchaus hilfreich... um nur ein Beispiel für
   einen dadurch gefundenen Bug zu nennen:
      PLPhysicsNewton::WorldNewton::GenericContactBegin:: -> if (nCollisionGroup1 && Ignore)
    -> !! Übler Bug der nun zum Glück angewarnt wurde! ;-)
   Desweiteren werden auch Variablen angewarnt die zwar Initialisiert, aber nie verwendet wurden, ebenfalls recht nützlich,
   und wie schon oben erwähnt sollte man PL_UNUSED() verwenden wenn das schon korrekt so ist.
-> Ich werde sicherlich noch ein paar Tage brauchen bis ich durch alle Projekte sauber durch bin. :)



>> 10.09.2006
[CO]
- Config: - GetVarBool() entfernt da man dafür mittlerweile auch locker GetVar().GetBool() schreiben kann.
          - GetVarFloat() entfernt da man dafür mittlerweile auch locker GetVar().GetFloat() schreiben kann.
- FSTools::ValidatePath(): Bei einem der Zahlreichen String-Anpassungen der letzten Zeit kam hier ein kleiner Bug rein so
  das es zu Problemen mit '/' oder '\' kommen konnte. Stefan, wäre nett wenn du irgendwann später über diese Funktion
  nochmal drüber schaun könntest - nicht das ich das Schrittweise kaputt oder zu umständlich gemacht habe. :)
- Variant um GetString()-Funktion erweitert damit man sich ausdrücklich die String-Version des Wertes zurückgeben lassen
  kann ohne vorher auf String casten zu müssen



>> 08.09.2006
[CO]
- Abstraktes Checksum-Interface + MD5 Implementation hinzugefügt



>> 04.09.2006
[CO]
Alle Projekte:
- Fand einige Stellen an denen es z.B. netter ist vVector.x anstatt vVector[0] zu schreiben
PLGeneral:
- Types.h: FALSE, TRUE, und NULL flogen heraus bzw. verschob diese Definitionen in den Linux Teil da diese dort soweit ich
  weis benötigt werden. (bei Windows werden diese Dinge in den Win32-Headern definiert)



>> 04.09.2006
[SW]
- Linux implementation des Unicode(wchar_t) supports, habe den aufruf der durch "int vswprintf( wchar_t *buffer,const wchar_t *format, va_list argptr )"
  durch die funtion "int vswprintf(wchar_t *buffer, size_t count, const wchar_t *format,va_list argptr)" ersetzt, da unter linux nur die mit dem count parameter gibt.



>> 01.09.2006
[CO]
Alle Projekte:
- Wie Stefan es wünschte verwenden wir nun überall 'd' als Prefix für 'double' anstatt ein universelles 'f' für 'floating point'.
PLGeneral:
- Lokalisierungs-System eingebaut. Das System an sich ist recht einfach aufgebaut und auch leicht zu bedienen. Texte sind
  in Gruppen aufgeteilt und jedes Projekt kann seine Texte in einer eigenen Gruppe anlegen damit es z.B. keinen Konflikt mit
  PL-Texten gibt. Wie üblich ist das 'Localization' Format in XML gehalten.
  Da wir bereits überall wo Sprachabhängige Texte verwendet werden das 'PLT'-Makro verwenden, waren die Code Umstellungen minimal.
  Nur den Header '#include <PLGeneral/Tools/Localization.h>' muss man nun einfügen wo man Sprachabhänige Texte hat. Neben
  dem 'PLT'-Makro welches 'PixelLight' als Text-Gruppe nutzt gibt es noch ein 'PL_TEXT'-Makro bei dem als zweiter Parameter
  die Gruppe angegeben werden muss. Ob wir das 'PLT'-Makro drinnen lassen müssen wir noch sehen, auf jedenfall ist es im Augenblick
  noch nett da man die Codes dadurch nicht ändern musste oder sich um die Gruppe innerhalb der PL-Codes kümmern muss.
  Als 'native'-Sprache verwenden wir innerhalb von PL Englisch. Für diese 'native'-Sprache ist keine Lokalisierungs-Datei
  nötig da der Englische Text gleich als Schlüssel für die Übersetung verwendet wird. Wird keine Übersetzung gefunden weil
  gerade z.B. Englisch als Sprache aktiv ist, so wird einfach dieser Text-Schlüssel als Ergebniss verwendet. :)
  Was im Augenblick noch fehlt ist ein Tool welches Codes als Eingabe bekommt, nach unseren Lokalisierungs-Makros sucht
  und die Gefundenen Dinge in einer bzw. mehreren Lokalisierungs-Dateien auflistet so das man die Codes nicht per Hand nach
  zu übersetzenden Texten durchwühlen muss.
  Auch wäre es wohl sinnig wenn die Beispiele & Tools ihre Texte in eigenen Gruppen verwalten würden, das muss man aber
  noch ausjungeln wie was am besten ist. Hier ein Beispiel wie so eine Lokalisierungs-Datei aussieht:
    <?xml version="1.0" ?>
    <Localization From="English" To="Deutsch">
        <Text Name="Hello">Hallo</Text>
        <Text Name="This is a test">Dies ist ein Test</Text>
    </Localization>



>> 30.08.2006
[CO]
- Jede String Buffer Implementation speichert nun noch den String in einem jeweils anderen Format. Hab ich z.B. einen ASCII
  String, fordere aber einen Unicode-String an, so wird intern eine Unicode-String Variante erzeugt. Fordere ich nochmals
  Unicode an, so wird direkt dieser gepufferte Unicode-String zurückgegeben. Sobald der Orginal String verändert wird, wird
  dieser gepufferte String 'schmutzig' und muss sobald er wieder angefordert wird neu erzeugt werden. Arbeitete die internen
  String Konvertierungen aus, also wenn ich z.B. 'sMyString = sACII + sUnicode' schreibe.



>> 29.08.2006
[CO]
- String Klasse um wchar_t-Unicodes erweitert. In unseren Projekten sollte nun immer bei den Compiler-Einstellungen 'Unicode'
  anstatt 'Multi-Byte' verwendet werden was normalerweise die Standard-Einstellung ist. Da wchar_t von der größe her nicht
  fest Definiert ist, sollte man NIE davon ausgehen das ein Buchstabe 2 Byte oder so groß ist sondern IMMER sizeof(wchar_t)
  verwenden. Zudem sollte man aus diesem Grund wchar_t Strings auch nicht in Dateien speichern oder aus solchen Laden. Das
  sollte man dann über das 'sicherere' UTF-8 Format machen sobald dies Implementiert ist. Durch die änderung der Compiler
  Einstellung wurden einige fehlerhafte String-Stellen gefunden wo z.B. !sMyString abgefragt wurde, 'true' zurückgegen wurde
  obwohl der Rückgabewert ein String war etc. - also Stellen die man bei den krassen String Umstellungen von damals übersehen
  hatte. :)
  An ein paar Stellen wie z.B. im Win32 PLGui Backend wird bereits das Format des PL Strings geprüft und dann entsprechend
  die Unicode oder ASCII OS Funktions Variante verwendet... wie man anhand von PLSampleGui sehen kann geht nun auch Japanisch
  ganz wunderbar. *g*



>> 28.08.2006
[CO]
- Vorherige String Klasse durch die überarbeite String-Klasse ersetzt. Das Interface ist noch kompatibel mit dem alten und
  wurde nur minimal erweitert. Die ASCII Implementation ist komplett Implementiert, wurde an einigen Stellen neu geschrieben
  und mit den erweiterten String-Tests geprüft so das halbwechs sichergestellt ist das nicht wieder von neuem üble Bugs
  reingekommen sind. ;-) (zudem läuft alles auch im Release Modus noch stabil was auch schonmal ein gutes Zeichen ist *g*)
  Das sehr gut funktionierende String-Buffer Konzept wurde natürlich beibehalten, jedoch haben String Buffer nun auch noch
  den Job die konkreten String Operationen auszuführen - abhängig von deren internen String-Format. Die String Klasse selbst
  ist also sogesehen 'nur' noch ein String-Buffer-Container der bestimmte allgemeine Bedingungen prüft so das diese nicht
  in jeder String Buffer Implementation erneut gemacht werden müssen.
  Es kamen noch ein paar zusätzliche Hilfs-Funktionen hinzu damit man Strings auch mit Zahlen recht einfach zusammenbasteln
  kann. Beispiel: sString = 5 + sString + '_' + true + "HeHo" + 55.9; -> 5MyString_1HeHo55.9
  Damit kann man nun relativ einfach an vielen stellen String::Format() ersetzten was vorallem dann sehr sinnig ist wenn
  dort auch noch Strings miteingewoben werden sollen... man also GetString() nutzen muss. GetString() sollte man jedoch
  wo immer möglich in den PL innereien vermeiden da man sich für auf ein String Format (sollte IMMER Unicode sein) festlegen
  muss. Zudem vergisst man bei String::Format auch mal schnell GetString() und dann bekommt man Schrott zurück - der VC Compiler
  meckert das ja leider nicht an. Am besten & flexibelsten & sichersten ist das String-System, wenn ALLE String Operationen
  KOMPLETT über die String Klasse gemacht werden und GetString() NUR genutzt wird um z.B. dem OS den String zu übergeben.
  (sprich, um mit der Welt außerhalb von PL zu Kommunizieren *g*) Hält man sich an diese Spielregel, so braucht man sich nicht
  darum zu kümmern ob man gerade mit ASCII, Unicode, UTF-8 oder weis der Teufel was arbeitet - man verwendet einfach 'PL-Strings'
  und gut iss. ;-)
  Was noch fehlt sind Unicode-String Buffer die ich als nächstes angehen werde.



>> 26.08.2006
[CO]
- System: GetProgramName() -> Gibt den Namen des laufenden Programms zurück. (z.B. 'c:\MyApplication\Test.exe')



>> 25.08.2006
[CO]
Alle Projekte:
- Nach dem öffnen eines FS Verzeichnisses wurde meistens nicht geprüft ob das gut ging - verbesserte dies um Crashs zu vermeiden
  falls das öffnen eines Verzeichnisses mal nicht klappen sollte.



>> 24.08.2006
[CO]
Alle Projekte:
- Fand noch ein paar Stellen an denen anstatt stricmp/strcmp die String Funktionen verwendet werden können.
- Es gab noch ein paar Interface-Stellen wo 'const char*' anstatt 'String' verwendet wurde. Bei z.B. TestCase::GetName()
  ist dies aber durchaus Absicht da die Tests selbst nicht bereits von unserer String Klasse abhängig sein sollen.
- Entfernte extra 'const char*'-Funktionen in diversen Interfaces wie z.B. PLGeneral::Tokenizer so das 'nur' noch die eigene
  String Klasse verwendet wird. Da die String Klasse mittlerweile auch 'nur' einen Pointer auf einen 'char*' String halten
  kann 'ohne' dabei den gesammten String zu kopieren, ist dies ebenfalls kein 'Performance'-Problem. :)
- An ein paar Stellen wo String::CompareNoCase verwendet wurde wird nun == verwendet welches zwischen groß/kleinschreibung unterscheidet.
- Ersetzte wo möglich String::Format durch String Addition. Zum einen ist das etwas kompakter & besser Lesbar, aber viel wichtiger:
  Das wird so mit z.B. Unicode Strings weniger Probleme bereiten da es nicht mehr über GetString() abläuft.
- Entfernte einige <MyString.>GetString() wo das nicht wirklich nötig ist.
PLGeneral:
- String: Nahm die Print()-Funktion heraus da diese in der überarbeiteten String Klasse auch nicht mehr vorhanden ist. Ab
  jetzt muss man das immer über String::Format() machen, so gibt's nur noch eine einzige Funktion dafür (kein doppelter Code)
  und die 'Performance' wird darunter wohl auch nicht wirklich leiden. ;-)
- String::String(const char *pszString, bool bCopy = true, uint32 nLength = 0) -> Am Ende kann man nun noch optional
  die Länge übergeben. Dies ist u.a. in PLMesh::EffectLoaderFX recht praktisch da man hier einen sehr langen String hat
  wo man aber bereits genau weis wie lange dieser ist.
- Tokenizer::Start(const char *pszBuffer, long nSize) entfernt und die Codes in den anderen Projekten entsprechend angepasst.
- BufferedStringReader::BufferedStringReader(const char *pszBuffer, uint32 nSize) entfernt.



>> 23.08.2006
[CO]
- Da ich momentan an einer neuen String Implementation mit Unicode Support Arbeite muss ich zwangsläufig die String Dinge
  nochmal gaaaaaanz genau durchgehen. Dabei vielen mir gleich ein paar Dumme Dinge in der aktuellen Version auf - UND, wie es
  aussieht fand ich sogar unseren bösen Release Crash Bug!!! String::Replace(char nOld, char nNew) -> 'Set pointers to new
  location' war NICHT in Ordnung, denn da bereits nIndex drauf addiert wurde durfte man nicht einfach nochmal zusätzlich
  die String Länge draufzählen um das Ende des Strings zu bekommen... denn nun schoss man über den Speicher heraus und es
  wurde irgendwo herumgeschrieben wo das nicht sein durfte - KEIN Wunder das dies Probleme machte! *g*



>> 22.08.2006
[CO]
Alle Projekte:
- Die Projekte verwenden nun die .lib's in PLSDK/Actual/libs anstatt die aus den build/win32 Verzeichnissen.
PLGeneral:
- Stellte TinyXML von 2.4.3 auf 2.5.0 (Beta) um. Da etwas an der Lib verändert wurde muss diese auf jedenfall noch
  gepackt vorliegen damit man selbst neu übersetzen kann. (tinyxml_2_5_0_changed.zip)



>> 21.08.2006
[CO]
- XmlDocument: GetErrorDesc() so erweitert das standardmäßig auch in den String geschrieben wird 'wo genau' der Fehler
  auftrat - das will man in den meisten Fällen natürlich auch direkt wissen. :)
  Mir viel dabei auf das die Xml-Datei Namen noch nicht den eigentlichen Klassen Namen entsprachen, änderte dies.



>> 17.08.2006
[SB]
- Bei Log::Open() den Paramter für den LogFormater mit dem Standardwert "" versehen, falls man keine Parameter mit angeben möchte
- Log::GetLogFormater() gibt nun kein const-Objekt mehr zurück, da man ansonsten auf die Optionen, die dieses Objekt zur Verfügung stellt,
  gar nicht zugreifen kann. Das Objekt muß also auch veränderlich sein, damit man sich den LogFormater zurückgeben und dann bequem
  dessen Optionen ändern kann
- Einige Kommentare überarbeitet



>> 16.08.2006
[SW]
- Log: XmlLogFormater hinzugefügt.



>> 14.08.2006
[CO]
- String: Überarbeitete die Replace()-Funktion nochmal sorgfältig, z.B. war bereits der 'Count' am Anfang nicht ok. Die nochmals
  etwas erweiterten String Tests konnten nun keine Fehler mehr feststellen. (was allerdings leider nicht bedeutet das nix mehr
  drin wäre ;-)



>> 13.08.2006
[SW]
- HTML LogFormater hinzugefügt: Und im zuge dieses LogFormaters die OpenFunktion des Logs um den Parameter sParameters erweitert.
  mit diesem Parameter ist es nun möglich die LogFormater bezogenen Parameter zu ändern, welche ans RTTI angebunden sind.
  beim HTML LogFormater sind das die Parameter Title(zum setzten des HTML-Titels), Header(dieser Text direkt nach dem <body>-tag geschrieben)
  Background(zum setzen einer Background farbe bzw. bild) und DefaultTextColor(zum setzten der default Farbe für den Text).
- Log::GetLogFormater hinzugefügt. Hiermit ist es möglich sich den aktuellen LogFormater zu hohlen um dann optionen des LogFormater zu ändern.
  (z.b. beim HTML LogFormater kann man darüber die Formatierung der Meldungen für jeden Loglevel seperat angeben).
- Log: die maximale anzahl der Loglevel von 2^32 auf 255 reduziert, da chris und ich glaube das kaum jemand mehr als 255 Loglevel brauchen wird.
- String::Replace: Hier wurden die restliche Zeichen des alten Textes nicht in den neuen String übertragen, nachdem der eigentliche Replace beendet war.



>> 12.08.2006
[CO]
Log Änderungen:
- Bei LogLevel wieder meine Änderungen eingespielt, also wie besprochen das nur mit 'Debug'. Bei der Ausgabe steht dann auch
  nur 'Debug' - wie Stephan auch merkte wird das hier zuviel Text, das einzige was ich noch mehr hier habe ist das bei Debug
  wirklich 'nur' Debug und nicht Debug0 steht. Erst bei 'User Debug' Levels steht dann Debug1 etc. dabei.
- Verschob das Makro wieder nach oben wie Stephan es vorschlug, unterschied macht das keinen. Ich selbst geh die Codes nur
  immer von oben nach unten durch, und wenn dann oben etwas verwendet wird das aber 'rein Code liniear' gesehen erst 'unten'
  definiert wird sieht das für mich immer etwas merkwürdig aus... aber bei Makros iss das ja Funktionsmäßig kein Unterschied...
  und wenn es euch oben besser gefällt schreiben wir das mit den Makros *immer* oben.
- Wie Stefan vorschlug bei PL_LOG wird vor Level PLGeneral::Log:: eingefügt -> passte alle Codes an, viel schlanker so das nun ist :)
- Nahm wie von Stephan vorgeschlagen die Update-Funktionen heraus, fügte nun *aber* wie von mir geschrieben eine Flush Funktion
  hinzu damit ich von PLEngine::SNConsole aus einen Flush ERZWINGEN kann unabhängig vom Flush Log Level das die Konsole natürlich
  *nicht* ändern soll... zusätzlich *MUSS* dort auch noch geprüft werden ob sich die Datei seit dem letzten Check geändert hat,
  sei es durch ein früheres Log Flush oder durch eine Datei änderung des Users. (warum auch immer er eine machte)
  Derzeit ist das OS abhängig Implementierte, aber das überarbeite FS wird dann ja solche Infos ebenfalls bereitstellen so das dies
  dann universell machbar ist.
- ... bei dieser neuen Flush Funktion merkte ich das Log::Write() noch nicht ganz ok war. Denn sobald m_qLastMessages einmal voll war,
  wurde nach jedem Output flush ausgeführt. Darum fügte ich m_nFlushMessages hinzu. Bei jedem Eintrag wird das um eines erhöht, und
  erst wenn m_nBufferedMessages erreicht ist wird dieser Counter zurückgesetzt und ein Flush ausgeführt.
- Fügte nach 'Quiet' noch ein Log Level namens 'Always' ein. In SNConsoleBase::ProcessCommand() *muss* der gerade eingebene
  Befehl *immer* unabhängig vom aktuell Eingestellten Log Level ausgegeben wird, außer natürlich Log Ausgaben sind wieso auch
  immer mal komplett deaktiviert. Darum ist 'Info' hier nicht nutzbar. Wenn jemand da eine andere Idee hat wie man das lösen könnte gebt
  bescheit... so wie das jetzt im Augenblick alles ist läuft auch die PL Konsole wieder so sauber wie vor der Log Umstellung.



>> 08.08.2006
[SB]
- Kleinen Fehler im Log-Makro behoben: __LINE__ ist eine Zahl, daher muß es im printf-Style mit %d
  in den String eingefügt werden, das %s führte natürlich zu einem Crash



>> 07.08.2006
[CO]
Alle Projekte:
- Stellte auf das neue Log System um



>> 06.08.2006
[CO]
- Timer um Funktion GetTimer() erweitert. Hierbei handelt es sich um einen allgemeinen Timer auf den einfach der aktuelle
  Zeitunterschied bei jedem Update addiert wird.



>> 31.07.2006
[CO]
- Array<AType>::Add(const AType Elements[], uint32 nCount): Hier habe ich Vorsichtshalber das memcpy durch Element weise
  Kopieren ersetzt, denn soetwas wie memcpy kann ja leider sehr schnell nach hinten Losgehen vorallem wenn man etwas komplexere
  Klassen direkt nutzt. Es ist zwar noch memset drinnen um auf *ausdrücklichen* User Wunsch neue Elemente zu Initialisieren,
  da wüsste ich allerdings nicht wie man das anderst machen könnte, einfach jedem Element '0' oder so zuweisen geht ja nicht.



>> 28.07.2006
[CO]
- In SystemLinux/SystemWin32 wird im Konstruktur nun auch srand aufgerufen um den Zufallsgenerator zu Initialisieren. Bis
  jetzt stand in PLMath::Math ein Kommentar das man dies selbst über diese Funktion machen muss, und in PLEngine wurde dies
  dann auch gemacht... allerdings sollte man soweit irgend möglich auf OS/Standardfunktionen verzichten um eventuellen
  Inkompatibiläts oder Makro Problemen gleich von anfang an die Luft anzuschnürren.



>> 26.07.2006
[CO]
- Stellte alles auf die neue HashMap um und nahm die alte HashTable Klasse heraus. Beim Umstellen viel mir auf, das wenn
  etwas aus einer HashMap entfernt wurde das Objekt selbst übergeben wurde, und nicht dessen Name. Wann immer möglich sollte
  man Namen/Keys übergeben da diese *sehr* viel schneller gefunden und entfernt werden kann - bei einem Objekt/Zeiger muss
  man erst die GESAMMTE HashMap durchlaufen um den entsprechenden Eintrag zu finden.
- Nahm an ein paar Stellen 'stdio.h' etc. heraus wo man dies nun nicht mehr benötigt. (vor der String Umstellung brauchte man das
  dort wohl noch) Gerade in Headern sollte man es soweit möglich vermeiden solche Header einzubinden um eventuellen Problemen
  die dadurch entstehen können zu vermeiden. (Makros etc.)
  Das ist momentan zwar noch nicht Optimal, zeigt aber wo es hingehen könnte/sollte. So bekommt man dann auch hoffentlich weniger
  Probleme wenn man mal einen Memory Manager/Tracker hinzufügt, denn manche dieser Standard Header überschreiben new etc. was
  dann ziemlich ungünstig ist.



>> 23.07.2006
[CO]
- Fügte wie vor einigen Wochen mit Stefan bereits besprochen String::SetCharacter() hinzu.
  Ersetze in FSTools::ValidatePath() 'sValidPath.Delete(0, 1); sValidPath.Insert(&c, 0, 1);' durch 'sValidPath.SetCharacter(0, c)'.



>> 22.07.2006
[CO]
- FSTools::GetDirectory(): Hier habs noch einen Bug, wenn in einem gegebenen Pfad kein Verzeichniss vorhanden war, wurde der
  gesammte String als Verzeichniss zurückgegeben was aber sicherlich nicht gewollt war. Es wird in dem Fall nun ein leerer 
  String zurückgegeben. Das gleiche in FSTools::GetFirstPath(). Auch musste FSTools::ValidatePath() angepasst werden da GetFirstPath()
  es wie es bereits in der Funktions-Kommentierung stand am Ende ein '/' hat. Der File System Unit Test läuft nun ohne das
  'Fehler' festgestellt werden. (vorher gabs Fehler bei den zip-Tests)
- Stephan fand gestern noch einen Fehler in XmlDocument::SaveFile(), hier wurde FSTools::GetPathPrefix() anstatt FSTools::GetDirectory()
  verwendet um das Verzeichniss herauszufinden in dem sich die Datei befindet. Solche Stellen gabs noch ein paar mal und ich korrigierte
  das überall.
- Überall wo man eine Datei öffnet um einen Tokenizer darauf arbeiten zu lassen wird eine Datei im Binary Modus geöffnet, ansonnsten
  im Text Modus. Diese Stellen waren bereits mit einem [TEST] versehen und Stefan und ich hatten das auch bereits vor einer weile kurz
  besprochen. (Immer Text Modus kann Probleme machen, und häuftig ist/war das leider auch der Fall :(
- Den Fehler in RefCount<AType>::Release() behoben den ich bereits am 16'ten gefunden hatte. Fügte desweiteren zur Vollständigkeit
  == und != für 'Direkte Zeiger' hinzu. Ebenfalls wird nun VOR einer Zeiger zuweisung geprüft ob dies bereits der aktuell gesetzte
  Zeiger ist, machte man diesen Test nicht, konnte es zu einem üblen Crash kommen wenn man einen Reference Counted SmartPointer sich
  selbst zuwies. Die entsprechenden Bast Tests laufen nun sauber & stabil.



>> 21.07.2006
[SW]
- Linux port Änderungen von Christian teilweise angepasst/fehlendes hinzugefügt.



>> 16.07.2006
[CO]
- Xml-Klassen: Diverse Definitionen nun mit groß/kleinschreibung geschrieben. Das ist zum einen Lesbarer, und manchmal sogar
  etwas kürzer da man keine '_' mehr braucht.
- Types.h: Nahm einige mittlerweile total veraltete Definitionen heraus (das meiste wurde auch überhaupt nicht mehr genutzt)



>> 16.06.2006
[SW]
- GetOpts in CmdLineParser umbennant
- CmdLineParser:
  eine Parse-funktion für PLGeneral::Array<PLGeneral::String> hinzugefügt.
  und 2 statische funktionen ( String CmdArrayToString(int argc, char** argv) und
    Array<String> CmdStringToArry(String cmd_str) )
  hinzugefügt.
  Die 1. Funktion Convertiert das char argumenten Array in ein String um
  Die 2. Funktion Convertiert ein String in ein Array<String> um.
- PLMain übergibt nun ein PLGeneral::Array<PLGeneral::String> für die cmd-Parameter



>> 13.07.2006
[CO]
- HashString<AType>::~HashString(): Hier fehlte ein [], die Klasse ist zwar sowieso veraltet und mittlerweile durch HashMap
  ersetzt, aber solange das noch drinnen ist müssen eventuelle Bugs raus :)
- String::GetSubString(): Es wurde Speicher angelegt, korrekt gefüllt und einem String() Konstruktur übergeben, da dieser jedoch
  selbst den String kopiert und nicht den Zeiger übernimmt, hatten wir danach ein Speicherleck. Hab dem String(const char *pszString)
  Konstruktor erstmal einen Optionalen Parameter geben über den man dann festlegen kann das dieser Speicher übernommen, und nicht
  kopiert werden soll... hat Vorteile wenn man das festlegen kann, ist aber auch etwas 'Gefählich'. Läd man z.B. eine Datei ein,
  so kann man den 'Buffer' nun direkt an String übergeben ohne das nochmal kopiert und danach der eingelesene Buffer wieder
  gerstört werden muss. Standardmäßig wird aber immer Kopiert.
- String: Dem StringBuffer muss man nun immer die Länge des Strings übergeben. Da diese IMMER bekannt ist, ist es einfach nicht
  so prall diese vom StringBuffer nochmals ermitteln zu lassen. Zudem ist der Zeiger auf den String innerhalb es StringBuffers
  NIE NULL, sobald es NULL wird, wird auch der StringBuffer nutzlos... Nahm daher auch den StringBuffer Konstruktor ohne
  Parameter heraus. Auf z.B. m_pStringBufffer->GetString() muss man daher NIE prüfen da es NIE NULL sein kann - bis auf eine Stelle
  in der String Klasse wurde das auch nie geprüft. :)
  Machte die interne StringBuffer Implememtation inline und nahm 'Sicherheitsabfragen' wie z.B. pszString == NULL heraus da diese hier
  einfach nur Sinnlos sind, es ist schlichtweg ein ganz übler Fehler der eigentlich NIE passieren dürfte wenn hier mal NULL kommt,
  und wenn das mal der Fall ist, so ist das ein Bug in der eigentlichen String Implementation der behoben werden muss.
- DynLibManager::~DynLibManager(): Hier wurde der Iterator nicht wieder gelöscht
-> Die oberen Bugs fand ich als ich zum Testen mal den Memory Manager von http://www.fluidstudios.com/ im PLGeneral
   Header includierte, der merkte sofort das in der Hash Table der Speicher anderst wieder freigegeben wurde als er erzeugt wurde.
   Auch wurde ein Speicherleck in String::GetSubString() angemeckert - und tatsächlich war was noch was... wir sollten uns
   wohl dranmachen unseren eigenen kleinen Memory Manager/Tracer zu schreiben, denn gerade bei solchen Speicherlecks hilft das
   enorm viel.



>> 29.06.2006
[CO]
- Bitset::Resize(): Das gleiche wie gestern in Array::Resize()



>> 28.06.2006
[CO]
- Array::Resize(): Hier konnte es zu Problemen kommen wenn ein Array intern bereits genug Elemente hatte und nach einem
  'Größe ändern' bereits alle Elemente 'hinzugefügt' sein sollten. Erstaunlich das dies bis jetzt noch nicht aufgefallen war.



>> 26.06.2006
[CO]
- CmdLineParser: 'DEBUG' zu '_DEBUG' gemacht damit das unter VC klappt



>> 17.06.2006
[CO]
- Container: Neue Funktion 'uint32 Add(const AType Elements[], uint32 nCount)'



>> 14.06.2006
[SB]
- Style-Anpassungen an GetOpts vorgenommen. Bitte mehr auf Spaces und Tabs achten
- PLMain arbeitet nun nur noch mit PLGeneral::String



>> 07.06.2006
[SW]
- Neu Klasse GetOpts hinzufgefügt. Mit dieser Klasse läßt sich ähnlich, wie die getopt funktion unter linux, Optionen parsen.
  Die Klasse wertet nur die Optionen aus welche ihr vorher bekannt gegeben worden sind.



>> 05.06.2006
[CO]
- ResourceManager: Neue Funktion: LoadResource(): Create() sollte jeweils NUR eine Resource erzeugen, aber diese nicht auch noch
  eventuell gleich einladen... dafür ist nun die neue Funktion da. Siehe PLMesh Tagebucheintrag von heute für mehr Informationen.



>> 04.06.2006
[CO]
- String: Vor ein paar Tagen hatte ich in der String Klasse StringBuffer aus dem Interface in die Implementation verschoben
  damit das Interface möglichst keine Implementations Details enthält und etwas übersichtlicher ist. Allerdings konnte man nun
  nicht mehr beim Debuggen ohne weiteres 'in den String' schaun was oft sehr hilfreich ist. Machte daher diese Änderung wieder
  zu gunsten des Debugging rückgängig. Fügte auch gleich ein kleines Kommentar hinzu warum das public ist, nicht, das ich in
  ein paar Jahren wieder vergessen habe wieso das public ist und wieder auf die schlaue Idee komme das in die Implementation
  zu verschieben. ;-)
- Map: Neue Funktion: Replace() -> Stephan viel auf das diese Funktion welche recht nützlich ist noch fehlte



>> 30.05.2006
[CO]
- String: Mir viel gerade auf das wir zwar operator =(const char *pszString) hatten zum String kopieren, aber keine Funktion
  wo man nur eine bestimmte Anzahl von Zeichen kopieren konnte. Also fügte ich eine Copy()-Funktion hinzu welche bereits
  im OpenGL Renderer verwendet wird. Ersetzte außerdem 'strcpy' durch 'strncpy' da das erstere mittlerweile 'deprecated' ist
  da keine überprüfung auf Speicherüberlauf. Nahm auch ein paar mehr oder weniger überflüssige 'strlen' heraus.
  Verschob die interne StringBuffer Klasse in die String.cpp Datei damit das Interface etwas aufgeräumter ist.



>> 25.05.2006
[CO]
- Module::GetClasses() die gleichen Parameter wie bei ClassManager::GetClasses() verpasst damit es einheitlich ist.
  Die Codes der Funktionen sind identisch, baute am Anfang noch eine Abfrage ein ob alle Regestrierten Klassen zurückgebenen
  werden sollen, in diesem Fall kann man sich extra Arbeit sparen und einfach die Klassen Liste zurückgeben. In
  PLEngine::GuiDebugScene::UpdateClassList() macht es die Sache mit dem einheitlichen GetClasses() auch etwas einfacher da
  ich mir dort gleich eine Liste mit in Frage kommenden Klassen zurückgeben lassen kann ohne per Hand aussortieren zu müssen.
  (der Grund für diese Änderung :)



>> 23.05.2006
[SW]
- Linux backend zum filesystem auf die Strings umgestellt



>> 22.05.2006
[CO]
Alle Projekte:
- Fand in diversen Projekten noch Stellen wo man z.B. Vector3::ZERO einsetzen konnte anstatt ein neues Temporäres Objekt zu erzeugen.
  Fand auch jede Menge stellen in denen man Werte direkt den Konstruktoren übergeben konnte anstatt diese Werte intern erst
  initialisieren zu lassen um anschließend einen Wert zuzuweisen.
- Ein paar Variablen Namen angepasst wo man z.B. einen Zeiger auf Zeiger hat (also z.B. **ppMyPointer)
PLGeneral:
- String::LastIndexOf(): An ein paar Stellen in den Codes wurde der Rückgabewert in uint32 gespeichert was probleme gab wenn
  nichts gefunden wurde und '-1' daher als Ergebniss kam.
- FileSystem: IsBaseDir() hinzugefügt. Da es bereits auch IsSearchPath() gibt und ich bereits an ein paar Stellen umständlich
  per Hand prüfte ob ein gegebener Pfad ein Basis Verzeichniss ist oder nicht um z.B. diesen Pfad dann gegebenenfalls während
  dem einladen einer Szene Temporär als Basispfad einzusetzen, denk ich diese Funktion hat im FS seine Existensberechtigung. :)
  Machte bei der Gelegenheit gleich ein paar int zu uint32, damit verschwinden ein paar Compiler cast Warnungen an diversen
  Stellen.
- String: + Operator hinzugefügt damit man auch soetwas wie sResult = "A" + sString schreiben kann... wird bereits in
  PLSamplePhysics verwendet da hier recht praktisch.



>> 21.05.2006
[SB]
- Bösen Fehler im String behoben: Beim Duplizieren des StringBuffers hatte sich ein Fehler eingeschlichen, so daß nicht
  wirklich ein neuer Stringbuffer benutzt wurde. Daher wurde also im falschen Buffer geschrieben, so daß sich Strings veränderten,
  die eigentlich vorher kopiert worden waren. Ein weiterer Fehler war auch noch in Replace(char, char), dort wurde der Index
  innerhalb des Strings erst nach dem Kopieren des Buffers berechnet, so daß man hinterher wieder im alten Buffer landete.
- FileSystem auf String umgestellt. Nach dem Beheben des String-Fehlers funktionierte das meiste wieder erstaunlich gut, nur ein
  paar kleine Fehler die bei der Umstellung des FS passiert waren. Da die FS Funktionen aber aus heftigen String-Manipulationen
  bestehen, die nun dank String-Klasse völlig anders implementiert werden mußten als vorher, kann es aber gut sein daß noch weitere
  Fehler auftauchen. Also bitte mal verstärkt auf Probleme mit dem FS achten.
- Einige kleine Umstellungsfehler beseitigt
- String: Replace(char, char) vereinfacht, so daß nur noch eine Schleife benötigt wird. Schleife in Schleife wobei die erste dann
  abgebrochen wird ist unschön und sollte vermieden werden :-)



>> 18.05.2006
[CO]
- Nachdem Stephan beim übersetzen mit gcc bei der Funktion PLPlugins -> PLSceneNodes1 -> SNLightning.cpp -> GenerateLightning()
  eine Warnung bekam da etwas nicht const war und 'pPoint[f]+vDest' einmal als Parameter verwendet wurde was eine Warnung
  verursachte, fügte ich in GeneralWin32.h etwas hinzu so das auch bei uns bei Warnungs Level 3 bei soetwas eine Warnung kommt.
  (die Warnung empfinde ich als sinnig :)



>> 16.05.2006
[SB]
- Resourcen-Klassen auf Strings umgestellt
- Log-Klasse auf Strings umgestellt
- Profiling-Klasse auf ... Na ihr könnts euch wohl denken ;-)
- Einige Style-Anpassungen vorgenommen
- PLBase::FromString() und PLBase::VarChanged() auf String umgestellt und alle Projekte darauf angepaßt



>> 15.05.2006
[SB]
- Nochmal die XML Klassen verändert. Die vorherige Änderung hatte zur Folge, daß in den Klassen mit einem public Konstruktor
  erstmal eine interne Node erzeugt wurde, und dann wieder überschrieben wurde (Speicherleck). Leider fällt mit keine sinnvolle
  Lösung ein, denn auch eine statische Methode müßte ja intern einen Konstruktor aufrufen, gleiches Problem also.
  Habe daher den internen Konstruktor wie vorher wieder eingebaut, nur statt (void*) nimmt er nun (void*, int).
  Das ganze ist nur nötig, weil ansonsten ein Aufruf von z.B. XmlText("Bla") einen Compilerfehler wegen Aufruf eines privaten
  Konstruktors auslöst (void* passt "besser" als String, daher wird das genommen). Darum also nun der zusätzliche Parameter int,
  der wird zwar nicht verwendet, verhindert aber diesen Fehler.



>> 14.05.2006
[CO]
- Container/Functions.cpp hinzugefügt in dem die Implementation für die String Funktionen liegen. Sobald man die String Klasse
  nutzt muss man PLGeneral einbinden, aber nutzt man 'nur' die Container Templates ohne String Klasse, so braucht man PLGeneral
  nicht einzubinden - praktisch für z.B. Max Exporter damit man nicht für alles diese grässlichen stl Klassen nutzen muss. :)



>> 14.05.2006
[SW]
- POD-warnungen gefixed



>> 14.05.2006
[SB]
- RTTI Funktionen größtenteils auf Strings umgestellt. Dies bringt ein paar Probleme mit sich, denn da die RTTI Funktionen nun natürlich
  auch Strings zurückgeben, ist es nicht mehr so einfach möglich, festzustellen ob ein Fehler aufgetreten ist. Zumeist ist "" als
  Rückgabe zwar ein Anzeichen für einen Fehler, jedoch könnte natürlich auch der leere String eine gültige Variable sein.
  Anders herum ist es auch problematisch, denn wenn eine Variable auf "" gesetzt werden soll, wird jetzt vermutlich der Standardwert
  gesetzt - bei Strings kann jedoch wirklich "" gemeint gewesen sein. Dieses Problem bestand allerdings vorher auch schon, von daher
  sollte es erstmal keine größeren Probleme geben, nach den ganzen Umstellungen überlege ich mir genau, wie wir das mit den Standardwerten
  künftig machen wollen.
- Base besitzt nun keine Funktionen mehr, um die Variablen aufzuzählen oder an ein Var* zu kommen. Dafür muß dann halt
  GetClass()->GetVar() geschrieben werden (intern passierte ja sowieso nichts anderes). 
- GetVarTypeAsString() in GetVarType() umbenannt - die Funktion heißt nun als in "beiden Richtungen" gleich
- Config: m_szVariableValue entfernt. Sollte einmal der Fall eintreten, daß aus zwei Threads auf das gleiche Config-Objekt zugegriffen wird,
  würde das böse schiefgehen. Wir müssen daher in Zukunft darauf achten, daß alles Thread-Safe ist
- Tools: CombineStrings() entfernt. Diese Funktion ist äußerst unschön und wurde sowieso nur an einer Stelle verwendet, wo sie überhaupt
  nicht notwendig war. Die anderen String-Funktionen teilweise umbenannt, damit besser zu verstehen ist was die machen.
- Da die XML Klassen leider noch keine Strings verwenden, war es an einigen Stellen nötig, so etwas wie String(pszString).GetBool() zu schreiben.
  Damit diese Stellen hoffentlich später nicht vergessen werden, habe ich mich bemüht diese immer mit einem [TODO] zu markieren. 
- Es sind immer noch an viel zu vielen Stellen Konvertierfunktionen für Strings vorhanden, teilweise in dreifacher Ausführung und jedesmal
  leicht anders implementiert :-( Habe daher angefangen die zu vereinheitlichen, das werde ich aber in den kommenden Tagen erst richtig angehen.
- XML Klassen auf Strings umgestellt  



>> 13.05.2006
[CO]
- Erweiterte HashMap & SimpleMap um eine Vergleichs-Funktion. Da die definierbaren Funktionen recht universell sind, packte ich
  diese in eine gemeinsame Datei Namens 'Functions.h' welche im Container Ordner liegt.



>> 12.05.2006
[CO]
- Fand einen Bug in HashMap::CSlotsList::Add() -> Falls dies nicht das erste Element dieses Slots ist, so wurde der Next 
  Zeiger nicht Initialiert.



>> 11.05.2006
[SB]
- Class Groups wurden entfernt, da diese künstliche Definition von Gruppen so keinen Sinn mehr ergab.
  Da die Gruppen sowieso mit den Ableitungen von einer Basisklasse übereinstimmen, ist es sinnvoller gleich
  nach Basisklassen zu suchen. Nur das Aufzählen von Gruppen ist jetzt nicht mehr möglich, wird aber auch
  nicht wirklich gebraucht. Das Interface von ClassManager wurde daher so angepaßt, daß man sich entweder alle
  abgeleiteten Klassen einer Basisklasse direkt zurückgeben lassen kann, oder nur die direkt abgeleiteten.
  Einige Klassen wurden außerdem auf Strings umgestellt.



>> 09.05.2006
[SB]
- Externe Libraries wurden nach "external" verschoben und dort entpackt, damit das Projekt direkt übersetzt werden kann
  und keine Archive mehr entpackt werden müssen. Evtl. Sourcen können innerhalb der Lib-Verzeichnisse abgelegt werden,
  aber auch nur wenn diese wirklich benötigt werden, weil z.B. für PL etwas verändert werden mußte.
  Die Projekte wurden entsprechend angepaßt.



>> 26.04.2006
[CO]
- XML Klassen: Ein paar Leerzeichen & Tabs verbessert
- FileSystem: RemoveBaseDir(): Der übergebene Pfad muss zuerst 'korrigiert' werden so das dieser auf jedenfall mit dem
  intern gespeicherten Pfad übereinstimmt.



>> 22.04.2006
[CO]
- Stefan und ich besprachen gestern das Iterator Problem und entschieden das es das beste ist, zusätzlich in den Container
  Klassen neben GetIterator() noch GetEndIterator() anzubieten welches 'hinten' im Container startet. HasNext() gibt
  also 'false' zurück und HasPrevious() 'true'. Die Änderung in den Klassen war nicht wirklich aufwändig. Passte gleich die
  Stellen in allen Projekten an wo man einen Iterator für einen Rückwärtsdurchlauf verwendet.
- XmlDocument::LoadFile(): Hier gabs gleich zwei kleinere Problemchen. Man muss die Datei im Binärmodus öffnen damit TinyXML
  End Of Line (EOF) behandeln kann, und zum anderen fehlte ganz am Ende '\0'. Nun funktioniert im XML Test das Parsen von
  'demotest.xml' korrekt. In der neuen TinyXML Version wurde hier etwas geändert, darum konnte es nun Probleme geben.



>> 21.04.2006
[CO]
- HashMapIterator Konstruktor: Sind keine Elemente in der Map, so wird der Konstruktor nun sofort wieder verlassen da man
  ja bereits weis wie die Suche nach dem ersten Map Element ausgehen wird. Ist NUR ein Element drinnen ist es allerdings
  etwas Problematisch. Hab das nun erstmal so gemacht das man ein nächstes aber kein Vorheriges Element zurückbekommt. Hier
  muss man sich wirklich überlegen wie man diesen Sonderfall behandeln will, denn HasPrevious() gibt hier nun momentan immer
  false zurück. Dieses Problem gibts in jeder Iterator Implementation.
- Bei der Gelegenheit schaute ich gleich nochmal die Container Klassen durch und entfernte überflüssige Tabs & Leerzeichen



>> 20.04.2006
[CO]
- Container Klassen um Copy-Konstuktoren für den eigenen Typ erweitert



>> 17.04.2006
[CO]
- Stellte auf TinyXML 2.4.3 um. Anscheinend wurde intern etwas an den Strings geändert, wird hier nun NULL übergeben gibts
  einfach einen Crash. Daher musste nun in
    XmlDeclaration::XmlDeclaration(const char *pszVersion, const char *pszEncoding, const char *pszStandalone)
  eine Sicherheitsabfrage rein.



>> 08.04.2006
[CO]
- Pool & FastPool: FreeElements(): Hatte vergessen den Fall zu berücksichtigen wenn gerade überhaupt keine Elemente vorhanden 
  sind...
- Bitset: Machte einige Funktionen inline



>> 05.04.2006
[CO]
- Pool & FastPool: FreeElements(): Die alte Implementation war viiieeel zu umständlich. Man muss einfach nur die gesammte 
  Liste gerade verwendeter Elemente in die Liste der freien Liste 'anhängen'... das macht Pool & FastPool dort wo man sehr 
  häufig Elemente einfügt, löscht und alles komplett zurücksetzt extrem Performant. :)



>> 28.03.2006
[SB]
- Base::GetClassName(): return false bei "const char *" ... ? in return NULL geändert :-)



>> 22.03.2006
[CO]
- Base::GetClassName(): Sicherheitsabfrage ob Klasse vorhanden ist eingebaut



>> 12.03.2006
[SW]
- Fehler in PLGeneral/Main.h behoben, explizites angeben des Namespaces für String da nicht immer
  sicher ist, das "using namespace PLGeneral;" vorher "verwendet" wurde wenn dieser Header includiert wird.
- Fehlerausgabe unter linux hinzugefügt, wenn das laden einer LIB fehlschlug.



>> 27.02.2006
[SW]
- SemaphoreLinux.cpp: Der Check für den Maximalen wert des Semaphore eingebaut.
- TheadLinux.cpp: Der Execution Mutex (Er wird verwendet um Join(Timeout) zu implementieren ) wird
  in Terminate() und in Join(Timeout) explizit unlocked.
  In Terminate() wird er unlocked weil der Thread hier nichtmehr dazu kommt den Mutex selbst freizugeben.
  Wenn in Join(Timeout) der Mutex->Lock(Timeout) erfolgreich war, so muss der Mutex dort auch unlocked werden,
  da sonst beim nächsten start des selben Thread-objectes der Thread nicht im versuch des "Locken" des Execution-Mutex
  blocked.



>> 27.02.2006
[SB]
- Ebenfalls noch einige kleine Style-Dinge hochgeladen. Das mit den Tabs und Freizeichen ist manchmal Geschmacksache,
  vor allem wenn man Variablen untereinander anordnen will etc. Am Anfang einer Zeile sollte jedoch immer Tab verwendet
  werden. Ebenfalls sollte darauf geachtet werden, daß Freizeilen auch wirklich frei sind, sprich keine Leerzeichen oder
  Tabs darin enthalten sind
- Einige kleine Änderungen im Linux Port:
  - MutexLinux: Habe den pthread mutex von einem Pointer in eine direkte Variable verwandelt, da bei allen Beispielen
    die ich gefunden habe keine Pointer verwendet wurden, sondern die Struktur direkt. Die Variable heißt nun entsprechend
    m_sMutex, da es sich um eine Struktur handelt. Das mit dem Pointer war natürlich auch in Ordnung, allerdings scheint
    man sich das dynamische Erstellen hier sparen zu können, es ist also nicht notwendig (deswegen aber nicht falsch).
    In dem Falle hätte allerdings nach pthread_mutex_destroy() noch das Objekt selber per delete gelöscht werden müssen,
    da die Funktion dies allem anschein nach nicht tut (wie sollte sie auch unterscheiden, ob das Objekt dynamisch erzeugt
    worden ist oder nicht). Und es ist nicht notwendig, beim Portieren die gleichen Namen zu verwenden wie im Win32 Port -
    dort handelt es sich ja um ein Mutex-Handle, welches man vom System zurückbekommt, daher m_hMutex, handelt es sich aber
    dann beim Linux Port um einen Pointer, so sollte auch der Name in m_pMutex oder wie jetzt für eine Struktur m_sMutex
    verändert werden.
  - Die System-Ports sollten möglichst die Terminologie der entsprechenden System übernehmen, damit sich ein Windowsprogrammierer
    z.B. im Windows-Port gleich zurechtfindet und ein Linux-Programmierer im Linux Port. Daher sollten die Datentypen entsprechend
    angepaßt werden und nicht per Definitionen vereinheitlicht werden - dies ist ja auch nicht mehr nötig, denn es handelt sich
    ja gerade um systemspezifische Klassen, welche nur im entsprechenden System funktionieren müssen. Das unabhängige Interface
    wird ja von den Klassen System, Thread, Mutex etc. bereitgestellt und benutzt die Impl-Klassen als Backend. Daher besteht
    also in den Backends selber keine Notwendigkeit mehr, irgendwelche Datentypen umzudefinieren oder zu vereinheitlichen :-)
  - DynLibLinux: Habe daher HANDLE m_hModule in void *m_pLib umbenannt
  - ThreadLinux: Variable in m_nThreadID umbenannt
  - ThreadLinux: In RunThread lpParameter in pParameter umbenannt. lp ist wieder nur für Windows und den dortigen Datentypen LPVOID üblich
  - ThreadLinux: In RunThread ppThread in pThread umbenannt. pp deutet auf einen zweifachen Pointer hin, es ist jedoch ein direkter Pointer
  - ThreadLinux: m_pMutex wurde nicht in jedem Fall initialisiert, jedoch später benutzt. Nun wird es immer mit NULL initialisiert
  - Die neuen Member-Variablen wurden dokumentiert
  - Variablen sollten immer im kleinst möglichen Kontext deklariert werden, also am besten beim ersten Benutzen und dann gleich
    initialisieren. Wenn es anders geht also möglichst nicht am Anfang einer Methode die Variablen deklarieren und dann erst
    später benutzen
  - Bitte Debug-Code immer mit [DEBUG] kennzeichnen
  - In den Kommentaren "Windows" durch "Linux" ersetzt :-)
- Der Linux Port ist wirklich schon sehr gelungen, ist einfach toll wie übersichtlich das jetzt schon geworden ist :-)
  Hier noch ein Paar Anmerkungen bzw. Dinge die noch getan werden müssen:
  - ThreadLinux: Die Verwendung von m_pMutex muß noch etwas überarbeitet werden. Beim Join beispielsweise muß wohl nicht mehr Unlock()
    aufgerufen werden, dann wenn der Mutex noch gelocked wäre dürfte pthread_join gar nicht zurückgeben. Außerdem ist das Löschen
    des Mutexes an vielen Stellen nicht ok, denn dann geht der Aufruf beim nächsten Starten des Threads schief, da der Mutex nicht
    mehr da ist. Eigentlich müßte es reichen den Mutex nur im destruktor wieder zu löschen, beim Abbrechen des Threads etc. muß nur
    darauf geachtet werden, daß korrekt Unlock() aufgerufen wird.
  - SemaphoreLinux: Hier fehlt noch die Behandlung des Max-Values. Bitte mal schauen ob Linux das bietet, wenn nicht ist die Frage
    ob wir das selber einbauen, oder ob dieses Feature unter Linux halt nicht zur Verfügung steht. Falls wir das selber machen
    sollte dies vielleicht besser in Semaphore geschehen und damit einheitlich für alle Systeme. Blöd ist es natürlich wenn eine
    Semaphore auch von anderen Prozessen verwendet wird, aber in dem Fall würde auch jetzt schon das Mitzählen des aktuellen Wertes
    schiefgehen, und solange es dafür keine Systemfunktionen gibt ist das Problem wohl auch nicht zu lösen



>> 27.02.2006
[CO]
- Linux Dateien dem VC Projekt hinzugefügt (werden jedoch vom Build ausgeschlossen)
- Machte beim Linux hier und da ein paar kleine Style Änderungen damit alles wie aus einem Stück aussieht... die Linux 
  Implementation ist sehr viel übersichtlicher als vor dem PLGeneral umbaun - gute Arbeit Stephan. :)
- Mir ist aufgefallen das an einigen Stellen wo z.B. als Abtrennung von Funktions Sammlungen bei z.B. 
    //[-------------------------------------------------------]
    //[ Public virtual ThreadFunction functions               ]
    //[-------------------------------------------------------]
  oft keine zwei Leerzeilen waren - bis jetzt hatten wir es hier immer so gemacht das wir hier zwei Leerzeilen hatten um 
  die Funktions Blöcke schöner zu trennen so das man schon beim Überfliegen der Codes sehr schnell erkennt was zusammen 
  gehört. Ist natürlich wieder so eine Geschmacksfrage - ich persöhnlich finds so aber einfach übersichtlicher.
  Das ist natürlich wieder so ein mehr oder weniger Sinnfreies 'kleinmist' Zeug... allerdings erleichtert ein durchgängig 
  Einheitlicher Code Style enorm die Arbeit wenn man sich dafür Entscheidet eine Style Änderung vorzunehmen wie wir es in 
  der Vergangenheit ja schon recht oft gemacht hatten. :)
- An ein paar Stellen '/*<' durch '/**<' ersetzt... wenn ich solche Dinge per zufall finde, so ändere ich diese immer 
  gleich so das es nicht noch mehr Stellen werden... man arbeitet ja oft mit Copy'n'Past oder schaut nach wie es woanderst 
  geschrieben wurde. ;-)



>> 26.02.2006
[SW]
- Linuxport auf die Klassen-Umstellung angepasst
- In der Thread-klasse die Funktion Stop in Terminate umbenannt, da die Bezeichnung Stop in meinen Augen nicht 
  "Kill den thread" sondern "Sende thread ein signal damit er sich beendet" bedeutet.



>> 25.02.2006
[SB]
- Haupt-Header von 'General.h' in 'PLGeneral.h' umbenannt
- Projekte an Änderungen angepaßt



>> 23.02.2006
[SB]
- Habe mit der kompletten Umstrukturierung von PLGeneral begonnen. Das Projekt teilt sich ab jetzt in 3 Teile: Base, System und Core.
  In Base kommen alle Basisklassen und Datentypen, welche die Basis von PLGeneral bilden, also sprich Base, String, die Container, XML, Graphics etc.
  In System befinden sich die Klassen welche welche eine Abstraktion des Systems darstellen, also die frühere Platform Klasse, Filesystem, Threading, Libraries, Timing usw.
  In Core letztlich kommt dann das Application-Framework, welche PLGeneral zur Verfügung stellt. Das ist insbesondere das RTTI mit allen dazugehörigen Klassen, also
  Klassen, Module, Config etc. Das wird dann nach und nach ausgebaut, so daß ein richtig schönes Framework entsteht. Die Trennung von System und Core ist wichtig,
  denn dies sind zwei völlig unterschiedliche Dinge, es war daher nicht schön daß diese vorher zusammen waren.
- Die Platform-Klasse wurde entfernt, da diese nicht gut gelungen war. Dafür befinden sich in System nun alle systemabhängigen Klassen, jeweils mit einer
  Implementierung für das jeweilige System. Die Win32 Implementierung ist jeweils schon dabei, die Linux-Implementierung könnte Stephan nachtragen :-)
  Das meiste kann aus der alten Platform-Klasse kopiert werden, es hat sich inhaltlich nicht viel verändert, nur das Interface ist schöner geworden.
- Die System-Klassen benutzen nun ein Backend-System, es gibt also jeweils eine System-unabhängige Klasse als Interface, und eine Implementierungsklasse mit Ableitungen
  für jedes System. Das Interface besitzt dann einen Pointer auf die Implementierungsklasse. Das ist zunächst komplizierter, hat jedoch den Vorteil daß das Interface
  und die Implementierung komplett voneinander getrennt sind, damit entsteht nicht wieder so ein Chaos wie in der alten Platform-Klasse.
- Habe den Threads und der Synchronisation ein vernünftiges OOP System spendiert. Die Thread und Synchronisations Funktionen befinden sich in Threading, es gibt einen
  ThreadManager der die aktuellen Threads auflisten kann etc, für die Threads selber gibt es eine Klasse Thread, Mutex und Semaphore sind ebenfalls eigene Klassen.
  Damit ist dies nun endlich auch vernünftig objektorientiert, wie es sich für C++ gehört.
  Das schreiben eines Threads geht nun auf verschiedene Arten, bevorzugt aber so: Eine Klasse MyThread wird von Thread abgeleitet und ihre Run() Methode überschrieben.
  Mit new MyThread und pMyThread->Start() kann der Thread dann gestartet werden. Auf diese Weise hat der Thread ein Objekt zur Verfügung und muß nicht mehr über void*
  Pointer umständlich Daten übergeben bekommen. Bitte in Zukunft darauf achten auch bei neuen Funktionen gleich vernünftig objektorientiert zu arbeiten, und nicht plötzlich
  in unserem kompletten OOP Framework altbackene prozedurale Methoden zu verwenden. Auch ist es nicht gut das Win32 Interface inklusive der gesamten Kommentierung
  einfach zu kopieren, denn erstens legt man sich damit auf das oftmals merkwürdige Windows Interface fest, und zweitens hat Microsoft sicherlich ein Copyright auf seine
  Hilfetexte :-) Also wenn neue Funktionalität eingebaut wird bitte auch die Mühe machen das vernünftig zu designen, so daß es schön ins System passt.
- Beim Umbauen der Threads bitte wenn möglich von Thread ableiten, oder zumindest von ThreadFunction. Ich habe lange überlegt, ob ich die Möglichkeit eines Function-Pointers
  überhaupt noch anbieten will, habe mich dann dafür entschieden. Das heißt jedoch nicht, daß das nun überall einfach weiter verwendet werden sollte, da es am einfachsten
  ist das so umzubauen. Die OOP Methode ist viel flexibler und besser, der Funktionspointer sollte nur in Ausnahmefällen verwendet werden.
- Die System-Klasse wurde um ein paar nette Funktionen erweitert, so kann man nun z.B. den Computernamen und den Usernamen abfragen. Ebenfalls soll hierüber eine
  Versionsverwaltung implementiert werden, so daß z.B. Plugin-DLLs schnell feststellen können, wenn sie mit einer inkompatiblen PLGeneral.dll arbeiten. Auch dient dies
  natürlich den Log-Ausgaben. Das muß jedoch noch vernünftig implementiert werden.
- Die Methode GetCPUMhz() aus der Tools-Klasse wurde ebenfalls nach System verschoben.



>> 20.02.2006
[CO]
- Array, Bitset: RemoveAtIndex(): Fand und behob einen bööösen uint32 Umstell-Bug... war ja klar das so eine Umstellung 
  diese Viecher anlockt ;-)
  Resize(): Auch hier gabs noch einen heftigen Bug - wow, das ich das bis jetzt übersehen hatte, hm, die Container Tests 
  sind wohl noch nicht genau genug... :)



>> 12.02.2006
[SW]
Alle Projekte: Subversion:
- habe das property svn:eol-style für die neuen Dateien gesetzt.
    um dies automatisch zu machen sollten folgende optionen in der config-datei 
    von subversion vorgenommen werden:
    [miscellany]
    enable-auto-props = yes
    
    [auto-props]
    *.c = svn:eol-style=native
    *.cpp = svn:eol-style=native
    *.h = svn:eol-style=native
    *.inl = svn:eol-style=native
    *.dsp = svn:eol-style=CRLF
    *.dsw = svn:eol-style=CRLF
    *.sln = svn:eol-style=CRLF
    *.vcproj = svn:eol-style=CRLF
    *.sh = svn:eol-style=native;svn:executable
    *.py = svn:eol-style=native
    *.txt = svn:eol-style=native
    SCons* = svn:eol-style=native
    Makefile = svn:eol-style=native
    
    damit sollte jede datei die passende eol-kennung(bis auf die vc-projekt-dateien immer die kennung, welche vom OS verwendet wird)
    beim auschecken haben.
PLGeneral:
- Stellte die linux-thread-functionen auf pthread um.



>> 10.02.2006
[CO]
- Wie mit Stefan vorhin im Chat besprochen änderte ich die Stack & Queue Klassen etwas so das Pop nun NICHT mehr das 
  entfernte Element zurückgibt da dies ziemlich Problematisch war. Stattdessen sollte man sich das Element nun über 
  GetTop()/GetBottom() zurückgeben lassen und danach Pop() aufrufen - oder Pop() einen Zeiger übergeben der das Element 
  bekommen soll. (falls man nicht immer zwei Funktionen aufrufen möchte :)



>> 09.02.2006
[CO]
- Binominal Heap Iterator implementiert, vorwärts ging ja noch, aber rückwärts war etwas fies zu Implementieren. Da in 
  diesem Heap nur der Nachfolger, aber nicht der Vorgänger bekannt ist, ist das rückwärts durchlaufen auch nicht wirklich 
  gut von der Laufzeit her. Dort habe keinen Vorgänger Zeiger eingebaut da er hier unnötig ist und 'nur' die Iterator 
  Implementation für rückwärts durchlauf vereinfachen würde - da aber Iteratoren keine gängige Operation auf Heaps sind, 
  entschied ich mich dagegen hier im Binominal Heap pro Eintrag noch mehr Speicher zu verschwenden.
- Neue Heap Implementation: FibonacciHeap: Hat gewisse Ähnlichkeiten zum Binominal Heap, jedoch geht u.a. das einfügen 
  neuer Elemente superflott... dafür ist das entfernen von Elementen etwas Aufwändiger da hier dann auch gleich etwas 
  aufgeräumt werden muss. Ohne diese Funktion läuft es zwar auch korrekt, aber dann hat man im Prinzip nur eine 
  doppelt verkettete List und diese Struktur wird Witzlos. :)
  Wir haben nun drei gängige Heap Implementationen - das sollte fürs erste reichen.



>> 09.02.2006
[SB]
- Singleton hat nun wieder einen Destruction Guard, da die Benutzung des SmartPtr hier nicht möglich war.
  Aufgrund des static initialization order problems kann es vorkommen, daß der statische SmartPtr später initialisiert wird,
  als der Singleton. Beim Aufruf von GetInstance() wird also die Instanz erzeugt und im SmartPtr gespeichert, danach wird
  dann aber erst der SmartPtr initialisiert und somit der Zeiger wieder auf NULL zurückgesetzt, so daß beim nächsten Aufruf
  von GetInstance() eine zweite Instanz erzeugt wird und die erste natürlich auch niemals mehr gelöscht wird.
  Die statische Instanz welche das Löschen des Singletons überwacht darf also keine Daten haben, die initialisiert werden
  müssen, daher muß hier doch wieder der speziell darauf abgestimmte Destruction Guard verwendet werden
- Der Destruction Guard besitzt nun eine leere inline Methode, welche innerhalb des Singleton einmal aufgerufen wird.
  Dies ist notwendig, damit der Compiler die statische Instanz erzeugt, ansonsten scheint diese in einer template-klasse
  wegoptimiert zu werden, wenn nicht einmal darauf zugegriffen wird. Die Methode macht also nichts ist aber notwendig,
  damit der Compiler richtig arbeitet. Interessant ist, daß dieses Problem nur bei Template Klassen auftrifft, bei Nicht-Templates
  funktioniert das mit der statischen Instanz auch ohne solche einen Trick
- Im Singleton werden nun auch die Zuweisung und der Copy-Constructor deklariert, um ein Kopieren des Objektes und damit
  die Umgehung des Singletons zu verhindern
- Die unschöne Methode CheckInstance() wurde entfernt, statt dessen wird über ein Destroy-Flag überprüft, ob das Objekt
  bereits gelöscht wurde. Damit wird während der Deinitialisierung das Objekt nicht noch einmal neu erzeugt, nachdem es bereits
  gelöscht worden ist.
  Generell sollte man während der Deinitialisierung keine Singletons mehr verwenden, da diese schon gelöscht worden sein
  könnten - static DE-initialization order problem ;-) Also sollte z.B. in einem Destruktor eines Singletons nicht mehr auf andere
  Singletons zugegriffen werden. Sollte man es doch einmal tun muß auf jeden Fall der Rückgabewert von GetInstance() auf NULL
  überprüft werden, da dies nun zurückgegeben wird, falls die Instanz bereits gelöscht wurde
- Singleton generell noch etwas überarbeitet



>> 08.02.2006
[CO]
- Heap Interface um GetTop() und ExtractTop() erweitert um das 'oberste' Element anzufragen bzw. zu entfernen
- Neue Heap Implementation: BinominalHeap: Nachdem ich erstmal die Theorie soweit kapiert hatte war die Implementation 
  nicht soo schwer wie ich anfangs dachte, eigentlich sind nur CTree::Union() und ExtractTop() etwas kompliziert gewesen - 
  der Rest war 'trivial'. ;-)
  Die entsprechende Iterator Klasse muss ich noch Implementieren...



>> 07.02.2006
[CO]
- Für Heaps (Priority Queue) gibts nun wieder wie früher ein eigenes allgemeines Heap Interface da Heaps einfach etwas 
  anderes sind als Maps. (das erkannte ich erst wieder als ich mich wieder genauer mit den Datenstrukturen befasste :)
  Wie auch bei Container & Map hab ich Support für Iteratoren Implementiert. Dies ist zwar genauso wie bei Map eher 
  unüblich bei dieser Datenstruktur, jedoch ist das ein nettes Feature. In welcher Ordnung die Elemente beim Iterator 
  zurückgegeben werden kann man wie bei Map nicht wirklich vorausgesagen - man weis nur das das ERSTE Element jeweils das 
  größte/kleinste aller Elemente ist - je nach verwendeter Compare-Funktion.
- Binary Heap an neues Heap Interface angepasst
- Nam den Sicherheits-Test innerhalb einiger Container Iteratoren der prüfte ob der Container Zeiger gültig ist heraus 
  da total überflüssig - dieser Zeiger MUSS immer gültig sein, ansonnsten läuft gerade etwas total schief... ;-)
- Einige Container Iterator Implementationen waren noch nicht ganz korrekt.



>> 06.02.2006
[SB]
- PLGeneral_Rewrite Branch entfernt. Die Änderungen wurden größtenteils in den main Branch übertragen, der Rest muß sowieso
  noch einmal komplett überarbeitet werden, was dann direkt in den aktuellen Sourcen geschieht.
- Kleine Fehler in RefCountPtr und SmartPtr entfernt. Diese Klassen werde ich wohl nochmal gründlich durchgehen müssen, da der
  Compiler ja leider nur die Teile compiliert die auch wirklich benötigt werden. Und diese Klassen sind schon etwas kompliziert,
  da sie einige template Tricks verwenden :-)
- Singleton: DestructionGuard entfernt. Statt dessen wird der Zeiger nun in einem SmartPtr gespeichert, dieser löscht genauso wie
  vorher der Guard das Objekt wenn er selbst gelöscht wird (also am Ende des Programmes, da es sich um eine statische Instanz handelt).
  Diese statische Instanz wird auch korrekt initialisiert, was wohl daran liegt daß sie nicht selbst zum Template gehört - dies ist wohl
  ein Fehler der Sprache, daß dies nicht korrekt funktioniert.
  Singleton ist nun von RefCount abgeleitet, damit der SmartPtr vernünftig die Referenz halten und löschen kann. Die Ableitung ist
  jedoch private, da ansonsten jeder den RefCount erhöhen oder verringern könnte, und somit das Singleton ad absurdum führen würde.
  Damit der SmartPointer dennoch den RefCount nutzen und die Instanz löschen kann, mußte er als friend deklariert werden.
  Falls es Probleme mit dieser Lösung gibt, bitte Bescheid sagen, denn dies ist schon einigermaßen kompliziert - und bei den
  Templates noch durchzuschauen fällt hier schon etwas schwer :-)



>> 06.02.2006
[CO]
- Bitset: Die Anzahl der benötigten Integers wurde noch nicht immer korrekt berechnet + verbesserte das Initialisieren 
  der Bits. Container::GetSize() Kommentar etwas erweitert damit wirklich klar ist WAS hier zurückgebenen wird.
  (Kommentar also bitte nicht löschen :)
- Tokenizer: Da momentan + und - als einzelnde Zeichen betrachtet werden funktioniert ParseNumber() nicht korrekt - 
  negative Zahlen werden nicht mehr korrekt gesetzt. Entweder müsste man bei ParseNumber() nun nach Vorzeichen ausschau 
  halten oder wir behandeln diese Zeichen nicht als einzelnde Zeichen. (hab das erstmal auskommentiert damit alles sauber 
  läuft)
- FastPool: FastPoolElement: Virtuellen Destruktor etc. hinzugefügt damit alles sauber über die Bühne läuft



>> 05.02.2006
[SB]
- String: Konstruktor mit Printf-Funktionalität wurde entfernt, da dies nicht bei jedem String erwünscht ist.
  So war es unmöglich, einen normalen String der ein Prozentzeichen (%) enthält zu speichern. Statt dessen
  gibt es nun die statische Funktion Format, die einen formartierten String mit Printf syntax erstellt und einen
  String zurückgibt (named constructor).
- Tokenizer:
  - Fehler in ParseEquation(String, int&) entfernt - hier fehlte die Referenz, das Ergebnis wurde also nicht zurückgegeben
  - SingleChars zu {}()[]<>+.*/=,;" verändert. Damit dürfte die übliche Syntax von C Programmen besser abgedeckt werden
- Auf String::Format() umgestellt



>> 04.02.2006
[SB]
- String:
  - IsFixedNumeric() in IsNumeric() umbenannt. Man muß hier im Hinterkopf behalten, daß es um Eigenschaften der Zeichenkette geht (nicht um den Inhalt!),
     und das umfaßt z.B., ob diese nur aus alphabetischen Zeichen besteht, nur aus numerischen oder aus alpha-numerischen Zeichen. Diese Begriffe sind
     allgemein bekannt und daher sollten diese Funktionen nun sehr verständlich und eindeutig sein. An solchen Stellen sollte drauf geachtet werden, daß keine
     eigenen Begriffe erfunden werden, da dies außenstehende nicht verstehen würden, noch dazu wenn z.B. Fixed noch eine ganz andere Bedeutung hat
     (Fixkomma Zahl), das verwirrt die User dann noch einmal unnötig, in diesem Fall also lieber gleich nach allgemein bekannten Begriffen suchen, wenn es
     einem einmal nicht einfällt :-)
  - IsFloatingPointNumeric() entfernt. Diese Funktion gehört nicht in den String, da es sich nicht mehr um die Eigenschaft einer Zeichenkette handelt. Aus was
    für Zeichen eine Zeichenkette besteht kann direkt als Eigenschaft dieser Zeichenkette gesehen werden, dafür die Funktionen IsAlphaNumeric() etc.
    Hier jedoch geht es eigentlich schon um den Inhalt, und dafür sollte ein Parser zuständig sein. Abgesehen davon sollte so eine Funktion dann auch gleich
    ein anerkanntes Floating-Point Format erkennen, die sehen dann etwas komplizierter aus (123.4567E10 (f/d) o.ä.) Dafür gibt es aber genug Definitionen, die
    man dann benutzen kann. Im Moment bleiben wir beim alten Verfahren, da wir nicht alles auf einmal machen können, später werden dann solche Dinge gleich
    korrekt geparsed z.B. mittels regulärer Ausdrücke.
  - Einige Kommentare angepaßt
  - Bei einigen Funktionen const hinzugefügt
- Profiling:
  - Kleine Änderungen im Coding Style



>> 04.02.2006
[CO]
- Profiling: SelectNextGroup() & SelectPreviousGroup() behob kleine uint32 umstell Fehler
- String:
  - Compare Funktionen wie besprochen um Start Position Parameter erweitert, in der Implementation werden ein paar 
    Sonderfälle berücksichtigt in denen man auf einen Schlag weis ob die Strings gleich sind oder nicht - gerade beim 
    Vergleichen längerer Strings wird das enorm Speed bringen.
  - IsSubString() wie besprochen geändert und neue Funktionen IndexOf() & LastIndexOf() hinzugefügt.
  - IsCharacter() entfernt da mittlerweile überflüssig... IsCharacter() das kann man nun auch selbst per Hand in zwei 
    Schritten machen. (z.B. sToken.GetLength() == 1 && sExpected.IsSubString(sToken))
  - < und > Operatoren hinzugefügt um Strings Lexikographisch vergleichen zu können (für sortieren wichtig)
  - Neue Funktionen: Replace() in 3 Varianten, einmal für const char *, String und für Buchstaben - Ich würde wirklich gerne 
    diese spezielle Replace Funktion für Buchstaben behalten da die Implementation deutlich einfacher ist. Zwar wird auch 
    in der String-Replace Implemenation getestet ob es sich nur um Buchstaben handelt und dann eine schnellere Implementation 
    gewählt, aber in der const char * müsste ich dazu erst die Längen der Strings ermitteln lassen was hier ja nicht 
    'for free' ist... und will man wirklich nur Buchstaben austauschen ist diese extra Funktion handlich & Performant.



>> 03.02.2006
[SW]
- Linux buid: build is wieder fehlerlos unter linux
  habe in RTTIDefs.h den rückgabewert von CLASS_OFS von PLGeneral::uint64 auf size_t geändert.
  da size_t immer die passende länge auf dem entsprechenden sysstem hat.
  (32Bit-System -> 32 Bit, 64Bit-System -> 64Bit)



>> 03.02.2006
[CO]
- Container Klassen: Intern verwendete Klassen & Strukturen sind nun nicht mehr von außen 'sichtbar'... vorallem 'HashMap' 
  sieht nun in der Implementation ziemlich krank aus - dieses Template wirrwar ist kaum noch lesbar. ;-)
- String:
  - Compare Funktionen kann man nun noch optional die Anzahl der zu vergleichenden Zeichen übergeben, so muss man nicht erst 
    umständlich sich einen String & dann einen Substring davon erzeugen lassen damit man bestimmte Regionen von Strings 
    vergleichen kann.
  - Neue Funktion: IsSubString(): Prüft ob ein gegebener String ein Unterstring ist
  - Delete() fängt nun auch den Fall ab wenn der String nun leer ist
  - Print() prüft nun ob der übergebene String NULL ist (ansonnsten gabs einen Crash in '_vscprintf')
  - GetSubString(): Position Parameter wird auf korrektheit überprüft
  - IsAlphabetic() & IsAlphaNumeric(): Kommentare um jeweils eine kleine Beispielzeile erweitert, denn ich hatte total 
    verpeilt für was diese eigentlich da sind und nahm an es würde sich um 'ist keine Zahl/ist eine Zahl' Funktionen handeln. 
    Stefan klärte mich kurz im Chat auf und jetzt ist diese Sache natürlich total logisch - aber da es sicherlich auch 
    andere nicht auf anhib peilen werden lieber kurz nen Beispiel dazu. :)
  - Neue Funktionen IsFixedNumeric() (hm, besserer Name??) prüft ob der String eine Zahl ist, IsFloatingPointNumeric() prüft 
    ob es eine Fließkommazahle ist



>> 31.01.2006
[CO]
- HashMap: HashSlot zu einfacher Stuktur gemacht, das spart Funktionsaufrufe und ist auch etwas kompakter. HashSlot speichert 
  nun auch den Vorgänger, dadurch war nun auch die Implementation der 'Previous' Iterator Funktionen möglich - wobei diese 
  HashMap Iterator Implementation für 'vorwärts' & 'rückwärts' Support etwas Tricky ist... aber ich glaub das es kaum 
  einfacher gehen wird. :(
- SimpleMap Implementiert - diese Klasse verwendet intern 'Fast Pool' damit das häuftige Einfügen & Löschen etwas flotter 
  von dannen geht, aber zum auffinden der entsprechenden Einträge muss man natürlich sequentiell die gesammte Liste 
  durchgehen... diese Klasse sollte daher mit bedacht eingesetzt werden. Andere Map Implementationen wie z.B. 'Binary Heap' 
  sind hier deutlich flotter und diese Implementation hat noch den netten Seiteneffekt das die Elemente vom Iterator gleich 
  'nach Schlüssel geordnet' zurückgegeben werden was bei dieser Implementation 'for free' kommt. Bei SimpleMap und HashMap 
  ist dies nicht der Fall und ein geordnetes zurückgeben der Element zu 'erzwingen' wäre hier definitiv nicht gut da diese 
  Implementationen das einfach nicht 'unterstützen' und dies dann extra Implementiert werden müsste was dann recht langsam 
  wäre. Jede Implementation hat hier genauso wie die Container-Klassen vor und Nachteile die man geschickt nutzen sollte. 
  Wenn wirklich benötigt könnten wir später noch extra Funktionen anbieden die Elemente 'IMMER' geordnet zurückgeben - ob 
  nun performant oder nicht... aber in den meisten Fällen ist es egal in weiler Reihenfolge die Elemente zurückgegeben 
  werden und da sollten wir defintiv die Sache nicht unnütz künstlich ausbremsen.



>> 30.01.2006
[CO]
- Nahm wie mit Stefan besprochen die Funktion ExpectCharacter() wieder aus dem Tokenizer und implementierte eine vergleichbare 
  Funktion namens IsCharacter() in der String Klasse.
- Container, Map & Iterator Templates um virtuellen Destructor erweitert, auch bei Templates scheint dies Pflicht zu sein - 
  gut das genau zu wissen. :)



>> 29.01.2006
[CO]
- Prüfte über Doxygen ob die Kommentare soweit ok sind und verbesserte ein paar Stellen



>> 24.01.2006
[CO]
- Tokenizer: Neue Funktion: ExpectCharacter(): Ähnlich wie ExpectToken(), aber erwartet das der nächste Token ein einzelner
  Buchstabe ist welcher mit einem der übergebenen Buchstaben übereinstimmt. Wird bereits in Var::CheckMinMax() verwendet um 
  zu prüfen ob ein " oder ' vorhanden ist.
- Var::CheckMinMax() Funktionen an neuen Tokenizer angepasst
- Base::SetVars() an neuen Tokenizer angepasst



>> 23.01.2006
[SB]
- Tokenizer verändert, so daß bei Quotes erst die Anführungszeichen ("), dann der Inhalt und dann noch einmal die Anführungszeichen zurückgegeben werden.
  Ist das Wort leer, so wird es nicht zurückgegeben. Auf diese Weise kann der Tokenizer sowohl für strikte Syntax
  verwendet werden oder es kann wie bisher einfach der Inhalt der Quotes ausgelesen und weiterverarbeitet werden



>> 22.01.2006
[CO]
- Resource Manager & Profiling Klassen an uint32 angepasst damit die Warnungen verschwinden



>> 21.01.2006
[SB]
- Neue Tokenizer Klasse geschrieben. Intern benutzt diese nun eine vernünftige State-Machine (TheoInf läßt grüßen) ;-) Dies ist zwar u.U. etwas langsamer, sollte dafür
  aber wesentlich stabiler sein und ist vor allem verständlicher zu lesen
- Die Klasse arbeitet nun mit Strings anstatt mit char arrays
- Die Optionen werden nicht mehr beim Starten des Parsers festgelegt sondern über eigene Get/Set Methoden
- Die grundlegende Funktionalität des Tokenizers wurde besser von den erweiterten Parser-Funktionen getrennt. Diese sind zwar nach wie vor vorhanden, sollten aber nur
  eingesetzt werden, wenn keine strikte Syntax gebraucht wird. Im allgemeinen sollte der Tokenizer nur die Tokens liefern, danach muß der Output vernünftigt
  geparsed werden
- Neue Klassen: BufferedReader, BufferedStreamReader und BufferedFileReader. Diese Klassen werden benutzt, um Schritt für Schritt aus einem Stream oder einem
  Buffer zu lesen. Dies wird im Tokenizer verwendet, so daß dieser jetzt auch direkt aus Dateien parsen kann. Leider ist die Implementierung nicht so performant wie sie
  sein könnte, dies sollte später noch einmal überarbeitet werden. Außerdem sollte es eine Stream-Klasse geben, die Byte für Byte zurückgibt, der BufferedStreamReader
  könnte dann auf beliebige Streams angewendet werden. Auf diese Weise könnte jeder Stream verwendet werden, nicht nur Dateien sondern auch z.B. Netzwerk-Streams o.ä.
- Codes an neuen Tokenizer angepaßt



>> 21.01.2006
[CO]
- Etwas an den Container Klassen gefeilt, u.a. wird nun dort so möglich/sinnig uint32 anstatt int verwendet - dadurch kann 
  man gleich von vorne heraus Negative Werte ausschließen so, das man sich intern extra Abfragen sparen kann. Bei 
  GetIterator() kann man nun optional einen Start Index setzen. Die Iterator Konstruktoren sind nun protected so das diese 
  NUR von dem jeweiligen Container Typ erzeugt werden können.
- Bitset: Damit wir endlich ein paar cpp-Dateien im Container Ordner haben machte ich das Bitset Template zur normalen 
  Klasse. Ein etwas weniger wichtiger Grund war, das man nicht jedesmal <bool> angeben muss - denn ein anderer Typ ist hier 
  sowieso nicht möglich/gewünscht... ein Bitset mit z.B. floats wäre total daneben. :)



>> 17.01.2006
[SB]
- Alle Klassen auf Namespaces umgestellt. Das RTTI machte dabei etwas Probleme, die Makros müssen hier nochmal überarbeitet werden, es
  ist also möglich daß externe Klassen im Moment nicht mehr richtig funktionieren.
- Alle Container-Klassen nach 'PLGeneral/Container' verschoben
- Quicksort nach 'PLGeneral/Tools' verschoben
- Verzeichnis 'FileSystem/Base' gelöscht und alle Dateien direkt nach 'FileSystem' verschoben
- Patch von Christian für einen Fehler in SearchMultiHandle eingearbeitet



>> 16.01.2006
[SB]
PLString:
- Die Operatoren gefielen mir noch nicht wirklich, da dies eine bunte Mischung aus der Verwendung von String und char* war.
  Habe nun bei den wichtigsten Operatoren jeweils beide Varianten eingebaut, wird dies mit char* aufgerufen ist es also minimal
  schneller, da nicht erst ein String-Objekt erzeugt werden muß
- StringModule wurde in StringBuffer umbenannt
- Der StringBuffer implementiert nun nicht mehr einen eigenen Reference Counter sondern benutzt PLTRefCount
- Hilfsfunktionen zur Verwendung von String-Buffern in der Klasse eingebaut. Dies erleichtert die Arbeit mit den Buffern, da ansonsten
  an vielen Stellen immer wieder das gleiche getan werden mußte (Buffer kopieren wenn der String verändert wurde etc)
- Der String-Buffer übernimmt nun immer einen neuen Zeiger auf einen Buffer, die Möglichkeit einen eigenen Buffer zu allokieren und
  den übergebenen String zu kopieren fällt weg. Dies macht die Verwendung des Buffers wesentlich verständlicher, zumal das Kopieren
  des Strings nur an einer einzigen Stelle nötig war
- Compare-Funktionen überarbeitet
- Konstrukturen mit einem Char-Zeichen als Parameter aus StringBuffer entfernt. Im String selbst bleibt dieser Konstruktor erhalten,
  damit Operationen auf Strings auch mit Buchstaben funktionieren, ansonsten wäre das Umwandeln eines Buchstabens in einen String
  der Länge 1 recht kompliziert
- IsAlpha: Wurde umbenannt in IsAlphabetic. Außerdem prüft diese Funktion nun den gesamten String und nicht mehr nur ein Zeichen,
  für ein einzelnes Zeichen sollte entweder die System-Funktion direkt aufgerufen werden oder SubStrings verwendet werden
- IsAlphaNumeric: Prüft nun ebenfalls den gesamten String, ob dieser nur aus alpha-numerischen Zeichen, sprich alphabetischen ODER
  numerischen Zeichen besteht. Vorher prüfte diese Funktion nur auf numerische Zeichen, der Name war also falsch
- PrintF in Print umbenannt. Naja typische Schönheitsoperation, sollte dies auf heftigen Widerstand stoßen können wir es auch wieder
  umbennen, aber ich finde so ein großes F am Ende irgendwie häßlich ;-)
- Insert (char) entfernt. Wenn dies nicht dringend und an performance wichtigen Stellen gebraucht wird sollte dies lieber über einen String
  der Länge 1 gemacht werden
- EatLeadingWhitespace und EatTrailingWhitespace umbenannt in TrimLeading und TrimTrailing. Außerdem noch Trim hinzugefügt, welches
  beides macht. Außerdem geben diese Funktionen nun ebenfalls den String zurück
- Konvertierungsfunktionen aufgeräumt. Kleine Änderung: Beim =(char) wird nun der Buchstabe ausgegeben, nicht dessen Ascii-Wert.
  Dies war zuvor inkonsistent, bei =(char) wurde die Zahl genommen, bei += jedoch der Buchstabe
- Const bei entsprechenden Methoden hinzugefügt
- String-Klasse liegt nun in Base
PLGeneral:
- PLTRefCount Template hinzugefügt, Basisklasse für Reference Counting
- PLTRefCountPtr Template hinzugefügt, diese Klasse ist ein spezieller Reference Counter für externe Objekte
- SmartPtr-Template hinzugefügt. Diese Klasse arbeitet mit dem PLTRefCount Interface und überprüft dabei,
  ob das verwendete Objekt dieses Interface unterstützt oder nicht. Falls nicht wird mittel PLTRefCountPtr ein
  externer Reference-Counter für das Objekt erzeugt, es ist jedoch besser, wenn die Klasse auf die gezeigt
  wird von PLTRefCount abgeleitet wird, da dies Fehler z.B. durch doppeltes Zuweisen des gleichen Zeigers
  besser verhindern kann
- Alle Klassen auf die neue PLTRefCount-Klasse umgestellt



>> 07.01.2006
[CO]
- RTTIDefs.h: Da 'VAR_OFS' bei Stephan unter Linux Compiler Warnungen verursacht bastelte er ein Makro welches unter Linux 
  keine Warnungen produziert. Da VC aber anscheinend kein '__alignof__' kennt musste ich hier defines einsetzen, unter 
  Windows das eine Makro, unter Linux das andere... vielleicht bekommt man irgendwann später etwas Universelles zusammen das 
  überall sauber geht, aber ich denke wir können das erstmal so lassen.



>> 03.01.2006
[SW]
Alle Projekte:
- Habe das subversion property "svn:eol-style 'native' " für die source-files, text-files und project-files gesetzt.
  dieses property sorgt dafür, das beim checkout,update die eol-kennung entsprechend des OSes ist
  d.h. unter linux ist die eol-kennung nur \n und unter windows \r\n und zwar egal vom welchem os aus diese
  Datei verändert oder erstellt worden ist



>> 02.01.2006
[SW]
- Memleak in der String-klasse unter linux behoben. Das Problem war das die _vscprintf-implementation
  fehlerhaft war(ein return hat gefehlt, *asche über mein haupt*).
  Da die vsnprintf-function unter linux das selbe macht, wurde die protabele_vsnprintf-fn aus GeneralLinux.cpp
  entfernt.



>> 01.01.2006
[SW]
- habe die kompabilität zu gcc 3.4 hergestellt bzw. zum c++-template standard
  zum einen musste ich den header string.h in HashTable.inl hinzufügen, weil sonst der gcc mit folgender fehlermeldung 
  bezüglich strlen, strcpy,strcmp abbrach:
  "there are no arguments to `strcmp' that depend on a template parameter, so a declaration of `strcmp' must be available"
  Die änderung von AType zu AType1 in der friend declaration in den Dateien ResourceManager.h, ResourceHandler.h und 
  Resource.h war nötig weil sonst der gcc mit folgender Fehlermeldung abbrach:
  "include/PLGeneral/Base/ResourceManager.h:32: error: declaration of `class AType'
   include/PLGeneral/Base/ResourceManager.h:25: error:  shadows template parm `class AType'"
  es müsste nur getestet werden ob diese Änderungen keine probleme verursachen
- tinyxml: habe eine statische lib für linux von tinyxml in den zips hinzugefügt und tinyxml.h so abgeändert das sie auch 
  unter linux übersetztbar ist
  
  
>> 01.01.2006
[CO]
- PLTString &PLTString::operator += (char nCharacter): Hier waren die Parameter vertauscht



>> 22.12.2005
[CO]
- Optimierte PLTHashTable da diese Klasse recht häufig verwendet wird und etwas lahm war... die alte Implementation war etwas 
  dürftig. Bei 'Add()' wird nun nicht mehr geprüft ob dieses Objekt bereits eingetragen ist - das muss der User schon selbst 
  machen wenn er hier unsicher ist und das jedesmal inter zu prüfen ist schlichweg zu Aufwändig... Codes angepasst habe ich 
  keine da wir eh vorher immer im  Falle des Falles prüfen. Nahm diverse überflüssige 'Sicherheitsabfragen' raus - denn in 
  den Innereien kann man IMMER davon ausgehen das die gegebenen Dinge stimmen da diese bereits vorher mal geprüft wurden. :)
  Desweiteren wird nun zwischen groß/kleinschreibung unterschieden. Die neue Implementation ist nun teils mehr als doppelt 
  so schnell wie die alte und die Namen können beliebig lang sein.
- PLTResource & PLTResourceHandler: Die alte Resource Handler Implementation war viel zu umständlich - daher machte ich dies 
  'direkter', Resource kann also intern direkt auf Handler zugreifen und umgekehrt... da diese Dinge stark zusammenhängen 
  ist das denk ich ok und es vereinfacht die Sache enorm. Wenn ein Resource Manager automatisch nicht länger verwendete 
  Resourcen löschen soll, löschen nun die Resource Handler die alte Resource wenn diese nicht mehr verwendet wird.



>> 15.12.2005
[CO]
- Da PLTString nun stark an Bedeutung gewinnt, überarbeite ich die String Klasse nochmal komplett - die alte Implementation 
  war leider teils heftig Buggy/Unbefriedigend. Das Überarbeiten war zwar einiges an Arbeit, aber ich denke es hat sich 
  definitiv gelohnt. :)
- Stellte intern die Speicherung von Namen im Resource Manager auf PLTString um - den Rest in PLGeneral wird Stefan 
  anpassen. Das verwenden von PLTString zur Speicherung von Namen bringt einige Vorteile, zum einen haben wir so keinen 
  Overflow mehr wenn man einen längeren Namen hat als Speicher für einen Namen verfügtbar ist... und zum anderen Spart man 
  einiges an Speicher da ein 'leerer' String gerade mal 4 Byte groß ist... und ansonnsten wird nur soviel Speicher für den 
  String verwendet wie wirklich nötig ist. Also nicht mal fest char[256/1024 usw.] anlegen und hoffen das dies reichen 
  wird. ;-)
- In PLTParameters::AddParam() kam es nun nach 'PLTVariant *pVar = new PLTVariant(cParam);' zum Crash da in 
  'PLTVariant::m_sName' merkwürdigerweise Schrott stand. Machte hier eine kleine Änderung, lies aber das vorherige als 
  Kommentar drinen. Stefan, schau bitte mal was hier schiefgeht und ob man es so wie es jetzt ist lassen kann.



>> 12.12.2005
[CO]
- PLTXmlElement::GetFirstAttribute(): An ein paar Stellen wo ich diese Funktion verwendete hatte ich vergessen vorher zu 
  Prüfen ob hier überhaupt etwas zurückgegeben wird bevor ich es verwende - wieder soetwas wo man sich schwer wundert das 
  dies nicht schon vorher aufgefallen ist. ;-)
- Nahm wie besprochen die Prioritäten aus dem Resource Manager da diese dort mehr Ärger als nutzen bringen
- PLTSingleton: 'm_pInstance' bekommt nun im Constructor die Instance zugewiesen und nicht mehr in GetInstance(). Nach den 
  kleinen Änderungen im Resource Manager Template hatte ich hier in den konkreten Resource Managern nun das Problem das 
  in deren Constructoren teils GetInstance() verwendet wird - jedoch lieferte dies zu diesem Zeitpunkt NULL zurück da diese 
  Variable erst noch gesetzt werden musste. (endlos Rekursion :)
  Ich hoffe diese kleine Änderung geht ok...



>> 08.12.2005
[CO]
- PLTResourceManager: Die Funktion Get(<Name>) ist nun virtuell, in der Engine beim Scene System hat diese Funktion eine 
  erweiterte funktionalität da man über z.B. 'Root.Scene.Jeep' auch 'absolute Namen' angeben kann. Machte SetResourceName() 
  Protected da es reichen müsste wenn man über PLTResource::SetName() den Namen einer Resource setzen kann. 
  PLTResource::SetName() ist nun ebenfalls virtuell da z.B. in der Engine bei PLTSceneContainer in Namen kein '.' vorkommen 
  darf und der Name 'Root' nicht verwendet werden darf. (NUR die Root Node selbst hat diesen Namen :)
  Dummerweise musste ich auch Get(<int>) virtuell machen und in PLTSceneContainer implementieren, ansonnsten bekam ich 
  folgende Fehlermeldung:
    "error C2664: 'PLTSceneContainer::Get': Konvertierung des Parameters 1 von 'int' in 'const char *' nicht möglich"
  Was machen wir hier? Irgendwie ist das total dämlich. :(



>> 02.12.2005
[CO]
- PLTHeap: Kann nun auf Wunsch auch den Key zurückgeben



>> 30.11.2005
[CO]
- PLTBase::SetVars(): Konnte kein '=' gelesen werden, wurde das nächste gefundene Wort 'übersprungen' was nicht korrekt war.



>> 20.11.2005
[SB]
- Habe das Interface von PLTContainer verändert: Die Funktion Add(const AType &Element) gibt nun ebenfalls einen AType* Zeiger zurück.
  Man braucht dies nicht, wenn man nur eine Liste von Zeigern hat, besteht die Liste jedoch aus direkten Objekten, welche kopiert werden,
  ist dieser Zeiger sehr nützlich, ansonsten würde es wesentlich umständlicher.
- Habe in PLGeneral und PLMath alle Aufrufe von Add(const AType &Element) angepaßt - da vorher true als Fehler zurückgegeben wurde, nun
  aber NULL für den Fehlerfall steht, muß leider jeder Aufruf angepaßt werden. Habe dies auch in den anderen Projekten getan.



>> 18.11.2005
[SB]
- Include von PLTLog in PLTSingleton entfernt, dadurch mußten an anderen Stellen die Include-Files geändert werden



>> 10.11.2005
[CO]
- PLTResourceManager<AType>::SetResourceName(): Ohman, wie konnte DIESER total dämliche Bug nur soo lange unbemerkt 
  bleiben? (war natürlich mein verschulden :) Hier wurde zuerst der neue Resourcen Name gesetzt, und dann wurde die 
  Resource mit hilfe diesen neuen Namens aus 'm_lstNameHashList' entfernt und dann mit dem neuen Namen wieder 
  hinzugefügt... brrr, natürlich muss die Resource mit dem alten Namen aus 'm_lstNameHashList' entfernt werden.



>> 09.11.2005
[CO]
- PLTTools: Neue Funktion: CombineStrings(): Kombiniert Strings miteinander. Diese Funktion wird u.a. im Renderer in den 
  Shader Backends benötigt um den Shader korrekt zusammenzukopieren... denn hier müssen noch Renderer & Custom Definitionen 
  in den Shader eingefügt werden.
- PLTList: Get() & ReplaceAtIndex() & AddAtIndex() & RemoveAtIndex() & Compare() etwas Optimiert: Ist der Index in der 
  'hinteren' hälfte, so wird nun vom letzten Element rückwärts durchlaufen wodurch man in diesen Fällen eine bessere 
  Suchzeit hat... wenn man schon ne doppelt Verkettete Liste hat, so kann man auch ruhig die Vorteile die diese bietet 
  nutzen. ;-)
  Passte ebenfalls PLTPool & PLTFastPool entsprechend an.



>> 07.11.2005
[SB]
Alle Projekte:
- Habe im Repository die Verzeichnisse _Branches und _Tags entfernt - ich fand die störend, und wir nutzen das bisher eh nur sehr selten.
  Der PLGeneral-Branch sitzt nun direkt im Hauptverzeichnis, was nicht weiter stören sollte, zumal Branches ja sowieso keine allzu lange Zeit
  am Leben sein sollen :-)



>> 02.11.2005
[CO]
- Reset-Funktion zu PLTArray hinzugefügt mit der man den Array 'zurücksetzen' kann - recht praktisch das
- PLTTools: Neue Funktionen: GetIntegersFromString(), GetFloatsFromString() und GetDoublesFromString()



>> 01.11.2005
[CO]
- PLTXmlDocument: LoadFile() und SaveFile() setzen nun den Dokument Wert auf den Dateiname + einen TinyXML Fehlercode
  wenn die Datei nicht geöffnet werden konnte.



>> 29.10.2005
[CO]
- PLTSystem: Vergrößerte die Anzahl der Slots der Hash Tables von m_hashClasses & m_hashModules da ich derzeit 217 Klassen, 
  und 19 Module zähle - so ist die Hash Table wieder Effektiver und da es nur eine Instance von PLTSystem gibt gibts auch 
  Speicher mäßig keine Probleme.
- Es können nun auch Passwort Geschütze Zip-Dateien verwendet werden. Dafür musste ich PLTFile::Open() um einen weiteren 
  Optionalen Parameter erweitern. (das Passwort wenn benötigt)



>> 25.10.2005
[CO]
- PLTTools: Neue Funktion GetBooleanFromString() welche einem den booleanischen Wert in einem String zurückgibt. Dies ist 
  z.B. beim Auslesen von XML Attribute Werten recht praktisch da der User dadurch '0' oder auch 'false' schreiben kann.
  PLTVar::Set() verwendet nun ebenfalls diese Funktion damit das Einheitlich gehandhabt wird.
- PLTXmlElement: Schlägt das zurückgeben eines Attribute Wertes fehl, so ändert TinyXML troztdem die übergebene Variable - 
  das ist total unpraktisch und darum wird hier nun diese Variable nicht mehr geändert falls die Funktion fehlschlägt. 
  Hatte mir schon überlegt diese Änderung direkt in TinyXML zu machen, sah aber davon ab da dies eventuell Probleme 
  verursachen könnte.



>> 24.10.2005
[CO]
- PLTBase: Um Funktion AddVarsToXMLElement() erweitert welche die Variablen zu einem XML Element hinzufügen. Dabei kann man 
  als Parameter übergeben ob die Variablen als Attribute oder Elemente hinzugefügt, und ob Variablen mit Default Werten 
  irgnoriert werden sollen. Da dieses 'Variablen zu XML Element hinzufügen' öfters benötigt wird, ist diese hilfs Funktion 
  ziemlich praktisch. Das 'Gegenstück' zu dieser Funktion SetVarsFromXMLElement() ist ebenfalls vorhanden. Diese zweite 
  Funktion kann auf Wünsch selbständig nach Variablen in den Attributen UND Child-Elementen suchen soll, Default Einstellung 
  ist jedoch Variablen nur in den Attributen suchen.
- PLTConfig läd & speichert nun in einem XML Format, dabei werden die verschiedenen Variablen als Elemente hinzugefügt 
  und auch Variablen mit Default Werten werden ebenfalls gespeichert - das ist hier irgendwie übersichtlicher.
- PLTXmlDocument: LoadFile() verwendet nun eigene File System Funktionen um eine Datei einzuladen und zu Parsen



>> 21.10.2005
[CO]
- PLTConfig: Beim Laden & Speichern kann man nun Optional angeben ob die Config Datei NUR im aktuellen Verzeichniss gesucht
  werden soll. Damit kann man Konflikte zwischen verschiedenen Config Files verhindern - z.B. das plöztlich in PLSamples 
  Configs aus PLTools genommen werden da die gewünschten Configs in PLSamples nicht gefunden wurden und PLTools im FS als 
  Basis Pfad eingetragen ist... und somit wurden teils unerwünschte Einstellungen verwendet. :)



>> 05.10.2005
[CO]
- Musste in TinyXML eine weitere kleine Änderung vornehmen: Hatte Probleme beim Scene Format da '[' und ']' nicht in Namen 
  vorkommen durften - aber somit konnte eine Scene nicht mehr geladen werden sobald eine RTTI Array Variable verwendet 
  wurde. Also erweiterte ich TiXmlBase::ReadName() so, das auch '[' und ']' in Namen akzeptiert werden... hoffentlich macht 
  das keine Probleme... hat jemand ne Ahnung ob das 'Absicht' ist das '[' und ']' bei XML nicht in Namen vorkommen darf, 
  sprich, es so in den 'Vorgaben' steht? Wenn ja, und wir uns daran halten wollen, müssten wir uns für RTTI Array Variablen 
  etwas anderes überlegen was aber ziemlich unschön werden würde.
- An ein paar Stellen wo das RTTI float Variablen in einen String schreiben soll %f durch %g ersetzt damit am Ende keine 
  Überflüssigen Nullen stehen.



>> 29.09.2005
[CO]
- PLTString::Insert() um weiteren optionalen Parameter erweitert. Ist dieser nicht -1 so gibt dieser die Anzahl der 
  einzufügenden Zeichen an. Desweiteren noch ein paar Tool Funktionen hinzugefügt.
- PLTSystem::ScanPlugins() um optionalen Parameter erweitert. Da wir mittlerweile ziemlich viele dll's haben kann 
  ScanPlugins() vorallem beim Programmstart im Debug Modus nervend viel Zeit in anspruch nehmen da zuerst einmal die dll 
  geladen werden muss und wenn nichts Interessantes drinen ist wird diese wieder entladen. Ist dieser neue Parameter auf 
  'true' (Default = 'true'), so wird anhand des Namens ein kleiner 'Vortest' gemacht so das man meist gut die hälfte der 
  dll's erst gar nicht zu laden braucht was den Scan Vorgang beschleunigt. Dabei wird das 'D' am Ende des Namens geprüft. 
  Ist man im Release Modus und ist dort ein 'D' wie z.B. bei PLSampleSceneNodesD.dll so wird dieses Module komplett 
  ignoriert. Da wir selbst uns an diese Namens Konvention halten klappt das hier, der User müsste sich am Ende auch daran 
  halten, oder beim Scannen diesen Parameter auf 'false' setzen damit nicht eigentliche gültige Module ignoriert werden. 
  Ist natürlich eine Sache die schnell daneben gehen kann wenn jemand nicht aufpasst - allerdings spart das Wertvolle 
  Ladezeit was ein deutlicher Pluspunkt ist... und eine andere Lösung um die ScanPlugins() Ladezeit zu verkürzen hab ich 
  bis jetzt noch nicht gefunden. Ich machte das da diese Ladezeit gerade im Debug Modus mittlerweile deutlich auffällig - 
  das iss schon fast so nervend wie bei 3D Studio Max wo am Anfang erstmal tausende von Plugins geladen werden welche man 
  teils gar nicht braucht was Debuggen zur Qualt macht. Das Scannen selbst kann man wohl nicht umgehen, aber halt wie 
  gesagt grob anhand des Names 'ausfiltern'. In meinem Debug Modus Test wurden früher beim Programmstart gut 252 mal dll's 
  geladen und entladen. Jetzt nur noch 39 mal - früher war das so hoch da wenn eine dll geladen wird ja auch gleich noch 
  alle damit Verbundenen dll's geladen werden, und beim endladen werden diese anderen dll's meist auch wieder entladen und 
  das gleiche Spielchen immer und immer wieder. Hoffentlich kommt Stefan mit dieser Lösung klar... oder findet etwas 
  besseres. ;-)
  Alternativ könnten wir vielleicht auch alle Plugin in extra Unterordner wie z.B. 'Plugins' und 'PluginsD' packen und dann 
  gezielt beim Initialisieren der Engine in diesen Ordnern Scannen lassen. Aber dann müsste z.B. 'Newton.dll' auch im 
  entsprechendem Ordner liegen wenn man was 'rausgibt'... und im Grundordner müsste dieses nochmal liegen falls die 
  Anwendung selbst Newton verwendet. (denn in diesem 'rausgeben' Fall wäre es nicht gut an den Environment Variablen zu 
  drehen)



>> 25.09.2005
[CO]
Alle Projekte:
  Ging alle PL Projekte durch und machte einige RTTI Variablen 'read only':
  PLTImageLoader, PLTTextureCreator, PLTMeshCreator, PLTSkeletonAniLoader, PLTMeshLoader
PLGeneral:
- PLTFileSystem: Neue Funktion: IsSearchPath() -> Prüft ob ein gegebener Pfad ein Suchpfad eines gegebenen Types ist. Dies 
  brauchte ich in PLTMeshLoader wo ich prüfe ob ein Pfad bereits eingetragen ist. Wenn nicht, werden bei bedarf 
  während des Laden eines Meshs ein paar Suchpfade hinzugefügt und nach dem Laden wieder entfernt. (siehe PLEngine Diary)
- PLTFileType::RemoveSearchPath() korrigiert nun den übergebenen Pfad wenn nötig (sicher ist sicher)



>> 22.09.2005
[CO]
- Neue Funktion: PLTPlatform::ShellOpen(): Das OS öffnet eine Datei mit dem Programm welches mit diesem Datei Typ vernüpft 
  ist. Weis nicht ob diese Funktion wirklich in Platform passt oder nicht doch eher ins File System. Auf jedenfall ist diese 
  Funktion recht nützlich wenn man z.B. auf einen Link Klickt und sofort auf eine Internet Seite kommt - oder wenn man z.B. 
  im Mesh Editor ein Material öffnen will. (in dem Fall wird nen Text Editor mit diesem Material geöffnet)



>> 10.09.2005
[CO]
- Der einzige Unterschied zwischen PLTPool und PLTResourceManager bestand darin das PLTPool Element zusätzlich noch 
  eine Priorität haben - wichtige Element liegen dann also immer am Anfang. Da Prioritäten bei Resourcen sicherlich auch 
  nicht verkehrt sind erweiterte ich den Resource Manager um solche. Somit hat PLTPool nun keine Existensberechtigung mehr 
  und wurde gekillt. Nötige (meist kleinere) Anpassungen:
  - PLGeneral: PLTProfiling
  - PLModel: PLTAnchorPoint, PLTAnimationEvent, PLTAnimationInfo, PLTMesh, PLTMeshHandler, PLTMorphTargetAni
  - PLEngine: PLTSurfaceListener, PLTSky
  - MeshEditor: TGuiEditAnimationEdit
- Das mit PLTPool hatte ich mir nochmal angeschaut da ich den Namen PLTPool für etwas anderes brauchte - es gibt nun eine 
  Neue Container-Klasse mit diesem Namen. Im Prinzip handelt es sich hierbei um eine Verkettete Liste wie bei PLTList, 
  jedoch gibts Intern zwei Listen, eine mit den aktuell verwendeten Elementen und eine Liste mit derzeit nicht benötigten 
  Elementen. Diese Klasse ist recht praktisch wenn man viele Dynamischen Elemente Managen will, also wenn häufig Element 
  gelöscht und wieder hinzugefügt werden. Beim Löschen wird das eigentliche Element 'nur' zur Liste der freien Elemente 
  hinzugefügt, und fügt man wieder ein Element hinzu wird erst geschaut obs noch ein nicht verwendetes Element gibt - 
  ansonnsten muss wie bei der normalen Liste ein neues erzeugt werden.
- Neben PLTPool gibts noch eine schnellere Variante Namens 'PLTFastPool'. Bei diesem Container MÜSSEN die Elemente von 
  PLTFastPoolElement abgeleitet sein - damit kann man dann superschnell ein Element direkt vom Container entfernen ohne 
  voher wie bei PLTPool das reale Pool Element zu finden. Diese Klasse ist also Optimal wenn man sehr viele Elemente 
  regelmäßig löscht und hinzufügt. Ansonnsten verhält sich diese wie alle anderen Container Klassen auch. In der Engine 
  werde ich wohl PLTParticleGroup auf diese Klasse umgestellen und die neue Scene Hierarchy 'PLTSceneHierarchySphereTree' 
  verwendet diese Klasse ebenfalls da hier oft etwas gelöscht und wieder eingefügt wird und dies daher so flott wie möglich 
  gehen muss.
- In PLTList::RemoveAtIndex() war noch nen Bug, der Index wurde nicht erhöht - das dies nicht schon vorher aufgefallen ist...
- PLTStack: PushBack() Privat gemacht da dies nicht in das 'übliche' Stack Schema passt
- Neue Klasse: PLTQueue (FIFO) ist das Gegenstück zu PLTStack (FILO)



>> 30.08.2005
[CO]
- PLTBitset::Resize(): Parameter waren vertauscht



>> 26.08.2005
[CO]
- Bei einigen XML Funktionen Funktionen ein Get davor gesetzt + ein paar interne Sicherheits Abfragen auf NULL Zeiger
- XML Interface Kommentare soweit vervollständigt, sind aber noch hier und da nicht wirklich Aussagekräftig da die TinyXML 
  Doku hier leider teils lückenhaft ist. Einiges undokumentiertes Verhalten hab ich bereits direkt in den Codes nachgeschaut 
  und bei uns Dokumentiert. Drehte auch ein paar boolische Rückgabe Werte um so das diese zu unserem Style passen. 
  (bei Fehler 'true' statt 'false' - da wir fragen 'gabs nen Fehler?' und nicht 'ging alles glatt';-)
- PLTXmlDocument: Eigene Speicher Funktion eingebaut



>> 17.08.2005
[CO]
- XML Wrapper Versucht Nr. 2: Wie beim Treffen bei Jens Besprochen hat nun jede XML Klasse eine eigene Datei und alles 
  liegt in dem  Ordner. Zudem werden von diesen Klassen nun 'echte' Objekte erzeugt. Konkrete PL XML Objekte werden
  erst DANN erzeugt wenn diese benötigt werden - z.B. wenn man sich ein Element zurückgeben lassen will wird intern falls
  zu dem TinyXML Element noch kein PL XML Element vorhanden ist eines erzeugt.
  Mit dieser Lösung kann es sein das bestimmte Elemente/Attribute NIEMALS 'angefasst' werden und man hier daher auch keine
  eigenen PL XML Objekte erzeugen muss. (wird wohl vorallem bei Attributen der Fall sein :)
  Bei der Implementation gabs nen paar Kleinigkeiten zu beachten:
  Da die User Data Variable von TinyXML verwendet wird, muss man beim Kopieren und beim Einfügen der Objekte aufpassen da 
  sonst die PL XML Objekte Zeiger nicht mehr stimmen. Änderte in TinyXML TiXmlNode::CopyTo() es so das User Data NICHT
  mehr mitkopiert wird - denn das im Wrapper zu kompensieren war zuviel Aufwand. (rekursiv)
  Das Löschen der PL XML Objekte war etwas mehr Aufwand da man rausbekommen musste wann ein TinyXML Objekt zerstört wurde - 
  da TinyXML aber soetwas nicht anbietet erweiterte ich TinyXML um eine Destroy-Callback Funktion welche jedesmal aufgerufen 
  wird wenn ein Objekte zerstört wird. Durch diese Mini Erweiterung spart man sich dann in unseren Wrapper eine ganze Menge 
  an Arbeit. :)
  Alles in allem find ich diesen Wrapper recht brauchbar und der Aufwand/Nutzen Faktor stimmt. Mit einer komplett eigenen
  internen Hierarchy wäre alles mehr Arbeit als dies momentan der Fall ist. Zwar musste ich nun zwei mini Änderungen an 
  TinyXML selbst machen - aber ohne diese Änderungen hätte man sich teils heftig im Wrapper verbiegen müssen um es sauber
  laufen zu lassen, ich finde das ist nen akzeptabler kompromiss zwischen 'TinyXML umschreiben und direkt in PLGeneral',
  'gesammte XML Hierachy selbst Managen' oder gar gleich 'komplett eigenen XML Parser schreiben'.



>> 16.08.2005
[CO]
- PLTTokenizer::GetNextToken(): Quote verhalten minimal geändert. Bis jetzt wurden = und ` gleich gehandelt. Man konnte also
  mit " starten und mit ` Enden. Nun wird es so gehandhabt das wenn mit " begonnen muss es mit " auch wieder enden muss. Hat
  den Vorteil das man nun Quotes 'Schachteln" kann was enorm Praktisch ist. z.B. kann man nun Problemlos eine Scene Node 
  erzeugen dessen Mesh automatisch erzeugt wird mit z.B. 
  pContainer->Create("PLTObject", "Sphere", "Pos=\"0.0 0.0 5.0\" MeshFilename=\"PLTMeshCreatorSphere 
  Name=`Sphere` Radius=`4.0` Detail=`20.0`\"");
- PLTArray: Ist nun wieder ein 'richtiger' Array, bei meinen Tests hatte ich keine Probleme und alles läuft mit dieser 
  Änderung genau wie früher. Änderungen in den anderen Codes sind nicht nötig. Mit GetData() bekommt man den Zeiger auf 
  das erste Element des Arrays.
- Vertauschte bei PLTBitset & PLTArray Init & Add Parameter - denn Init sollte im Normalfall false sein und nicht geändert
  werden. (außer man weis genau was man tut :)
  Init ist praktisch wenn man GENAU weis das man einen Primitiven Variable Typ wie float hat oder einfache Klassen - aber 
  sobald z.B. virtuelle Funktionen ins Spiel kommen sollte man nie nie nie den Init Parameter auf True setzen da memset
  zum Initialisieren der Elemente verwendet wird!
  Keine Anpassungen in PLBase nötig, ansonnsten nur eine Handvoll Parameter Anpassungen in allen Projekten zusammen.
- PLTBitset: SetResizeCount() hat nun den Default Wert 320 - denn da jedes Element hier nur 1 Bit ist und je 32 Bits in
  eine Integer Variable 'passen' ist es so wesentlich Effizienter.
- PLTBitset & PLTArray: RemoveAtIndex() verkleinert nun bei Bedarf den Array wieder. NUR diese Funktion löscht die
  Elemente, alle anderen verwenden diese nur.
- PLTVar::SetEnumString(): Da m_lstEnum Array ist und jedesmal wenn ein neues Element hinzugefügt wird sich die Adresse 
  im Speicher von anderen Elementen ändern kann, darf man m_hashEnum erst nachdem alle Elemente eingetragen wurden
  erzeugen.



>> 10.08.2005
[CO]
- Wrapper für TinyXml geschrieben und im Tools Unterordner abgeladen. (+ Base Test um XML Test erweitert)
  Der Wrapper ist noch nicht 'perfekt' und es fehlen noch nen paar PL spezifische Funktionen für z.B. das eigene
  File System verwenden.



>> 06.08.2005
[SB]
- PLTWin32File::GetS() filtert nun nicht mehr das '\n' heraus sondern verhält sich jetzt genauso
  wie fgets(). Vermutlich werden wir jetzt aufgrund des neuen Verhaltens einige andere Stellen
  anpassen müssen, aber es ist ja immer besser sich an Standards zu halten :-)
- PLTWin32File::PutS() gibt jetzt die länge des Strings zurück, wenn es beim Schreiben keine
  Fehler gab, damit liefert PLTFile::Print() auch keine lästigen Fehler mehr. Bin mit nicht 100%
  sicher, ob das auch beim Textmode immer funktioniert, sollte aber eigentlich :-)
- Habe einen neuen Branch für PLGeneral erstellt, an dem ich in nächster Zeit arbeiten werde.
  Da ich noch einiges an PLGeneral ändern möchte und es unpraktisch wäre, dies im "laufenden Betrieb"
  zu tun, da dann ständig alles angepaßt werden müßte, ist dies eine gute Gelegenheit, mal Branches
  in Subversion auszuprobieren. Dies ist also eine Kopie des aktuellen PLGeneral, an der ich
  beliebig arbeiten kann, wenn die Arbeiten abgeschlossen sind werden die Änderungen wieder mit
  dem Hauptzweig gemerged - bei Bedarf kann man das auch zwischendurch schon machen, wenn ich z.B.
  nur einen kleinen Bugfix mache, der auch in der aktuellen Version ok ist, oder andersherum
  wenn jemand am Hauptzweig was ändert was ich gleich übernehmen kann. Also mal schauen wie gut
  das funktioniert :-)



>> 28.07.2005
[CO]
- Erweiterte das Resource Manager Template um die Virtuelle Funktion PLTResource::DestroyResource(), diese Funktion
  wird/sollte nun immer anstatt delete <Resource> verwendet werden. Als Standard ist ein einfaches 'delete' 
  Implementiert - in PLTSceneNode ist es aber nötig VOR dem Löschen die Scene Node sauber aus dem Container zu 
  entfernen. Vorher wurde in PLTSceneNode erst direkt im Destruktor der Knoten aus dem Container entfernt - dies 
  machte aber casting-Probleme da anscheinend bereits Teile des Objektes gelöscht waren was dazu führte das
  DeInitFunction() nicht mehr korrekt aufgerufen wurde.



>> 11.07.2005
[CO]
- PLTPlaneSet::IsBoxIn() kann nun Optional noch mit ausgeben welche Ebenen die Box schnitten.



>> 11.06.2005
[CO]
- Da ich merkte das man das Informer&Listener Prinzip immer wieder benötigt und es mir einfach zu dumm wurde
  das immer wieder von neuem zu Implementieren erstellte ich Informer&Listener Templates an und legte diese im 
  Base-Unterordner ab. (PLTSceneQuery und PLTSceneQueryListener in der Engine verwenden diese Templates bereits)
- PLTString etwas erweitert



>> 17.05.2005
[CO]
PLTPlatform:
- Fügte Funktionen für Multi-Tasking hinzu da die Rechner (und vorallem neue Konsolen :) immer mehr CPU's
  haben, muss man zwangsläufig versuchen wo immer möglich bestimmte Aufgaben als eigene Tasks zu realisieren um 
  diese Systeme Effektiver nutzen zu können. PLPhysics z.B. werd ich dann gleich in einem eigenen Task laufen
  lassen da dies dort 'relativ' Problemlos möglich ist - und der Trend bei Physik geht eindeutig zum eigenen
  Task dafür. (Thema Physics CPU etc. :)
  Auch müsste man nun so Ladebildschirme realisieren können welche lustige flüssige Animationen zeigen während Parallel 
  dazu in einem Task die Daten geladen werden.
  Damit müssten wir auch das CPU/GPU Problem besser in den Griff bekommen... denn wenn die CPU im Hauptprogramm an einer 
  Stelle einmal dummerweise auf die GPU warten muss, wird die CPU im Hintergrund für z.B. die Physics weiter verwendet so 
  das keine/kaum Resourcen brach liegen.
  Hab mich beim Design an der SDL Implementierungen Orientiert da dies im Endeffekt recht Einfach zu verwenden 
  und Sinnig ist. (und es lässt sich sicherlich kaum anderst machen da man ja nur die Grundfunktionen Wrapt :)
  Der User selbst kommt nur mit einer Handvoll Funktionen für Task & Mutex in Kontakt. Intern und vorallem
  bei den Linux Implementierungen ist das alles teils ziemlich umständlich - da man dort anscheinend XXX
  verschiedene Fälle beachten muss. Hab dort die Funktionen aus SDL übernommen, Stephan muss da aber nochmal drüber schaun
  ob das so ok ist und natürlich das mal ausprobieren - das wir endlich auch mal Multi-Tasking verwenden/unterstüzen sollen
  war ja schließlich seine Idee. ;-)
  Ich bin mir seeehr sicher das es sich so wie es momentan ist noch nicht einmal Übersetzten lässt. ;-)
  Erweiterte PLBaseTests gleich um einen einfachen Multi-Tasking Test.



>> 12.05.2005
[CO]
- PLTBase::SetVars(): Der Tokenzier behandelt hier '[' und ']' nun nicht mehr als einzelne Zeichnen da ansonnsten Variable
  Namen wie 'Test[3]' nur als 'Test' gelesen werden - sehr merkwürdig das dies bis jetzt noch nicht Aufgefallen war. ;-)
- PLTConfig::GetVarInt() berücksichtigt nun die Fälle wenn die Variable vom Typ Flag oder Enum ist
- PLTResourceManager<AType>: Add() & Remove() waren noch nicht ganz ok. Der Resource wird nun mitgeteilt das dies nun in 
  dem Manager ist und bei Remove() das diese nun in keinem Manager mehr ist. Den Bug merkte ich erst als ich eine Resource
  nachträglich einem Manager zuwies in es einen Crash gab als der Manager wieder gelöscht wurde... ohmanohman, wie konnte 
  ich das nur übersehen. ;-)



>> 09.05.2005
[CO]
- In VC 7.1 spuckte der Compiler bei PLGeneral leider diverse Fehler aus. Diese liesen sich aber zum Glück recht leicht
  beheben:
- PLTSingleton
  template <class AType> PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
  Hier muss typename Eingefügt werden:
  template <class AType> typename PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
- PLRTTIDefs.h
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
  Hier muss ebenfalls typename Eingefügt werden:
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
- PLTParameters::AddParam(const char *pszName, const PLTVariant &cParam) -> cParam ist nun const -> Machte sonst Probleme
  unter VC 7.1. und noch krassere Probleme auf dem Linux Compiler :)
- Musste in PLGeneralWin32.h auf einmal das Makro 'min' selbst definieren da es ansonnsten nicht gefunden werden konnte
Beseitigte probleme welche bei Stephans Linux Compiler auftraten:
- PLTSystem: Friend Definitionen:
 'friend class PLTModuleID<int>;
' zu 'template<class T> friend class PLTModuleID;
' gemacht
- PLRTTIDefs.h: Ca Zeile 150: 'template PLTModuleID<int>;' wurde entfernt da es Compiler Probleme verursachte.
  (die Zeile wird anscheinend auch nicht benötigt :)
  Desweiteren musste hier 'PLSystem.h' eingebunden werden und in PLBase.h wurde 'PLSystem.h' entfernt.
  (sollte keinen Unterschied machen - tut es aber ;-)



>> 07.05.2005
[CO]
- PLTBase::SetVars() minimal geändert so das auch 'PLTTextureCreatorASCII3D Name=ASCII3D' verstanden wird. In dem Fall wird
  wie üblich eine Fehlermeldung ausgegeben das bei 'PLTTextureCreatorASCII3D' ein '=' + Wert fehlt, der Rest wird nun aber 
  trotzdem weiterverarbeitet.
- PLTFileSystem::OpenInPaths() -> Hier wird nun zuerst in den Suchpfaden für den Typen (falls angegeben) gesucht, erst 
  wenn das nicht klappt wird versucht direkt zu öffnen. (ansonnsten hatte pszType keine Auswirkung)



>> 27.04.2005
[CO]
PLTConfig:
- Implementiere die Funktionen Load() und Save(). Load() ist kein größeres Problem, Save() hingegen bietet die Möglichkeit
  entweder ALLE aktuellen Konfigurationen zu speichern oder nur diejenigen welche in einer bestimmten Konfigurations-Gruppe 
  sind. PLTConfig::GetInstance()->Save("All.cfg"); speichert allso ALLES in eine Datei namens 'All.cfg', während
  PLTConfig::GetInstance()->Save("Engine.cfg", "PLTEngineConfigGroup"); NUR diejenigen Konfigurations Klassen in eine Datei
  speichert welche von PLTEngineConfigGroup abgeleitet wurden. PLTEngineConfigGroup hingegen wurde von PLTConfigGroup 
  abgeleitet. Auf die Art ist das Config-System nun sehr flexibel und man kann beliebig neue Gruppen von Gruppen von Gruppen
  etc. Erzeugen. Die Engine selbst läd/speichert also NUR 'PLTEngineConfigGroup'. :)
  Passte gleich PLRenderer (jedes Backend läd/speichert sich selbst), PLEngine und PixelLab + Plugins an. (nur minimalste 
  Erweiterungen :) Bei der Gelegenheit vergab ich dort auch gleich entsprechende Variable Namen.
- PLTFileSystem::AddBaseDir() -> Baute Abfrage ein ob dieser Basis-Pfad bereits Regestriert ist.



>> 23.04.2005
[CO]
Alle Projekte:
- Stellte bei ALLEN Projekten die Release Einstellungen etwas Resourcen schonender ein. Im Netz gibts nen kleinen 
  Artikel Namens 'Compiler Optimization Of MechAssault 2' wo diese Einstell 'Tips/Tricks' beschrieben wurden.
  - Exception handling /EHsc) wird Deaktiviert - wir verwenden dad sowieso nicht
  - Whole program optimization (WPO) Aktiviert



>> 10.04.2005
[CO]
- PLSingleton.inl: Hm, irgendwie will das mit PLTLog dort nicht funktionieren. Sobald das Log hier verwendet wird beendet 
  sich jedes Programm welches PLGeneralD.dll mal kurz prüft sofort ohne weitere Warnungen!??



>> 09.04.2005
[CO]
- Stellte PLGeneral auf neuen Kommentar Style um. PLSingleton.inl: Dort wo '[TODO] Add to log' stand stellte ich auf PLTLog
  um. PLTZipDate -> Packte die Inline Funktionen in PLZipDate.inl.



>> 20.03.2005
[SB]
- PLTZipStream::Read():
  Auch hier muß nun nSize und nCount angegeben werden, um Daten aus dem Stream auszulesen.
  Zwar wird intern wieder multipliziert und Byteweise gelesen, jedoch ist dies zur Kompatibilität
  mit anderen Funktionen nötig: Will eine Funktion einen Block von 18 Byte lesen, so ist der
  korrekte Rückgabewert nach dem Lesen '1', und nicht '18', die Anzahl der gelesenen Bytes muß
  also noch einmal durch die Blockgröße geteilt werden. Genau dies führte zum Fehler beim
  Lesen von "standardflare.tga", da der falsche Rückgabewert '18' gefunden wurde, brach DevIL
  das Lesen der Datei ab


  
>> 20.03.2005
[CO]
- PLTZipFile::Seek() -> Wird der Offset auf 0 gesetzt, so wird nur zurückgesetzt, aber nicht 0 Bytes gelesen.
  (könnte probleme machen)



>> 02.02.2005
[CO]
- PLTVar::Set() -> Fügte optionalen Parameter hinzu mit dem man den Aufruf von VarChanged() unterdrücken kann. Z.B. ist
  der Aufruf von VarChanged() in PLTBase::IsVarDefault() total ungünstig da im schlimmsten Fall hierdurch etwas kaputt gehen
  kann - das hatte ich beim Klonen im WE. Danach waren die Orginal Entities plötzlich in keiner Gruppe mehr da der Gruppen
  String leer war. Diese Gruppen wurden Dynamisch hinzugefügt - dumme Sache das, derzeit hab ich noch keine Ahnung was man
  da machen kann außer auch die Dynamischen Gruppen einfach zu diesem String hinzuzufügen.
  Zudem ist das hier in PLTBase::IsVarDefault() nen totaler Overhead. Mir gefällt das zwar irgendwie nicht mit diesem Extra
  Parameter da priniziell IMMER Informiert werden sollte, aber bis uns für PLTBase::IsVarDefault() was besseres einfällt ist
  das denk ich ok. Hauptsache es geht hier (vorallem im WE :) erstmal ohne oben Beschriebene Probleme beim einfachen
  Vergleichen zu erzeugen. Hatte mit VarChanged() auch bei PLTEntity Probleme wenn nen Entity noch nicht Initialiert war,
  aber bereits seine Variablen z.B. beim Initialisieren gesetzt wurden. Das umging ich dort über IsInitialized() Tests. 



>> 25.02.2005
[CO]
- PLTBase::GetVars() -> Intern auf PLTString umgestellt da ansonnsten der String aus PLTString wieder zerstört wurde und am 
  ende Schrott in pszBuffer Kopiert wurde.



>> 23.02.2005
[CO]
- PLTString um ein paar Sicherheits abfragen erweitert



>> 22.02.2005
[SB]
- Neue Klassen:
  - PLTVariant: Dies ist ein Variabler Datentyp, welcher verwendet werden kann wenn der Datentyp einer
    Variablen nicht feststeht. Dies wird bei dynamischen Parametern verwendet, auch könnte die Scriptsprache
    später gebraucht davon machen. Ansonsten sollte es aber eigentlich kaum Verwendung dafür geben :-)
  - PLTParameters: Dynamische Parameterliste, die bei Methodenaufrufen übergeben werden kann. Im Moment ist
    dies nur für den Konstruktor da, wenn das RTTI eine Klasse mit Parametern kreieren will. Sollte das
    RTTI später noch um dynamische Methodenaufrufe erweitert werden, wird diese Klasse auch dort Verwendung
    finden
- RTTI-Makros angepaßt:
  - DEFINE_CLASS erstellt keine öffentlichen Konstruktoren mehr, arbeitet also so wie vorher DEFINE_CLASS_PRIVATE
  - Zum Erstellen über CreateInstance() muß nun zusätzlich das Makros DEFINE_CONSTRUCTION_PUBLIC hinzugefügt werden
  - Zusätzlich kann ein Konstruktor definiert werden, dem Parameter übergeben werden können, dies geschieht mit
    DEFINE_CONSTRUCTION_PARAMS, der Konstruktor muß die form Class(PLTParams&) haben
  - Vor den Variablen muß die Liste mit DEFINE_VAR_LIST begonnen werden
  - Durch diese Änderungen war es nun möglich, das Registrieren der Variablen wieder einfacher zu gestalten,
    es müssen also keine Variablen mehr rückwärts und von vorne eingetragen werden. REDEFINE_VAR wurde
    ebenfalls entfernt, statt dessen werden bei DEFINE_VAR schon vorhandene Variablen mit dem gleichen
    Namen einfach überschrieben
  - Neue PL_VAR-Variablentypen hinzugefügt
  - Bei DEFINE_VAR muß nun immer auch der Enum-String als letzter Parameter angegeben werden, dafür wurde
    DEFINE_ENUM entfernt
  - Bei DEFINE_VAR kann hinter der Variablen nun noch ein Variablen-Name angegeben werden. Ist dieser "",
    wird wie bisher der richtige Name der Variablen verwendet
- PLTBase: IsVarDefault() hinzugefügt
- Klassen an neue RTTI-Definitionen angepaßt



>> 11.02.2005
[CO]
- RTTI: REDEFINE_VAR() funktioniert durch die letzte Änderung nicht mehr da die Basis-Variablen nun erst bei Init()
        eingetragen werden. Zuerst wollte ich ne PLTClass Interne Liste anlegen wo die dann bei Init() zu 'überschreibenden'
        Variablen eingetragen werden... Aber ich merkte schnell das dies etwas viel Aufwand ist - und wenn wir das so machen
        wollen wäre es das beste wenn Stefan, der sich ja deutlich besser mit dem RTTI auskennt das übernimmt. Ich entschloss
        mich stattdessen erstmal in den MeshLoadern DEFINE_VAR() zu verwenden. Und will die Basis-Klasse dann ihre gleiche
        Variable eintragen geht das schief da diese Variable bereits vorhanden ist. War die einfachste Lösung - nur Typ
        Sicherheit hat man damit nun natürlich nicht... da könnte man ne Warnung ins Log schreiben wenn wir das so lassen
        wollen...
        Macht REDEFINE_VAR() überhaupt noch Sinn? Denn dann müsste man auch DEFINE_ENUM() etc. Varianten anbieten.
- PLTLog::Open() -> Erzeugt nun ein neues Log wenn kein solches vorhanden ist.



>> 10.02.2005
[CO]
- PLTArray::AddAtIndex() und PLTList::AddAtIndex() waren noch nicht ganz ok. Wenn man ganz am ende ein neues Element einfügen
  wollte ging das noch nicht wie erwartet. Dadurch funktionierte bei mir dann das Regestrieren der Klassen-Variablen nicht
  richtig.



>> 09.02.2005
[SB]
- PLTConfig: Die Methoden GetVarb() etc. umbenannt in GetVarBool(), GetVarInt(), etc. Wie haben bisher immer aussagekräftige Namen
  verwendet, daher sollten wir dies auch hier tun. Es wäre zu überlegen, ob Methoden dieser Art nicht gleich in PLTBase
  eingebaut werden sollten, um es dem Programmierer zu erleichten, auf Variablen zuzugreifen (ist natürlich dann
  schlecht, wenn der Programmierer den falschen Typ verwendet).
- PLTConfig: Habe AddClass() wieder entfernt und durch eine simple "Create-On-Demand" Lösung ersetzt, da mir kein Grund einfiel,
  der dagegen sprach :-) Wenn jemand versucht, auf eine Konfiguration eines bestimmten Typs zuzugreifen, wird erst
  einmal geschaut, ob es diese schon gibt. Wenn nicht, wird das Objekt in dem Moment erzeugt und zurückgegeben.
  Sollte während das Programm läuft niemand versuchen, auf eine Config-Klasse zuzugreifen, wird diese auch niemals
  erzeugt, was ich auch für genau richtig halte, warum sollte man erst einmal alle möglichen Objekte erzeugen,
  wenn diese dann gar nicht gebraucht werden? Wir müssen da nur evtl. beim Speichern darauf achten, aber es stellt
  sich mir sowieso die Frage, ob das Speichern der gesamten Konfiguration sinnvoll ist, da ja z.B. Game-Config und
  Engine-Config nicht zusammen in eine Datei kommen sollten.
- PLTSystem: Eintragen der Config-Klassen wieder ausgebaut (s.o.). Lösungen dieser Art sollten grundsätzlich vermieden werden,
  da sie die Hierarchie eines Systems durcheinander bringen. PLTSystem steht ganz oben in der Hierarchie, d.h. alle
  anderen Teile der Engine verwenden PLTSystem, aber PLTSystem weiß nichts von diesen anderen Teilen. Wenn wir nun
  anfangen, das zu ändern (PLTSystem weiß plötzlich von PLTConfig und trägt dort Klassen ein), wird das ganz schnell
  unüberschaubar, da in beide Richtungen aufeinander zugegriffen wird - wozu das führen kann, sah man sehr deutlich
  beim alten FS, wo GetValidFileName() zu abwechselnden Aufrufen im Manager und im FS führte, dadurch konnte überhaupt
  nicht nachvollzogen werden, was wo getan wird und welches System wofür verantwortlich ist. Das gleich könnte leicht
  bei PLTConfig und PLTSystem passieren, wenn nun PLTConfig im Gegenzug anfängt, neue Klassen einzutragen, und schon
  pendeln die Aufrufe wieder hin und her. Darum also: Aufrufe immer nur in eine Richtung, so daß die Hierarchie erhalten
  bleibt, niemals wieder zurück vom oberen Teil der Hierarchie in untergeordnete Teile.
- PLTSystem: Beim Eintragen der Klassen wird nun geschaut, ob die Basisklasse bereits registriert wurde, ist dies nicht der Fall
  wird so lange gewartet, bis die Basisklasse da ist und erst dann die Registrierung der Variablen aus dieser
  Basisklasse vorgenommen. Damit die Variablen in der richtigen Reihenfolge bleiben, mußte ich bei den Schleifen und beim
  Eintragen der Variablen etwas tricksen, schönere Lösungen wären hier sehr willkommen. Bitte mal schauen ob die Probleme
  damit gelöst sind, in meinen Tests hat's jedenfalls funktioniert :-)
- PLTSystem: Mir ist aufgefallen, daß immer wieder PLGENERAL_API zu allen Funktionen hinzugefügt wird. Dies ist ok, wenn es wirklich
  benötigt wird, also die Funktion soll von außen verwendet werden und es gibt unaufgelöste externe Symbole aufgrund des
  fehlenden Exports. Ist dies aber nicht der Fall, bitte nicht einfach so hinzufügen, denn die Entscheidung, welche
  Methoden exportiert werden sollen und welche nicht, ist an den meisten Stellen schon mit Bedacht gewählt worden!
  Dies ist z.B. eine gute Möglichkeit, um noch etwas mehr Sicherheit zu gewährleisten, indem Methoden, die nur intern
  verwendet werden sollen, auch nur intern aufgerufen werden können (im System ist dies z.B. bei kritischen Methoden
  wie dem Hinzufügen von Modulen der Fall). Dies kann dann auch nicht durchs Verändern eines Headers (protected in
  public ändern) umgangen werden, und ist daher für solche kritischen Methoden nützlich.
  Also bitte immer überlegen, ob das Exportieren einer Methode wirklich gewünscht ist, und nicht einfach alle Methoden
  exportieren.



>> 08.02.2005
[CO]
- PLTResourceHandler: Machte SetResource() virtuell da es man z.B. in PLTSkeletonHandler sobald eine Resource gesetzt wurde
  diverse Aufgaben erledigen muss.




>> 05.02.2005
[CO]
- PLTConfig: Neue Funktion: AddClass() -> Da jederzeit neue Module mit eventuell neuen Konfigurations-Klassen darin
  eingeladen werden können war es nötig eine Funktion anzubieten um neue Config-Klassen zu regestrieren.
  In PLTSystem::RegisterClass() wird nun versucht die neue Klasse in PLTConfig einzutragen - mir viel da 
  keine bessere Möglichkeit ein... vielleicht wäre da ne art von System-Listener angebracht, falls man noch
  an anderen Stellen mitbekommen möchte wenn z.B. neue Klassen regestriert/entladen werden.
- PLTFile: Die Read&Write Funktion wurde so erweitert das man auch Count angeben kann -
  das war leider nötig da DevIL nicht korrekt laden konnte wenn man nSize*nCount direkt berechnete und als zu
  lesende Bytes übergab - da gibts anscheinend intern irgendwo doch nen Unterschied. 
  Auch bei ZLib ists nen Unterschied wenn man die Parameter size und count bei fread vertauscht.
  Stefan, wenn du weißt wieso dad so iss kläre mich bitte auf - ich kanns mir momentan noch nicht Erklären. ;-)



>> 04.02.2005
[CO]
- PLTResourceManager: In Create() wird nun die interne Funktion CreateResource() verwendet welche man in einem konkreten
  Manager überschreiben MUSS. Da das mit der automatischen Erzeugung im Template nicht klappt falls
  der Resource-Typ abstrakt ist, wie dies beim Sound-Manager der Fall ist, musste das geändert werden.



>> 02.02.2005
[CO]
- Ein paar kleinigkeiten an den Resource-Templates geändert



>> 01.02.2005
[CO]
- Neue Funktion: PLTFSTools::GetRelativePath() -> Macht aus einem Absoluten Pfad wenn möglich einen Relativen 
- PLTWin32FSTools::ConvertToWindowsPath() & PLTFSTools::ValidatePath() -> Kleine Laufwerksbuchstaben werden zu
  Großbuchstaben gemacht da es sonst Probleme geben kann. (ich hatte da eines in AddBaseDir() :)



>> 01.02.2005
[SB]
- PLFSTools, PLPlatform: Nannte FileNameEnding in FileExtension um.
  Dieser Begriff sollte wohl allgemein bekannt sein, und wir sollten es dem User nicht unnötig schwer machen :-)
- PLSearchHandle: Nahm die Änderung, daß '.' und '..' grundsätzlich aufgelistet werden, wieder heraus (und wenn ich
  es richtig sah, wurden inzwischen sogar alle Verzeichnisse aufgelistet). Dies mag an einigen Stellen nützlich sein,
  doch es gibt genügend Situationen, in denen das ausdrücklich nicht gewünscht ist, doch die können dann nichts
  mehr daran ändern (z.B. versucht unser PluginSystem "." und ".." als DLL zu laden, was sicher nicht gut ist).
  Wenn also alle Verzeichnisse sowie bestimmte Dateien gefunden werden sollen, sollte dies ist zwei
  Schritten erfolgen, worin ich kein Problem sehe (der FileDialog macht dieses ja auch genau so), denn diese Lösung
  behindert im Gegensatz zur anderen nicht die entsprechend andere Situation.



>> 31.01.2005
[CO]
- Machte PLTProfiling zum Singleton und passte Engine etc. an.



>> 29.01.2005
[CO]
- Nahm die Module-Templates aus der Engine, benannte diese in ResourceManager etc. um, überarbeitete diese etwas - diese
  Resource-Templates liegen im Base-Unterordner da es universelle Grundklassen sind die man überall gut brauchen kann.
  Dabei implementierte ich es so das man auch Resourcen & Resource Handler OHNE Resource Manager verwenden kann. Ist jedoch
  ein solcher Resource Manager vorhanden so MUSS jede Resource einen einmaligen Namen bestitzen - und das wird intern 
  auch sichergestellt. :)
  Somit können diese Resource & Resource Handler Templates auch in PLRenderer, PLSound etc. verwendet werden, denn dort gibt
  es auch Resourcen, allerdings ohne konkreten Manager dahinter da dies dort unnötig ist - das würde sonst dort zuviel des
  guten sein.
- Die konkreten Template Implementationen von PLTStack, PLTHashTable, PLTHeapBinary, PLTSingleton liegen nun in seperaten
  'inl'-Dateien. Ich finde es einfach übersichtlicher wenn im Header NUR das Interface liegt. :)


>> 26.01.2005
[CO]
- PLTConfig: Funktionen wie GetVarb() hinzugefügt mit dem man komfortabel gleich den Boolean Wert abfragen kann etc.
- PLTFileType::AddSearchPath(): Pfad wird nun intern bei Bedarf 'korrigiert'



>> 21.01.2005
[CO]
- PLTPlatform: GetTickFrequency() entfernt und PLTTimer entsprechend angepasst. Dies war nötig da es erstens so nicht
  unter Linux ging (dort hab es schwere Probleme mit dem richtigen Timing...) und zweitens war das mit der extra Frequenz
  sowieso nicht so brall. ;-) Da der Name 'TickCount' nicht wirklich aussagekräftig war, benannte ich ihn in
  GetMilliseconds() und GetMicroseconds() um, damit weiß man auch sofort in welcher Einheit man die vergangene Zeit
  zurückbekommt. Ein paar Dateien mussten in diversen Teilprojekten angepasst werden, aber nun müsste das etwas Sauberer
  sein.



>> 17.01.2005
[CO]
- Kleinen Fehler in PLTFile::Seek() behoben - das viel mir erst auf als bei FMod das Streaming aus PLTFile einfach
  nicht funktionieren wollte - nun gehts. ;-)



>> 10.01.2005
[CO]
- PLTPlatform: Neue Funktion: GetModuleFileNameEnding() -> Gibt die Dateiendung von Modulen, also unter Windows 
  'dll' und unter Linux 'so' zurück. PLTSystem::ScanPlugins() verwendet nun diese Funktion. Das IMMER über #ifdef
   zu machen wäre keine so dolle Lösung gewesen. :)
- PLRTTIDefs.h: Foreward declaration von PLTSystem eingefügt da es ansonnsten unter Linux einen Compiler
  fehler gibt.
- PLGeneralWin32.h/PLGeneralLinux.h: Dort wird nun PLEXPORT/PLIMPORT definiert da man dies ja seehr oft benötigt.
  PLRTTIDefs.h -> DEFINE_MODULE_PLUGIN verwendet nun PLEXPORT. (ging ja sonst so nicht unter Linux :)
-> Das waren noch die paar Dinge wie Port-mäßig gemacht werden mussten. Damit es unter Linux problemlos übersetzen geht.
- PLStack.h: Nahm PLGeneral.h include raus da ich dann z.B. beim Max Exporter nun durch die weiter intern
  eingebundenen Dinge dazu gezwungen bin PLGeneral dort miteinzubinden was ich aber nicht will. :)
- PLTPlatformWin32::LoadModule() -> Der Dateiname wird nun zuerst in einen Win32-Pfad umgewandelt bevor die Lib
  geladen wird.



>> 10.01.2005
[SB]
- Die Änderung vom 29.12. geht leider so nicht, weil sie dazu führt, daß der DestructionManager
  nicht mehr korrekt gelöscht wird und somit ein Speicherleck entsteht:
  DestructionGuard wird beim beenden deinitialisiert und löscht den DestructionManager
  -> dieser löscht alle Singletons
  -> Singleton ruft PLTDestructionManager::GetInstance()->RemoveObject(this) auf
  -> Dadurch wird der DestructionManager neu erzeugt und nie wieder gelöscht.
  Dies habe ich nur deswegen so ausführlich aufgeschrieben um klarzumachen, daß kleine und völlig
  harmlos aussehende Änderungen beim RTTI sehr bösartig sein können, da das RTTI leider auf vielen
  Tricks basiert, aber genau dies ermöglicht erst, daß es so gut und einfach zu bedienen ist :-)
- Habe nun DestructionManager und DestructionObj gelöscht, statt dessen hat jede Singleton-Klasse
  ab jetzt einen eigenen DestructionGuard, welcher das Singleton beim Beenden wieder löscht
  (damit ist die Abhängigkeit der Singletons von einem weiteren Singleton nicht mehr gegegeben).
- Die Klassen eines Moduls melden sich beim Beenden nicht mehr vom System ab, weil dies ein
  ähnliches Problem wie oben ergab: Die Reihenfolge der Deinitialisierung statischer Variablen
  wird vom Compiler vorgegeben und kann nicht beeinflußt werden, es passiert also, daß zuerst
  das PLTSystem-Singleton gelöscht wird und dann die Klassen eines Modules deinitialisiert werden,
  wenn diese dann PLTSystem::GetInstance()->Remove() aufrufen, wird PLTSystem neu erstellt und
  wir haben wieder ein Speicherleck.
  Um die Abhängigkeiten möglichst gerin zu halten, melden sich also die Klassen nicht mehr ab,
  sondern nur noch das Modul, wodurch automatisch alle Klassen entfernt werden. Um das Problem
  hier zu beheben, gibt es in PLTSingleton nun noch eine Methode CheckInstance(), welche nur die
  Instanz zurückgibt aber keine erstellt. Im oben genannten Fall meldet sich ein Modul also
  nicht mehr ab, wenn das System bereits deinitialisiert worden ist, denn in diesem Fall
  wurden ja sowieso schon alle Klassen beim Beenden gelöscht.



>> 09.01.2005
[CO]
- PLTPool: GetElements() in GetNumOfElements() umbenannt, PLTProfiling musste entsprechend angepasst werden.
- PLTArray & PLTBitset & PLTList: Compare() so umgeschrieben das der Operator != nun nicht mehr zwangsläufig vorhanden
  sein muss



>> 03.01.2005
[CO]
- PLTSearchFilter::CheckMatch() -> '.' und '..' kommen nun immer durch den Test, ansonnsten gibts probleme beim Auflisten
  des Inhaltes eines Verzeichnisses.
- PLTFSTools::GetFileNameEnding() -> Berücksichtigt nun auch nicht vorhandene Dateinamen Endungen
- PLTFSTools::ValidatePath() -> Fügt nun am Ende des Pfades noch ein / an falls dort keines ist damit Pfade immer mit /
  Enden.



>> 29.12.2004
[SW] + [CO]
- Die Linux Tests Crashten immer nachdem das Programm bendet wurden - nach Stundenlanger Such und dem durchgehen aller
  möglichkeiten waren wir schon nahe am Verzweifeln da man sich den Crash einfach nicht erklären konnte. Tja, und irgendwie
  landeten wir dann eher per Zufall im Destruktor von PLTDestructionManager und dort Crashte es beim Löschen eines Objektes.
  Es stellte sich raus das Zeiger ungültig waren - ein Blick auf den Destruktor von PLTDestructionObj zeigte das sich Objekte
  nicht wieder bei Tot abmeldeten sondern sich einfach ins Nirvana schlichen. ;-)
  Kleines Problem, merkwürdige Phänomene - viele Stunden suchen. ;-)
- PLGeneral und PLMathLib auf Linux portiert:
  -> Nun laufen PLBaseTest, PLFileTest und PLMathTest auch problemlos und sauber unter Linux - wir haben Teils auch alles über
     Eclipse Debugt etc. Jetzt da diese Dinge auf zwei Platformen laufen kann man annehmen das es so nun schon recht ordentlich
     ist.  :):)



>> 27.12.2004
[CO]
- Passte PLTTimer an die aktuellen Änderungen an. Die Timer Klasse verwendet nun PLTPlatform und ist dadurch Platform unabhängig
  und die ganzen Timer Platform-Dinge konnten entfernt werden - erleichtert das Portieren. :)
- Erweiterte PLTPlatform um GetTickFrequency() - wird für PLTTimer benötigt
- Dort wo in PLGeneral noch PLTDynamicList verwendet wurde stellte ich auch PLTArray um. Hab nun die alten Listen Klassen +
  PLTDataSet was wir ja mittlerweile nicht mehr brauchen gelöscht. Desweiteren alte Stack-Klasse herausgenommen.
  -> Endlich wieder Ordnung in PLGeneral - da Stephan und ich uns die nächsten Tage intensiv mit der Linux Portierung beschäftigen,
     wollte ich dieses alte Zeug draußen haben so das wir nicht mit unnötig vielen Dateien jonglieren müssen.



>> 26.12.2004
[CO]
- PLTArray: Musste internes Speicher Management etwas umstellen da es Probleme mit Klassen welche Klassen etc. beinhalten gab
  ... diese wurden dann nicht korrekt Initialisiert wenn alle Element in einem großen Buffer lagen. Nun hat PLTArray einen Buffer
  aus Zeigern auf die Elemente welche über new erzeugt und über delete wieder gelöscht werden... hat den kleinen Vorteil das nun
  auch die Konstruktoren & Destruktoren verwendung finden. :)
  -> Mittlerweile ist auch das merkwürdige Static Initialization Problem in der Engine verschwunden und alles läuft wieder
     einigermaßen - so langsam müssten die Container Klassen aber so passen. :):)



>> 25.12.2004
[CO]
- PLTFileSystem: Um GetNumOfFileTypes() & GetFileType() & RemoveFileType() erweitert damit ich in 
                 GuiFileSystemDialog die Search Path Ansicht füllen konnte
- In PLTFileSystem::AddSearchPath() wurde der File Type Name nicht korrekt gesetzt
-> Diese Änderungen wurden nur gemacht um GuiFileSystemDialog implementieren zu können - es zeigte sich ja schon bei
   GuiSystemView das es ganz Praktisch ist diese Dinge über einen Dialog 'anfassbar' zu machen... zudem wird dieser Dialog
   auch in PixelLab verwendung finden damit man Einstellen kann von wo die Daten kommen sollen.
- PLTBitset & PLTArray: Resize() kann nun optional mitgeteilt werden das ALLE Speicherplätze für Elemente automatisch
  zugreifbar sind... ist dann so als hätte man alle Elemente einzelnd hinzugefügt. Dies ist immer wieder nützlich wenn man
  einfach ein Feld haben will bei dem man frei auf die Elemente zugreifen kann ohne vorher alle über Add hinzugefügt zu haben
  wie dies bei 'normalen Listen' der Fall ist.
  Wenn man Resize() per Hand aufruft sind immer standardmäßig ALLE Elemente gleich verfügbar, so, als hätte man alle über Add()
  hinzugefügt - denn wenn man schon selbst Resize() aufruft erwartet man normalerweise das alles gleich zugreifbar ist, xxx
  mal beim Array Add() aufzurufen wäre schlichtweg zu umständlich. :)



>> 24.12.2004
[CO]
- PLContainer: AddAtIndex(int nIndex) hinzugefügt um ein neues Element an einer bestimmten Stelle zu erzeugen
- In PLTConfig() korrekten Config Klassen Name gesetzt



>> 22.12.2004
[CO]
- PLTFSTools: Neue Funktionen: - GetFileNameEnding() -> Liefert die Datei-Endung zurück
                               - CutFileNameEnding() -> Liefert Dateinamen ohne Endung
                               - GetDirectory() -> Liefert das Verzeichniss eines Dateinamens zurück
- PLContainer Klassen minimal erweitert



>> 21.12.2004
[SB]
- PLTBase.h: Die virtuelle Funktionen stehen nun in einem eigenen Bereich, wie wir es sonst auch meistens haben. Ich finde
  das zwar an dieser Stelle etwas unschön, da z.B. die beiden ToString() Methoden damit auseinandergerissen werden, es
  dient jedoch der Übersicht des Programmierers. Die Dokumentation der Methoden habe ich auch noch etwas erweitert.
- PLGeneral: Die Definition von systemabhängigen Klassen wird nun einheitlich in den Include-Dateien für das jeweilige
  System vorgenommen. Dies führt zwar dazu, daß einige Header immer eingebunden sind, scheint mir jedoch besser zu sein,
  da dann alle Plattformdefinitionen an einem Ort sind und somit schnell wiedergefunden werden können.
- FileSystem: PLNativeDirectory.h gelöscht und die Definition entsprechend nach PLGeneralWin32/Linux.h verschoben
- PLTTimer: Anpassung an unseren üblichen Stil, die Basisklasse ist nun abstrakt, da es kaum sinnvoll ist, diese direkt
  zu instanziieren (es gibt ja auf jeder Plattform eine systemspezifische Implementierung). Die Konstrukturen/Destruktoren
  sind nun protected (nicht unbeding nötig, aber einheitlich), und auch die Basisklasse besitzt Konstruktur/Destruktor
  wobei der letztere virtuell ist, da die Klasse virtuelle Methoden besitzt. Auch hier wurde die Definition von PLTTimer
  verschoben
- PLTPlatform: Neue Klasse, welche plattformabhängige Systemfunktionen enthält. Der Einfachheit halber, und weil man es
  vom Namen her sowieso so erwarten könnte, habe ich PLTSystem einfach von dieser Klasse abgeleitet - damit braucht man
  sich nicht mehr überlegen, wer wo eine Instanz davon erzeugen könnte sondern bekommt diese bei PLTSystem::GetInstance()
  ja gleich mit (nur für die Doku ist es nicht so schön, weil die Systemfunktionen nicht direkt in PLTSystem dokumentiert
  sind, allerdings sollten diese Funktionen sowieso nicht von einer Applikation verwendet werden, da wir ja alles schön
  mit unserem eigenen System abgekapselt haben). Auch die Timerfunktionen sind jetzt in PLTPlatform zu finden - fragt
  sich ob das so gut ist, wenn ja müßten wir eigentlich auf die Unterteilung der Timerklassen verzichten können, oder?
- PLTSystem: Zum Zugriff auf dynamische Bibliotheken wird jetzt PLTPlatform verwendet, womit PLTSystem jetzt hoffentlich
  plattformunabhängig ist



>> 21.12.2004
[CO]
- Behob kleines Problem in PLTBase::GetVars() mit dem vergleichen von Default-Werten - denn z.B. bei float-Werten können
  u.a. am ende noch diverse Nullen sein - um solche Probleme zu verhindern wird zuerst der aktuelle Wert der Variable gespeichert,
  dann wird der Default Wert gesetzt welcher dann wieder als String ausgelesen wird, anschließend wird der Variable Wert wieder
  auf seinen aktuellen Wert gesetzt - und nun hat man zwei vergleichbare Strings welche bei float Zahlen am Ende gleich viele  
  Nullen haben wodurch korrekt geprüft werden kann ob dies wirklich der Default Wert ist.
  -> bei pVar->Set() ist es an dieser Stelle unnötig und vielleicht auch etwas Riskant das in Set() pObject->VarChanged(m_szName);
     aufgerufen wird, vielleicht könnte man es hier noch etwas schöner machen - hab aber die Finger davon gelassen da es ansonnsten
     zu viele Änderungen geworden wären... Stefan, wenn du Zeit und Lust hast kannst du ja mal schaun wie man das besser Lösen
     könnte. :)
- Bei PLTBase::ToString() -> pszBuffer[nCopy+1] zu pszBuffer[nCopy] gemacht da das letzte Zeichen ansonnsten Schrott war :(
- PLTIterator um Funktionen erweitert um zum vorherigen Element zu springen, dies ist hin und wieder nötig wenn z.B. während
  der Iterator verwendet wird ein Element aus der Liste gelöscht wird, in dem Fall muss man den Iterator um ein Element 
  zurücksetzen und ganz nebenbei wird nun endlich auch pPreviousElement in PLTList verwendet.
  (Previous() brauchte ich zum ersten mal in GuiSys::Update())
- PLContainer: AddAtIndex() ist Index = -1 wird nun am Ende eingefügt (wie früher)



>> 19.12.2004
[SB]
- Containerklassen in PLGeneral eingebaut, dabei die alten Klassen umbenannt, damit diese noch verwendet werden können
  und schrittweise umgestellt werden kann
- Iteratoren: Remove() entfernt, ein Iterator dient nun nur noch zum Anschauen der Container, nicht zum Ändern. Dadurch
  ist es auch möglich, Iteratoren von const-Listen zu erhalten, dies ging vorher leider gar nicht
- Container: Jeweils einen operator= hinzugefügt, welcher die selbe Klasse als Parameter erwartet. Dies scheint leider
  nötig, da der Compiler diese Methode anscheinend implizit verwendet und nicht die vorhandene Methode mit PLTContainer
  als Parameter verwendet, wenn beide Operanden vom selben Typ sind (bei z.B. *pList = *pArray geht es dagegen!)
- PLGeneral: Auf neue Containerklassen umgestellt. Zunächst ist dies nur eine 1:1 Umstellung, also noch keine Verbesserung
  der Interfaces was Listen/Container angeht, dies wird im nächsten Schritt passieren (erstmal sehen, ob alles noch
  funktioniert)
- RTTI: Kleinen Fehler bei der Registration von Modulen behoben. Wenn ein Module zuerst registriert wird, bevor Klassen
  aus diesem Modul registriert worden sind, war die ModuleID noch nicht gesetzt worden, was dazu führte daß die Klassen
  nicht dem Modul zugeordnet werden konnten. Da man auf die Reihenfolge der Initialisierungen keinen Einfluß hat (das
  macht der Compiler), kann dies mal so und mal so passieren, es muß also in beiden Fällen funktionieren - und ich hatte
  es auf den worst-case ausgelegt, so daß der best-case fehlerhaft war ;-))



>> 19.12.2004
[CO]
- PLTFSTools: Um GetPathInfix() erweitert damit es vollständig ist. (prefix, infix & postfix :)
  Wollte das zuerst in GuiSys::SaveWindows() verwenden, dort reicht aber schon GetPathPrefix().



>> 18.12.2004
[CO]
- PLTVar::SetFlagsString(): Kleine zusätliche Abfrage eingebaut damit bei Flags am anfang kein '|' steht.
- PLTVar: Musste m_szEnum vergrößern da z.B. bei GuiSlider mehr Zeichen benötigt werden (hab lustige fehler am ende :)
- PLTFile::PrintLn() musste Buffer etwas vergrößern da es oft nicht reichte - vielleicht finden wir da bei Zeiten ne bessere
  Lösung für die Dynamische Übergabe von Strings - f(char *text, ...)



>> 18.12.2004
[SB]
- PLTClass:  Constructor und Destructor sind jetzt protected, da ja nur die Klassen selber eine Instanz von sich erzeugen
             sollen und diese dann selbständig am System anmelden
- PLTModule: Die Informationen über das Modul wurden in zwei Teile aufgeteilt, einmal dem Info-Teil bestehend aus
             Name/Vendor/Description, und dem Handle-Teil, bestehend aus ModuleID, Instance-Handle und Dateinamen
- PLTSystem: Neue Funktion zum Registrieren von Modulen eingebaut. Ein Modul wird erzeugt, sobald die erste Klasse aus
             diesem Modul registriert wird, dann wird auch die Module-ID zugeordnet, danach kann dann diese Funktion
             verwendet werden, um die Informationen über dieses Modul zu setzen
- PLTSystem: Einige Umstrukturierungen sowie Namensänderungen der Funktionen, die Funktionen zum Registrieren sind nun
             protected, womit das ganze wenigstens halbwegs sauber ist ;-)
- RTTI:      Makros zum Registrieren von Modulen so angepaßt, daß diese sich per Selbstinitialisierung nun ebenfalls beim
             System anmelden, um ihre Informationen zu übertragen. Dadurch können nun sowohl interne als auch plugin-module
             registriert werden, die Makros wurden dafür entsprechend angepaßt und erweitert
- PLGeneral: Hauptdatei PLGeneral.cpp hinzugefügt, in welcher das PLGeneral-Modul registriert wird



>> 15.12.2004
[CO]
- Neue Listen-Klassen geschrieben welche die alten ersetzen werden. Es gibt nun eine universelle abstrakte Klasse namens
  PLTContainer. PLTList, PLTArray und PLTBitset werden davon abgeleitet. Desweiteren gibt es eine universelle Iterator
  Klasse für die es jeweils pro Listen-Art eine spezielle Variante gibt. Die Codes hab ich noch nicht in PLGeneral 
  geladen da Stefan die Anpassungen in PLGeneral & PLGui vornehmen wird.



>> 13.12.2004
[CO]
- PLConfig.h: PLTConfigGroup eingeführt, alle Configurations Gruppen sollten davon abgeleitet werden.



>> 13.12.2004
[SB]
- Module:    Es gibt nun für jedes Module eine eindeutige ModuleID, welche von PLGeneral und nicht vom System vergeben wird.
             Über diese ID sollten die einzelnen Module angesprochen werden, da dies auf jeder Plattform funktioniert,
             die System-Handles sollten nur noch dann verwendet werden, wenn z.B. ein Modul wieder entladen werden soll,
             was jedoch innerhalb von PLTSystem passiert (es dürfte also eigentlich gar keinen Grund geben, das System-Handle
             anstatt der ModuleID zu verwenden).
- Module:    Klasse überarbeitet, so daß nur PLTSystem die wichtigen Daten der Klassen ändern kann sowie Zugriff auf die
             darin enthaltenen Klassen hat. Ebenso einige Änderungen bezüglich der Daten, da bei neuen Module zunächst
             nur die ModuleID bekannt ist, während die anderen Daten (Dateiname, Name, Vendor) erst später bekannt
             werden. Btw: Es hat seinen Grund, daß der Name nur Module und nicht PLTModule ist :-)
- PLTClass:  Anstatt des Module-Handles besitzt die Klasse nun nur noch die ModuleID ihres Modules
- PLTSystem: Auch hier wurden die Module-Handles durch Module-IDs ausgetauscht. Außerdem besitzt diese Klasse nun eine
             Methode, um die eindeutigen IDs zu erzeugen, dies wird von den RTTI-Makros benutzt um für jedes Modul
             eine eigene ID zu erhalten
- RTTI:      Die Makros wurden so geändert, daß sie pro Modul eine eindeutige ID erhalten und diese in ihren Klassen
             vermerken. Damit ist das System in der Lage, jede Klasse einem eindeutigen Modul zuzuordnen, auch wenn
             das System-Handle dieses Modules zur Zeit der Registrierung noch nicht bekannt ist (was leider immer
             der Fall ist, deswegen kann nicht einfach die HINSTANCE durchgereicht werden). Um dies zu erreichen,
             speichert eine Template-Klasse die ModuleID, welche sie vom System bekommen hat, und gibt diese an
             die Klassen weiter. Später setzt das System die zugehörigen Daten wie System-Handle, Dateinamen etc.
             im Modul, so daß diese Daten angezeigt werden können. Anmerkung: Dieses Vorgehen führt dazu, wirklich
             jedes Modul seine eigene ID bekommt, auch alle nicht dynamisch geladenen, dadurch sind also
             PLGeneral/PLEngine/PLGui/etc. unterschiedliche Module, welche allerdings erstmal alle den Namen
             "Internal" bekommen (wie kann man von loadtime-gelinkten DLLs den Namen herausbekommen?). Ob das ein
             Vor- oder Nachteil ist, kann unterschiedlich sein, wenn jemandem einfällt, wie man anders die Module
             und Klassen zuordnen kann, bitte sagen :-)
- PLTClass:  Der Gruppenname wurde entfernt, dafür kann jede Klasse als Basisklasse einer Gruppe definiert werden, welche
             dann alle abgeleiteten Klassen enthält
- RTTI:      Das Makro DEFINE_GROUP() angepaßt
- PLTSystem: Gruppen wurden entfernt, dafür kann bei GetClassList() die Basisklasse angegeben werden. Zusätzlich können
             alle als Gruppen definieren Klassen zurückgegeben werden



>> 12.12.2004
[CO]
- Bei der Klasse Module fehlten noch ein paar PLGENERAL_API - vielleicht sollte man diese Klasse bei Zeiten in 
  PLTModule umbenennen damit es einheitlich ist.
- PLTSystem::UnloadPlugin() -> Nur Dynamische Module können entladen werden
- PLTSystem::ScanPlugins() -> verwendet nun LoadPlugin() um die Module einzuladen
- PLTSystem::LoadPlugin() -> Module werden nun korrekt regestriert
- IsClass(), IsClassGroup() und IsModule() - hm, vielleicht wäre ne art von Iterator Klasse nicht schlecht damit das 
  überall einfach Einheitlich ist :)



>> 30.11.2004
[SW]
- PLGeneral: linux port + project archiv upgedated



>> 29.11.2004
[SB]
- PLTBase: Der Destruktor ist nun wieder protected, da dies unbedingt nötig ist, wenn das ganze RTTI System überhaupt
           einen Sinn machen soll. Das Problem ist, wenn der Destruktor in PLTBase öffentlich ist, kann jede Klasse
           damit gelöscht werden, es besteht für die Klasse also keinerlei Möglichkeit mehr, dies zu verhindern. Damit
           wird die Verwendung von DEFINE_CLASS_PRIVATE() nutzlos, und alle Sicherheitsvorkehrungen von abgeleiteten
           Klassen können damit umgangen werden: z.B. PLTRefCount ist so angelegt, daß es sich nur selber löschen
           kann, wenn der RefCount auf 0 sinkt, dies stellt sicher daß das Objekt niemals gelöscht werden kann, wenn
           es noch irgendwo gebraucht wird. Wenn nun aber PLTBase einen öffentlichen Destruktor hat, wird es
           möglich, dieses Verhalten von PLTRefCount zu umgehen und das Objekt von außen ungeachtet des RefCounts
           zu löschen, was natürlich gravierende Fehler zu Folge haben könnte. In PLTBase ist dies nun außerdem
           näher erleutert, warum Constructor und Destructor von PLTBase protected sind :-)
- RTTI:    Habe das RTTI nun so erweitert, daß ein Objekt mit PLTBase::Destroy() gelöscht werden kann, FALLS dessen
           Klasse mit DEFINE_CLASS() und nicht mit DEFINE_CLASS_PRIVATE() definiert wurde. Auf diese Weise kann
           man ein Objekt nur mit Hilfe eines PLTBase-Pointers löschen, aber nur wenn die Klasse dies explizit
           erlaubt, denn dies ist wichtig um die Wahl bei den Klassen zu belassen (s.o.).
           Hierzu waren einige Änderungen in PLTBase, PLTClass und PLRTTIDefs notwendig



>> 26.11.2004
[CO]
- PLTBase: Musste Destruktor public machen damit ich Klassen Instanzen von denen ich nur einen Zeiger auf 
  PLTBase habe auch wieder zerstören kann. Ich hoffe das ist ok so - ich fand keine andere möglichkeit...
  (siehe PLTConfig::~PLTConfig())
- Neues Configuration-System PLTConfig als Singleton implementiert. Dieses Config-System verwendet das RTTI
  und lässt sich daher sehr einfach bedienen und erweitern. Load() & Save() ist noch nicht implementiert,
  ansonnsten funktioniert alles.
          


>> 24.11.2004
[CO]
- Neue Datenstruktur: PLTHeap welche als Prioritätswarteschlange verwendet werden kann. Bereits implementierter
  konkreter Heap: PLTHeapBinary. Ich entschloss mich zu dieser abstrakten Template realisierung damit der Schlüssel
  und der damit verbundene Wert sowie die konkrete Implementation möglichst universell sind.



>> 21.11.2004
[CO]
- PLTQuickSort: QuickSort Algorithmus der später u.a. zum sortieren der Partikel verwendet wird. Ich hab versucht
  die Klasse so allgemein wie möglich zu halten, die Compare Funktion wird ähnlich wie in Java über eine abgeleitete
  Klasse implementiert. Lässt sich im Prinzip also genauso verwenden wie das bereits in VC vorhandene qsort - aber
  ich denke es ist das beste wenn man da was eigenes hat, man weis ja nie... ;-)



>> 21.11.2004
[SB]
- PLMain.h: Diese Datei beinhaltet nun einen plattformunabhängigen Einstiegspunkt für die Programme. Die Lösung per Makro
  war zwar eine gute Idee, jedoch nicht wirklich praktikabel, da ein Zugriff auf Programmparameter und Optionen damit 
  faktisch unmöglich gemacht worden wäre, denn diese Parameter wären nach wie vor je nach System unterschiedlich gewesen.
  Auch fand ich die Verwendung dieser Makros nicht sonderlich schön, da innerhalb eines Makros-Blocks dann der
  Funktions-Quellcode gestanden hätte, man aber gar nicht gewußt hätte, wie diese Funktion nun wirklich aussieht.
  Ein Programm, welches die plattformunabhängige Einstiegsfunktion verwenden will, muß nun einfach PLMain.h einbinden
  und die Funktion PLMain deklarieren, die Parameter dieser Funktion sind dabei nun wirklich auf jedem System gleich,
  da sie je nach OS unterschiedlich implementiert wird.
  Es muß natürlich darauf geachtet werden, daß PLMain.h nur ein einziges Mal in eine .cpp Datei eingebunden wird, da
  ansonsten die Einstiegsfunktion für das System mehrfach im Programm vorhanden wäre und es dann beim Linken natürlich
  einen Fehler gäbe. Dies sollte aber kein Problem darstellen, wenn dies einfach in der main.cpp verwendet wird, wie
  es wohl natürlicher Weise der Fall sein sollte.
- PLRTTIDefs.h: Makros für den Programm Einstiegspunkt entfernt



>> 20.11.2004
[CO]
- PLRTTIDefs.h: Makros für den Programm Einstiegspunkt hinzugefügt. (DEFINE_MAIN/END_MAIN) Diese sind zwar Optional, sollten aber
  IMMER verwendet werden damit man Plattform unabhängig bleibt ohne sich immer selbst drum kümmern zu müssen.



>> 19.11.2004
[CO]
- PLTTimer zum Singleton gemacht, PLTTimer in PLTTimerBase umbenannt und PLTTimer definiert das wie beim Gui automatisch jeweils korrekt
  je nach Plattform definiert wird so das man sich nicht mehr drum kümmern muss. Hab auch gleich die Linux Variante mit angepasst,
  Stephan - bitte gleich mal prüfen ob ich nicht fehler reingemacht hab. :)
  Passte gleich alle Codes an so das der Renderer nun endlich von der Engine selbst unabhängig sein kann.
- PLTLog: Ein paar kleine Änderungen gemacht, z.B. wird nun bei PLTLog::OutputString(const char *pszText) direkt in die Datei geschrieben
  damit man keinen Crash bekommt wenn der String länger als 1024 ist. Bei den mit ,... gehen wir einfach momentan noch aus das diese Strings
  nicht ZU lang werden. ;)
- PLTFile: PutC() -> Parameter mit const versehen



>> 18.11.04
[SW]
- Bis auf das FS auf linux portiert und ein paar kleine include fehler behoben (pfadangaben)



>> 15.11.2004
[SB]
- PLTPluginManager wurde wieder ausgebaut, und dessen Funktionalität nach PLTSystem verschoben. Dies ist sinnvoller
  und vor allem für den Programmierer einfacher, da PLTSystem besser zwischen den Klassen und den Modulen verknüpfen
  kann - das wäre mit einer getrennten Lösung kaum möglich gewesen, da die Libraries und die Klassen damit scheinbar
  voneinander getrennt gewesen wären. Da PLTSystem nun aber beides managed, kann es die Klassen gleich den entsprechenden
  Modulen zuordnen und bietet so auch für den Programmierer einen flexibleren Zugriff auf diese Informationen.
  PLTSystem ist jetzt also eine übergeordnete Klasse, die der Programmierer nutzen kann um auf Klassen und Bibliotheken
  zuzugreifen sowie alle Plugins zu managen, ohne dabei die Struktur der Applikation oder der Plugins festzulegen.
- PLTSystem wurde noch einmal in großen Teilen umgebaut, und ist nun sowohl einheitlicher als auch komfortabler.
  Dabei gibt es für Klassen, Gruppen und Module jeweils eine Methode GetXXXList(), um alle Objekte des Typs aufzulisten,
  sowie eine Methode GetXXX(), um einzelne Objekte per Name bzw. ID anzusprechen. Es ist jetzt also möglich, alle
  Klassen, Gruppen oder Module aufzulisten sowie deren Zugehörigkeiten untereinander zu erkennen. Die Methode
  GetClassList() wurde dabei so erweitert, daß entweder alle Klassen, oder alle Klassen einer Gruppe und/oder eines
  Moduls aufgelistet werden können, was die Einordnung der Klassen wiederum vereinfacht. Intern wurden die Methoden
  vereinheitlicht, außerdem sind die Add/Remove Methoden nun protected und können also nicht mehr wie vorher von
  außen aufgerufen werden, was hätte mißbraucht werden können.
- Die wahnwitzigen RTTI-Makros wurden noch einmal umgebaut, indem die Register-Funktionen nun nicht mehr Teil der
  zu registrierenden Klasse sind, sondern Teil der geschachtelten Info-Klasse. Durch Ableitung von der Basisklasse
  PLTClass und Aufruf der darin deklarierten Basisfunktionen _Register und _Unregister kann die Klasse dann bei PLTSystem
  angemeldet werden. Dieser weitere Trick dient nur dazu, die Add/Remove-Methoden von PLTSystem nach außen abzuschotten
  und als protected zu deklarieren, damit diese nicht beliebig aufgerufen werden können.
- Da sich die RTTI-Makros verändert haben, müssen sämtliche Projekte, welche diese verwenden, neu übersetzt werden, damit
  die Klassen vom aktuellen System korrekt registriert werden können. Dies sollte jedoch in der Zukunft nicht mehr so
  oft vorkommen :-)



>> 06.11.04
[SB]
- PLGeneral: Das Template PLTShared wurde gelöscht, die Idee war zwar nicht schlecht, hätte aber zu mehr Verwirrung geführt
  als daß es Nutzen gebracht hätte. Es gibt nun also nur noch Singletons, welche nur eine globale Instanz der Klasse
  erlauben, dies gilt z.B. für Syste, FileSystem, Log, etc. Die Klassen sollten also so strukturiert werden. daß entweder
  beliebig viele Instanzen möglich sind (wie z.B. bei der Gui), oder nur eine globale Klasse, um eine saubere Struktur
  zu bewahren.
- PLGeneral: Neue Klasse PLTPluginManager eingebaut, welche das Laden und Verwalten von Plugin-DLLs übernimmt. Dabei wird
  überprüft, ob eine DLL bereits geladen wurde und ob debug/release Modus übereinstimmen. Das Scannen einen Verzeichnisses
  nach Plugins wird zunächst von der Engine aufgerufen, jedoch kann ein Programm auch weitere Verzeichnisse Scannen.
  Zur Definition von Plugin-DLLs wurde PLRTTIDefs.h um entsprechende Makros erweitert.



>> 05.11.04
[SB]
- PLTRefCount: Abfrage des counts ist nun eine const-Funktion
- PLTFileSystem: Ist nun wieder ein singleton, es kann also nur eine einzige Instanz davon geben, die von allen
  Programmteilen verwendet werden muß. Dies ist aber kein Problem, da die Verwaltung von Suchpfaden nun doch
  nicht zentral im FS stattfinden wird, da dies einfach zu komplex geworden wäre (vor allem auch die Verwaltung
  durch den Programmierer, denn die Implementierung war ja bereits komplett).
- PLTFileSystem: Beim erstellen des FS wird nun das aktuelle Verzeichnis vom OS übernommen
- PLTFSTools: GetFileName() gibt den Dateinamen aus einem kompletten Pfad zurück (splitpath() äquivalent)
- PLTWin32Directory: Bei Angabe von "." wird das aktuelle Verzeichnis vom OS genommen
- PLTLog: Ist ebenfalls wieder ein Singleton, zur Unterscheidung verschiedener Logs wird diese Klasse entsprechend erweitert



>> 27.10.04
[CO]
- Behob kleinen 'Fehler' in den Vektor und Farb Klassen welche Offset Probleme im zusammenspiel mit dem RTTI erzeugten.
  Heute dazugelernt: "Vorsicht beim umgang mit this Zeigern!" ;-)
  Desweiteren ist es beim RTTI erfordlich das ALLE von PLTBase abgeleiteten Klassen virtuelle Destruktoren haben da es 
  ansonnsten bei delete [] zu einem Crash kommt - ebenfalls in PLTBase Notiert.



>> 15.10.04
[SB]
- PLTStack2: Da leider jedes Mal, wenn ich die Stack-Klasse benutzen will, irgend etwas nicht funktioniert, habe ich
  eine neue, sehr einfache Stack-Klasse geschrieben, welche auch wirklich nur das tut, was von einem Stack erwartet
  wird und dafür hoffentlich stabiler ist als die bisherige Klasse. Implementiert sind die Standardmethoden eines
  Stacks, Push()/Top()/Pop(), sowie noch eine Extramethode PushBack(), um ein Element an das andere Ende des Stacks
  anzufügen (dies ist vor allem beim Kopieren eines Stacks sehr wichtig). Ansonsten ist der Stack als einfache
  verkettete Liste implementiert, was vollkommen ausreicht da ja nur auf das Top-Element des Stacks zugegriffen werden
  kann, worauf immer ein direkter Zeiger existiert. Ein beliebiger Zugriff auf alle Elemente des Stacks ist also nicht
  implementiert und sollte auch nicht gebraucht werden, für einen solchen Fall sollte entweder eine Liste oder eine
  Array-Klasse verwendet werden. Dann ist auch endlich gegeben, daß sich die Containerklassen wirklich voneinander
  unterscheiden und somit je nach Situation optimal eingesetzt werden können.
  Die alte Klasse PLTStack sollte nun überall durch PLTStack2 ersetzt werden, oder durch eine andere Containerklasse,
  falls die Stackoperationen nicht ausreichend sind für einen bestimmten Fall, danach sollte die alte Klasse gelöscht
  werden und die neue Klasse in PLTStack umbenannt werden. Die zwei Klassen sollen also nur vorübergehend nebeneinander
  existieren, um die Anpassung zu erleichtern
- PLTTokenizer: Auch hier habe ich zunächst Änderungen vorgenommen, ohne die alte Version davon zu entfernen, damit die
  entsprechenden Stellen problemlos angepaßt werden können. Die Methoden Push()/Pop() implizieren schon vom Namen her
  eine Stack-Funktionalität, die sie dann jedoch nicht bieten, da nur ein einziger State gespeichert werden kann. Solche
  Dinge sind es aber, die später andere Programmierer, die mit PL arbeiten wollen, in den Wahnsinn treiben werden, denn
  ein Programmierer weiß, was er von einer Push()/Pop() Methode erwarten kann und wird nicht auf den Gedanken kommen, 
  daß der Name vielleicht zu viel verspricht. Ich habe daher einen echten Stack in den Tokenizer eingebaut sowie
  Funktionen, um auf diesen zuzugreifen. Mit PushState() kann der aktuelle Status des Tokenizers auf dem Stack gespeichert
  werden, mit PopState() wird dieser wiederhergestellt oder mit DropState() vom Stack verworfen. Damit ist ein einfacher
  recursive-descent parser, der natürlicher Weise mehr als einmal den Status speichern muß, also sehr leicht zu schreiben.
  Auch hier sollten die alten Methoden entfernt werden und durch die neuen ersetzt werden, sobald alle Stellen angepaßt
  sind, wo dies verwendet wird. Sollten die alten Methoden aus irgend einem Grund erhalten bleiben, könnten sie z.B. in
  SaveState()/RestoreState() umbenannt werden, was auch ihrer Funktionalität entspräche.



>> 08.09.2004
[CO]
- PLTArray um const [] erweitert



>> 05.09.2004
[CO]
- PLVar.h: Zwei Includes hinzugefügt



>> 29.08.2004
[SB]
- PLTRefCount: GetRefCount() ist nun const
- PLTVar besitzt nun eine Funktion, um eine Zeiger auf die Variable selbst zu erhalten. Da der Variablentyp natürlich nicht
  bekannt ist, ist der Rückgabewert ein void* Zeiger. Diese Funktion sollte natürlich nur mit größter Vorsicht verwendet
  werden, da man hiermit quer im Speicher rumschreiben kann. Auch alle Sicherheitsmechanismen wie readonly-variablen können
  mit dieser Funktion natürlich umgangen werden. Dennoch war eine solche Funktion nötig, um z.B. bei Variablen von Typ
  PL_VAR_CLASS an den Klassennamen heranzukommen (hierzu muß man sich den Zeiger auf das Objekt zurückgeben lassen und dann
  mit PLTBase::GetClassName() den Klassennamen ermitteln). Hierzu viel mir leider bisher kein besserer Weg ein...



>> 28.08.2004
[CO]
- Fügte PLTList<AType>::Add() noch einen Parameter hinzu mit dem man bei bedarf verhindern kann das geprüft wird ob etwas bereits
  in der Liste ist. Bei GuiListBox war es tötlich wenn extrem viele Elemente eingefügt wurden - da war der Aufwand ganz enorm so das 
  es teils viele Sekunden dauerte bis alles eingefügt war. :(
  Durch das deaktivieren des Tests geht es zwar nur etwas flotter, aber immerhin.
  


>> 26.08.2004
[SB]
PLGeneral:
- Habe PLGeneral.h umgebaut: Hier werden nun die OS-Spezifischen include-files eingebunden, so daß die Verwendung möglichst
  auf allen Betriebssystem identisch ist. Bei einer Portierung wird also einfach eine neue .h-Datei hinzugefügt und
  in PLGeneral.h mit den entsprechenden #ifdef's eingebaut. In PLGeneralWin32.h und PLGeneralLinux.h sind nun für das
  jeweilige Betriebssystem die import/export Makros sowie  die Datentypen definiert.
  Die Unterscheidung zwischen Import und Export geschieht nun nicht mehr über unterschiedliche .h Dateien sondern
  über eine Compilerdefinition (welche von VC++ automatisch gesetzt wird, diese müßte dann nur für Linux in die
  Makefiles eingebaut werden)
- Datentypen angepaßt, es werden nun nur noch die nötigsten definiert: int32, uint32, etc. Diese sollten nur da verwendet
  werden, wo es auf die Bitgröße des Datentyps explizit ankommt, also meist bei Dateizugriffen. Ansonsten sollten nur
  noch die primitiven Datentypen, also z.B. int, long, ... verwendet werden (für Flags z.B. unsigned long). Da DWORD/WORD
  von vielen als Windows-Datentypen verstanden werden, die man nicht braucht, habe ich mich für die Bezeichnung
  int16/int32/int64 entschieden, um klarzumachen daß es nur um die Bitgröße der Datentypen geht.
- PLTypes.h: Alle immer wieder verwendeten Datentypen/Definitionen der Engine befinden sich nun in dieser Datei,
  statt wie vorher noch in PLEngine. Da PLGeneral von den anderen Teilprojekten eingebunden wird ist dies besser,
  so muß PLEngine nicht mehr eingebunden werden, um z.B. die Definitionen für X/Y/Z verwenden zu können, wie dies
  bisher der Fall war
- Dummerweise vergessene PLGENERAL_API in PLTVar eingefügt :-)
RTTI:
- PLTSystem: Fehler bei den ClassGroups behoben: Da "" nicht als gültiger Hash-String gilt, wird nun ein Dummy-GroupName
  verwendet, um Klassen ohne Gruppe zu bezeichnen
- SelfInit-Class so erweitert, daß Klassen auch wieder automatisch ausgetragen werden, wenn das entsprechende Modul
  entladen wurde. Wenn kein SelfInit verwendet wird, muß der Programmierer stattdessen das Makro UNREGISTER_CLASS verwenden.
  Wie er mitbekommt, daß seine DLL entladen wurde, ist dann allerdings sein eigenes Problem ;-)



>> 18.08.2004
[CO]
- PLTBase::ToString: Behob String Problem, der Zeiger auf den Speicher wurde ungültig da das String Objekt nach ToString() wieder
  zerstört wurde und auch den String-Speicher selbst dabei killte.
- PLTSystem: Zwei neue Funktionen: GetVarType() & GetVarTypeAsString()



>> 10.08.2004
[SB]
- Neuer Variablentyp PL_VAR_PLSTRING zum Zugriff auf Variablen vom Typ PLTString eingebaut
- PL_ENUM Makros verändert: Der enum-string steht nun doch am Ende des Makros, da dies die Variablendefinition übersichtlicher gestaltet



>> 08.08.2004
[SB]
- PLTClass: Der Methode CreateInstance kann nun angegeben werden, ob die Variablen des erzeugten Objektes automatisch auf
  ihre Default-Werte gesetzt werden wollen, dies ist nun auch das Standardverhalten von CreateInstance().
- PLTBase: Neue virtuelle Methode VarChanged() eingebaut, diese wird aufgerufen wenn der Wert einer Variablen durch das
  RTTI verändert worden ist, um ggf. nötige Aktionen nach dem Verändern einer Variable durchzuführen



>> 07.08.2004
[SB]
- PLTBase, PLTClass: GetVarList(List, true) gibt nur die Variablen der eigenen Klasse zurück, ohne die von Basisklassen
  vererbten
- PLTVar::GetClass() gibt zurück, in welcher Klasse die Variable deklariert wurde
- Mittels DEFINE_ENUM können Aufzählungs-Variablen registriert werden. Als Typ kann hier entweder PL_VAR_ENUM oder
  PL_VAR_FLAGS angegeben werden. Das Setzen der Variablen kann entweder über die numerischen Werte oder über die
  enum-Namen erfolgen: z.B. Set("2|4"); Set("beta"); Set("Read|Write");



>> 06.08.2004
[SB]
- PLTypes.h erweitert, so daß die Definitionen an anderer Stelle komplett entfallen können. Die verwendeten Datentypen
  sollten jedoch noch einmal komplett überarbeitet werden
- Log-Ausgaben wieder eingebaut, dazu wird nun das "shared"-Log verwendet. Zur Zeit wird dieses jedoch nirgendwie aktiviert,
  deshalb verschwinden die Logausgaben im Nirvana :-)
- RTTI System erweitert:
  - Klassen beinhalten nun auch die Variablen ihrer Basisklassen
  - Es wird nun mit m_nBaseOfs auch der Offset zu PLTBase gespeichert, damit die Variablen auch dann noch korrekt gesetzt
    werden können, wenn eine Klasse nicht als erstes PLTBase in der Ableitungsliste stehen hat
  - DEFINE_VAR_READONLY erlaubt das Definieren von Variablen, die nur gelesen aber nicht verändert werden können
  - REDEFINE_VAR erlaubt das "Überschreiben" von Variablen in abgeleiteten Klassen, dabei können DefaultValue,
    Description und Annotation verändert werden



>> 05.08.2004
[CO]
- Den Ordner Tools in PLTools umbenannt. Beim Includieren wäre es am ende unschön wenn man #include <Tools/...> schreiben
  würde, da vermiss ich irgendwie das PL davor... und so musste ich die anderen Codes nicht an die verschiebung von PLTools
  in PLGeneral anpassen. ;-)
  Vielleicht sollten wir auch die anderen Ordner entsprechend anpassen damit es einheitlich ist. 
  (wieder so ne dumme Namensgeschichte ;-)
- Bei ein paar Headern in PLTools noch PLGeneral.h eingebunden - bei der Gelegenheit ging ich gleich alle Includes unserer
  Projekte durch und passte alles an. (waren ja in letzter Zeit einige Änderungen)
  Nun sieht man z.B. schön wie die Libs aufeinander aufbauen da alles geordnet ist.
- PLTimerWin32.inl & PLTimer.inl gelöscht da die inlines dort nicht so doll sind (was dachte ich mir früher dabei? :-)
- PLTypes.h von der Engine in PLGeneral verschoben, musste PLTypes in z.B. PLList.h einbinden da in der Engine teils
  NULL unbekannt war da windows.h dort nicht eingebunden werden musste



>> 04.08.2004
[SB]
- PLTDestructionManager eingebaut. Diese Klassen sorgen dafür, daß Instanzen von Singleton- oder Shared-Klassen am
  Ende der Programmausführung auch wieder gelöscht werden. Die Implementierung ist relativ kompliziert, da man
  hierbei wieder sehr mit der Compiler- und Exportproblematik herumschlagen mußte. Die Funktionsweise des Systems:
  - Statische Initialisierung wird durch Singleton::GetInstance() vermieden, dies ist nötig damit die Klassen sich
    über Selbstinitialisierung beim Programmstart bei PLTSystem anmelden können. Wäre PLTSystem eine statische
    Variable, könnte dies zu Problemen führen, wenn PLTSystem noch nicht initialisiert wurde
  - Jede Instanz von PLTSingleton und PLTShared meldet sich beim PLTDestructionManager an. Dies ist möglich, da
    PLTDestructionManager selbst ein Singleton ist und daher bei der ersten Verwendung erzeugt wird
  - Am Ende müssen alle Instanzen wieder gelöscht werden. Dazu dient die einzige statisch Variable
    PLTDestructionGuard::Instance, deren Destructor am Ende des Programmes automatisch aufgerufen wird. Diese löscht
    die Instanz von PLTDestructionManager, welche wiederum alle bei ihr angemeldeten Objekte löscht. Auf diese
    Weise werden alle erzeugten Instanzen auch wieder automatisch gelöscht :-)



>> 03.08.2004
[SB]
- Neues Verzeichnis PLTools, hier befinden sich nun allgemeine Tool-Klassen
- PLTTokenizer nach Tools verschoben
- Klassen aus PLEngine nach PLGeneral verschoben, welche allgemein verwendet werden können. Die Klassen sind nun
  allgemein und können auch außerhalb der Engine verwendet werden, PLEngine-spezifischer Code wurde dabei entfernt
  und muß weitern in der Engine selbst ausgeführt werden (z.B. Anzeige von Informationen etc).
  Verschobene Klassen: PLTLog, PLTProfiling, PLTTimer, PLTTools



>> 02.08.2004
[SB]
- PLTRefCount nach Base verschoben und von PLTBase abgeleitet
- PLTFile: Neue Methode PrintLn eingebaut
- PLTFile: Neue Methode Flush eingebaut
- PLTWin32File und PLTZipFile angepaßt



>> 01.08.2004
[CO]
- PLTDynamicList: In der Engine hab es nun mit den const/nicht const etwas probleme. Hab die Warnung
  "PLTDynamicList<AType>' : multiple assignment operators specified" fürs erste Deaktiviert da diese ansonnsten tausende male
  kam. ;-)
  Bei Zeiten müssten wir nochmal schaun wie wir das besser machen können...
- PLTPool: Um Copy Operator erweitert



>> 01.08.2004
[SB]
- Neue Basisklassen PLTShared und PLTSingleton eingebaut. Dies sind Template-Klassen, welche verwendet werden können,
  um Klassen mit nur einer Instanz (PLTSingleton) oder mit einer gemeinsamen Instanz für alle Programmteile (PLTShared)
  zu definieren.
- PLTFileSystem benutzt nun die neuen Basisklassen PLTSingleton und PLTRefCount
- PLTSystem: Anpassung an neue Basisklassen sowie kleinere Korrekturen
- Neue Definition PLGENERAL_TEMPLATE zum Exportieren von template-Klassen, dies muß bei allen zu exportierenden
  Template-Instanzen verwendet werden
- Verzeichnisse umbenannt



>> 30.07.2004
[SB]
- Habe das RTTI System in PLGeneral eingebaut und dafür die vorläufigen Plugin-Klassen wieder entfernt, da diese
  damit überflüssig geworden sind :-)



>> 29.07.2004
[SB]
- Die Gruppe einer Klasse wird nun mittels eines eigenen Makros gesetzt, wird dieses nicht verwendet gehört die Klasse
  keiner Gruppe an
- Die Basisklassen einer Klasse werden nun in PLTClass gespeichert und können dort abgefragt werden. Ebenso kann
  PLTBase::IsInstanceOf() als Shortcut zur Abfrage einer Basisklasse verwendet werden
- PLTBase selbst wird jetzt als Klasse registriert
- Beim Definieren einer Klasse wird nun eine interne von PLTClass abgeleitete Klasse erzeugt, welche dann in PLTSystem
  gespeichert wird. Dadurch ist es möglich, private Methoden von PLTClass zu verwenden sowie virtuelle Methoden
  zu überschreiben
- PLTClass::CreateInstance() kann benutzt werden, um eine neue Instanz einer Klasse zu erzeugen. Es muß allerdings noch
  ein Weg gefunden werden, daß Klassen dieses Verhalten unterbinden können, wenn eine direkte Erzeugung von Instanzen
  nicht erwünscht ist
- PLTClass: Methoden zum Ändern einer Klasse sind nun protected, können von Außen also nicht mehr aufgerufen werden,
  damit sind auch die konstanten Zeiger nicht mehr von Nöten und wurden durch normale Zeiger (PLTClass*) ersetzt
- Pointer-Truncation Warnungen wurden beseitigt, indem zur Speicherung des Offsets nun der 64Bit-Datentyp int__64
  verwendet wird
- Neues Makro: Wird DEFINE_CLASS_PRIVATE anstelle von DEFINE_CLASS verwendet, so kann die Klasse nicht über
  CreateInstance() instanziiert werden. Dies ist nützlich für Klassen, die nicht beliebig instanziiert werden
  sollen und daher meits auch keinen öffentlichen Standardkonstruktor besitzen
- Mittels der Compiler-Definition USE_SELFINIT kann bestimmt werden, ob die Selbstinitialisierung verwendet werden soll
- In PLTClass wird nun ein Module-Handle gespeichert, zu dem die Klasse gehört



>> 28.07.2004
[SB]
- Zugriff auf Variablen vollständig implementiert und getestet
- Klassen können nun in Gruppen eingeteilt werden, um einfach die Klassen eines bestimmten Typs auflisten zu können. Dies
  dient nur dem Entwickler zur Einfacheren Verwaltung seiner Klassen, z.B. sollten alle Plugins eines Typs den gleichen
  Gruppennamen bekommen (z.B. PLEntities), dann kann der Plugin-Manager sich eine Liste aller Klassen dieses Typs herausgeben
  lassen um die Plugins dann zu verwenden
- PLTVar wurde doch noch einmal umgeschrieben, es ist nun nicht mehr möglich, mit hilfe eines PLTVar-Objekts direkt auf
  eine Instanz einer Variablen zu zeigen, da dies zu Inkonsistenzen führte (PLTClass::GetVar() gab einen konstanten Zeiger
  auf PLTVar zurück, der nicht gelöscht werden durfte, währen PLTBase::GetVar() ein neues PLTVar Objekt erzeugte, welches
  dann wieder gelöscht werden mußte!). Die jetzt zurückgegebenen Objekte müssen grundsätzlich nicht mehr gelöscht werden,
  da sie Zeiger auf feste Instanzen darstellen und nicht neu erzeugt werden. Dafür gibt es nun Methoden in PLTVar,
  um den Wert der Variablen bezogen auf eine Instanz zu setzen: SetVar(PLTObject*, const char *pszValue)
- RTTI Interface ist nun komplett



>> 27.07.2004
[SB]
- Neue Funktionen in PLTBase: ToString() und FromString(). Mit diesen Methoden wird der Inhalt eines
  Objektes in einem String übergeben. Dies entspricht in wesentlichen dem VarString, jedoch kann das
  Aussehen dieses Strings von der Klasse bestimmt werden, es müssen also nicht die Variablennamen
  angegeben werden (die Repräsentation eines 3D-Vectors könnte z.B. "10 20 30" sein, anstatt "X=10 Y=20 Z=30")
- Mittels PLTVar können nun Werte von Variablen gesetzt und abgefragt werden
- Klassen werden in PLTClassRegistry gespeichert und können dort abgefragt werden
- PLTClassRegistry wurde in PLTSystem umbenannt, da diese Klasse die allgemeine Verwaltung des Systems übernehmen
  wird (neben Registrierung der Klassen werden auch Plugins, Dynamic Libraries etc. in ihren Aufgabenbereich fallen,
  evtl. kann man später auf Log etc. in PLTSystem einbetten)
- Die Klassen wurden überarbeitet und vereinheitlicht, z.B. wurden Unterschiede beim Zugriff auf Listen und Daten
  der Klassen beseitigt
- SelfInit-Part eingebaut, welcher die Klasse automatisch registriert
 


>> 25.07.2004
[SB]
- PLTVar überarbeitet, die Instanz des Objektes kann nun nur noch im Konstruktor übergeben werden
- Zugriff auf Variablen über PLTClass implementiert



>> 24.07.2004
[SB]
- PLTVar fertiggestellt, diese Klasse beinhaltet Informationen über eine Variable innerhalb einer Klasse. In PLTClass
  kann man eine Liste der registrierten Variablen abfragen, und in PLTObject können die Werte der Variablen gesetzt
  oder abgefragt werden. Zusätzlich kann auch PLTVar die Instance einer Variablen darstellen, dann kann auch über
  PLTVar auf die Werte der Variablen zugegriffen werden



>> 22.07.2004
[SB]
- Habe endlich einen generellen Weg gefunden, daß die Variablen einer Klasse nicht mehr pro Objekt gespeichert werden
  müssen sondern nur noch einmal für jede Klasse. Bisher besaß jede Instanz einer Klasse eine eigene Variablenliste,
  in der die Zeiger auf die Variablen gespeichert wurden (die Informationen über die Variablen wurden nur einmal
  gespeichert, dies führte jedoch dazu, daß es zwei unterschiedliche Klassen für Variablen geben mußte, was auch
  nicht schön war). Dies ist nun nicht mehr nötig :-)



>> 21.07.2004
[SB]
- PLGeneral: PLTDynamicList und PLTList so erweitert, daß diese nun auch mit konstanten Daten umgehen können.
  Dies ist z.B. dann nützlich, wenn der Zugriff auf eine const PLTList/PLTDynamicList erfolgt
- RTTI System begonnen. Mit Hilfe dieses Systems wird es möglich sein, zur Laufzeit auf Klasseninformationen zuzugreifen,
  damit können z.B. die vorhanden Variablen oder Methoden eines Objektes abgefragt und verändert werden, sowie
  natürlich generelle Informationen über den Typ eines Objektes abgefragt werden.
  Das System entspricht in seiner Funktionsweise dem EntityPluginSystem, ist jedoch allgemeiner und soll um einiges
  flexibler werden. Wenn alles klappt, wird durch dieses Klassensystem auch gleich ein sehr einfach zu verwendendes
  Pluginsystem zur Verfügung stehen, wobei die bisherigen Fallunterscheidungen nicht mehr benötigt werden sollten
  (bisher mußte unterschieden werden, ob eine Klasse im Hauptprojekt, in der Engine-DLL oder in einer Plugin-DLL
  deklariert wurde, dies ist nicht sehr schön und kann hoffentlich vermieden werden). Auch das Scriptsystem wird
  nach der Implementierung der RTTI leicht zu entwickeln sein, da der Zugriff auf Klassen und Variablen/Methoden
  zur Laufzeit damit bereits implementiert ist :-)
  Das RTTI wird also eine Reihe von Basisklassen zur Verfügung stellen, die in der gesamten Engine verwendet werden,
  zusätzlich wird es noch einige abgeleitete Klassen geben, welche für bestimmte Klassentypen zum Einsatz kommen
  können (RefCount, Singleton, etc)



>> 30.06.2004
[SB]
PLFileSystem:
- Fehler in PLTSearchMultiHandle behoben: HasNextFile() gab false zurück, sobald der erste SearchHandle komplett durchlaufen
  war, dadurch wurden die anderen SearchHandles ignoriert
- Das Interface von PLTFileSystem wurde noch einmal leicht verändert. GetRootDirectory() gibt nun das System-Root-Verzeichnis
  zurück, dieses kann jedoch nicht selbst gesetzt werden. SetCurrentDirectory()/GetCurrentDirectory() ermöglichen das Setzen
  eines aktuellen Verzeichnisses, sowie AddBaseDir() etc., welche im Prinzip weitere aktuelle Verzeichnisse hinzufügen lassen
  (falls mehrere benötigt werden). Hierdurch bleibt das System kompatibel zu den üblichen Dateisysteme, erlaubt jedoch zusätzlich
  mehr Kontrolle
- Zugriff auf Suchpfade und Rootverzeichnisse ist vollständig, es funktioniert nun also alles was für die Engine benötigt
  wird. Es können Dateitypen (z.B. "Textures", "Sounds", etc.) festgelegt werden und Suchpfade dafür angelegt werden.
  Das FS durchsucht dann beim Öffnen einer Datei automatisch diese Pfade, so daß sich die Anwendung nicht mehr darum
  kümmern muß, was wo liegt
- Suchpfade/Rootverzeichnisse ausgetestet und den PL-Realfall simuliert (separate Verzeichnisse für Textures/Models/etc)



>> 29.06.2004
[SB]
PLFileSystem:
- Geschwindigkeitstests durchgeführt. Leider ist das FS vor allem beim Zugriff auf viele kleine Dateien deutlich langsamer
  als die Standardfunktionen, beim Zugriff auf große Dateien fällt der Unterschied allerdings kaum mehr ins Gewicht.
  Dies dürfte hauptsächlich an den vielen String-Operationen liegen, wie müssen also einfach austesten, ob dies im reellen
  Gebrauch negativ auffällt und ggf. versuchen, diese Funktionen zu optimieren
- Neue Funktion PLTSearchHandle::GetNextFileAbs(), diese Funktion liefert den absoluten Pfad zurück. Funktion wurde in
  allen abgeleiteten Klassen implementiert
- Neue Funktion PLTZipDirectory::GetZipFile(), liefert ein Handle auf die Zip-Datei zurück, die das Verzeichnis beinhaltet.
  Der Rückgabewert ist const, damit zwar Dateiattribute (Namen etc.) abgefragt werden können, die Datei aber nicht
  verändert werden kann
- Fehler in PLTZipSearchHandle behoben: Das zugrunde liegende Verzeichnis wurde nicht gesichert (refcount)



>> 28.06.2004
[SB]
PLFileSystem:
- Dateien aus Zip komplett überarbeitet und an den PL-Style angepaßt
- Alle Dateien überarbeitet und die üblichen "Verschönerungen" vorgenommen :-)



>> 25.06.2004
[SB]
PLFileSystem:
- Beim Suchen mit Filter entspricht der Filter "" nun der Suche nach allen Dateien
- Beim Suchen mit Filter ist es nun auch möglich, noch Unterverzeichnisse mit anzugeben (z.B. Suche nach "subdir/*.txt")
- Mounten von Root-Verzeichnissen implementiert
- Dateitypen und Suchpfade wurden implementiert
- PLTSearchMultiHandle eingebaut: Dies ist ein Search-Handle, welches intern wiederum aus mehreren Search-Handles besteht
  und diese nacheinander abarbeitet
- PLTFileSystem interface wurde komplett implementiert
- Dateien aus Base und Win32 überarbeitet und komplett kommentiert



>> 23.06.2004
[SB]
PLFileSystem:
- PLEFileType und entsprechende Zugriffsmethoden in PLTFileObject wurden entfernt, IsDirectory() und IsFile() werden
  nun von abgeleiteten Klassen implementiert
- Neue Methoden GetName() und GetAbsName() in der Basisklasse PLTFileObject eingebaut, diese dienen dem Abfragen von
  relativen und absoluten Namen aller Dateiobjekte
- Interface von PLTFileObject wurde überarbeitet (const-Methoden)
- GetName() und GetAbsName() in allen abgeleiteten Klassen implementiert und getestet, es kann nun immer der relative
  sowie der absolute Pfad angefragt werden
- PLTSearchFilter implementiert, dieser filtert Suchergebnisse nach Wildcards
- Beim Erzeugen des Dateisystems wird das aktuelle Verzeichnis '/' automatisch als system-root gemountet
- Setzen des aktuellen Verzeichnisses implementiert
- Design von PLTFileSystem wurde festgelegt. Diese Klasse stellt das Hauptinterface zum FS dar, dient also dem Benutzer
  zum Öffnen von Dateien und Verzeichnissen sowie zum Suchen von Dateien



>> 22.06.2004
[SB]
PLFileSystem:
- FSTools: Neue Funktion IsAbsolutePath() eingebaut
- PLTWin32Directory: Es können nun auch absolute Pfade angegeben werden (z.B. D:\test.txt), welche unabhängig vom aktuellen
  Verzeichnis gefunden werden. Außerdem kleine Anpassungen an IsValid() vorgenommen



>> 20.06.2004
[SB]
PLGeneral:
- Neue Basisklasse PLTRefCount in PLGeneral eingebaut, da dies nun bereits in mehreren Klassen verwendet wird.
  Davon abgeleitet gibt es speziell für das FS die Klasse PLTFSRefCount, welche zusätzlich die Anmeldung erzeugter Objekte
  beim FileSystem übernimmt



>> 19.06.2004
[SB]
PLFileSystem:
- Fehler behoben: Das MountParent-Attribut eines Verzeichnisses wird nun weitergegeben, wenn ein Unterverzeichnis geöffnet
  wird. Dadurch bezeichnet MountParent jedoch nicht mehr unbedingt das direkte Superdirectory, wenn es gesetzt ist, sondern
  das Basisverzeichnis des gesamten Unterbaumes. Dies wurde ebenfalls in PLTZipFile implementiert
- Die einzelnen Implementierungen von PLTDirectory::Open() rufen nun intern OpenCanonical auf, wenn sie die Datei auf
  direktem Wege nicht öffnen können
- PLTWin32Directory und PLTZipDirectory: Enthält der zu öffnende Dateiname ein / (bzw. \) am Ende, so wird nur ein
  PLTDirectory* zurückgegeben. Wird nur eine Datei gefunden, beendet die Funktion mit einem Fehler und gibt NULL zurück
- PLTFileSystem: Mount ist nun protected, darf also nur vom FileSystem selbst (und PLTDirectory) aufgerufen werden
- Weitere kleine Fehler in Mount() und PLTWin32Directory/PLTZipDirectory behoben. Der Zugriff auf Dateien und Verzeichnisse
  scheint nun komplett zu funktionieren
- ReferenceCounting und garbage collection wurden nun auch in PLTSearchHandle implementiert, damit dies einheitlich für das
  gesamte FS ist
- Kleinere Fehler im ReferenceCounting und beim ObjectManagement behoben, dies scheint nun fehlerfrei zu funktionieren
  (nicht mehr benötigte Objekte werden selbständig gelöscht)
- Umstrukturierung der Open/OpenCanonical Funktionen. Dadurch konnten redundante Überprüfungen entfernt werden (Öffnen von
  Verzeichnissen oder Dateien), und eine endlose Rekursion zwischen den Funktionen Open und OpenCanonical ausgeschlossen werden
- PLTDirectory::FindFirst() gibt nun einen SearchHandle zurück, der immer alle Dateien im Verzeichnis auflistet. Daher muß
  PLTSearchHandle also keine Suchmaske mehr implementieren, dies wird später durch eine ContainerKlasse implementiert
- Hilfsfunktion FindFirst(pszFilter) und neue Klasse PLTSearchFilter erstellt, worüber das Suchen von Dateien mit einem
  Filter möglich ist. PLTSearchFilter ist jedoch noch nicht implementiert
- Die Grundfunktionen des FS sind nun *endlich* komplett implementiert, d.h. es kann auf alle Dateien und Verzeichnisse
  zugegriffen werden, wobei ZIP-Dateien bei Bedarf automatisch gemountet werden. Auch der Zugriff auf Dateien und
  Verzeichnisse über Dateisystemgrenzen hinweg ist möglich. Es fehlt nun noch das Mounten von root-Verzeichnissen
  sowie die Verwaltung von Dateitypen und Suchpfaden



>> 18.06.2004
[SB]
PLFileSystem:
- Beim Öffnen des Verzeichnisses '..' wird nun immer das korrekte Verzeichnis zurückgegeben, auch wenn dazu auf ein früher
  gemountetes Verzeichnis zurückgegriffen werden muß
- OpenCanonical wurde implementiert. Diese Funktion öffnet einen Pfad Schritt für Schritt, wobei wenn nötig auch Dateisystem
  gemountet werden (z.B. ZIP-Dateien)
- On-The-Fly-Mounten implementiert (z.B. beim Öffnen von "C:\test.zip\test.txt")



>> 16.06.2004
[SB]
PLFileSystem:
- PLTZipDirectory wurde so erweitert, daß nun auf ein bestimmtes Verzeichnis im ZIP-File zugegriffen werden kann.
  Mittels Open() können jetzt auch Unterverzeichnisse geöffnet werden
- Fehler in PLTZipFile behoben: Das PLTZipFile erhöht nun den Reference-Counter seines Zip-Verzeichnisses, damit
  dieses nicht gelöscht werden kann, solange das PLTZipFile existiert
- Zip-Implementierung wurde komplett implementiert. Der Code basiert auf unzip.c, wurde jedoch objektorientiert umgesetzt



>> 14.06.2004
[SB]
PLFileSystem:
- IsValid() wurde als Basisfunktion in PLTFileObject fertiggestellt
- PLTFSTools::ValidatePath() wurde implementiert. Diese Funktion validiert einen Verzeichnisnamen, indem z.B. '..'
  und '.' soweit möglich entfernt werden, / und \ vereinheitlicht werden und sonstige Fehler möglichst korrigiert werden



>> 11.06.2004
[SB]
PLFileSystem:
- Das Interface von PLTFileSystem wurde noch einmal komplett überarbeitet
- Dateisysteme können nun gemountet werden, wobei der Typ des Dateisystems automatisch festgestellt wird
  (z.B. zum Mounten von ZIP-Dateien). Damit der Kontext erhalten bleibt, kann ein Basisdirectory übergeben werden,
  welches die zu mountende Datei enthält



>> 05.06.2004
[SB]
PLFileSystem:
- Win32-Implementierung wurde komplett fertiggestellt



>> 04.06.2004
[SB]
PLFileSystem:
- Die Interfaces wurden noch einmal komplett umgestellt und vereinheitlicht
- Das Erzeugen und Löschen von Instanzen ist nun nur noch über spezielle Methoden und Klassen möglich
- Reference-Counting für PLTFileObject (und abgeleitete Klassen) implementiert
- Alle erzeugten PLTFileObject-Instanzen werden nun beim PLTFileSystem gespeichert und spätestens dann gelöscht,
  wenn auch das PLTFileSystem selbst gelöscht wird
- Auch PLTFileSystem selbst besitzt nun einen Reference counter



>> 26.05.2004
[SB]
PLFileSystem:
- Die erste Version vom PLFileSystem wurde fertiggestellt



>> 11.05.2004
[CO]
- PLGeneral: PLError wurde entfernt. Gelöschte Dateien: PLBuffer.h, PLError.cpp, PLError.h. Nahm desweiteren PL_ASSERT
  aus diversen Codes heraus da WENN da müsste man dies konsequent in ALLEN Codes machen. :)



>> 30.03.04
[SB]
- Plugin-Basisklassen in PLGeneral eingebaut. Diese ist noch nicht ganz fertig, funktioniert
  aber schon ganz gut. Es fehlen noch einige Optimierungen sowie die Verknüpfung mit dem
  FileSystem, damit die Plugins leicht gefunden werden können. Auch müßten die Klassen noch
  auf Linux Systeme angepaßt werden. Wenn dies fertig ist kann ein PluginManager in der Engine
  erzeugt werden, der alle Arten von Plugins einlädt und zur für Verfügung stellt, die
  einzelnen Programmteile benutzen dann den Manager um ihre Plugins zu erzeugen



>> 25.03.04
[CO]
- Wie ich sehe hat Michael nochmals PLTBuffer verbessert... ich selbst hatte gestern in PLBuffer in PLArray
  umbenannt und mehr oder weniger komplett umgeschrieben da ich diese Klasse mittlerweile im neuen Renderer beim
  Wrappen von Render States etc verwende und die alte Klasse nicht stabil genug war. Hatte die Codes aber noch
  nicht hochgeladen - PLArray.h ist nun auf dem Server, PLBuffer.h lass ich auch erstmal noch oben nicht das da
  etwas durcheinander kommt. :)



>> 23.02.04
[CO]
- PLTStack leicht modifiziert



>> 19.02.04
[CO]
- PLTString um Funktionen zum setzen und auslesen von Zahlen hinzugefügt.



>> 15.02.04
[CO]
- Plugin Systeme wie Entity und Sound: Dadurch das nun während der Entwicklung zwei Versionen eines jeden Plugins vorhanden
  sind (Debug und Release) gab es teils crashs da dann doppelt noch das andere z.B: Release Plugin eingeladen wurde was
  aufgrund inkompatiblem Compiler Modus einen crash verursachte. Diese Plugins haben nun intern einen vermerk ob diese im
  Release oder Debug Modus sind - Plugins in einem falschen Compiler Modus werden nun nicht mehr geladen. Nun müsste das mit
  dem Release/Debug Problemen entgültig der Vergangenheit angehören! Wenn nun was nicht geht dann liegts nur an nichtzusammen
  passenden Release Versionen. (da z.b. eine dll veraltet ist :)
- PLTList und PLTDynamicList -> Add Funktion so erweitert das optional ein Index mitgegeben werden kann um 
  festzulegen WO in der Liste das neue Element eingefügt wird



>> 11.02.04
[CO]
- PLTLanguageManager::GenerateLanguageList() -> Kann nun auch aus einer Preload Datei im Languages Block die verfügbaren
  sprachen auslesen falls mal ALLE Daten in einer pak Datei sind und daher die Sprachverzeichnisse nicht direkt abgelesen
  werden können.
- PLTList + PLTDynamicList: -> Da man beim Kopieren oft Start+Anzahl trifft (siehe read etc) haben wir nun beide
  Kopier Funktionen drin, also Start+Anzahl und Start-End. (heist CopyFromTo())
  Da die Listen sehr häufig Verwendung finden müsste es ok sein wenn man da etwas mehr komfort bietet.
  Die Kopier Funktionen müssten so nun wirklich passen. (getestet)



>> 07.02.04
[CO]
- Ein paar kleinigkeiten am alten FS geändert so das man nun im HDRI Viewer auch direkt pak/zip files einladen kann



>> 05.02.04
[CO]
- PLTTimer: Delay() in Sleep() umbenannt damit es identisch mit dem PLGui Sleep() ist. Ist zwar nun im GuiNative und Timer
  doppelt, aber so hat man alles Timer Relevante in der Engine sauber in einer Klasse beisammen. :)



>> 04.02.04
[CO]
- PLTDynamicList: Copy() kopierte durch <= ein Element mehr als man angab
- PLTList: Neue Funktion. Copy
- PLTBitset: Neue Funktionen: GetSize() -> Liefert die Bitset größe zurück
                              Copy() -> Copiert Bits in ein anderes Bitset



>> 01.02.04
[CO]
- PLTTokenizer: GetDataBlock() Funktionen erweitert. Es gibt nun neben der Block Schreibweise [X Y Z ...] auch alternativ
  {X, Y, Z ...} da man beide Schreibweisen häufig antrifft. wird z.B. im überarbeiteten Material Format bei den Parametern
  verwendet um dort ein fx-ähnliches Aussehen beizubehalten damit die Grafiker nicht zu 100% umdenken müssen und es leicht
  ist ein fx File in unser eignes Material Format umzuschreiben.



>> 29.01.04
[CO]
- PLTList: neuer operator: Concat. Zur Verkettung zweier Listen.
  Desweiteren wurden in einem Kunstruktor noch nicht die Variablen Initialisiert. (siehe MH oben)



>> 22.01.04
[CO]
- PLTOutputDevice in PLTErrorOutputDevice und PLTError in PLError (da gleich statische instanz) umbenannt.
- Erweiterte PLGeneral Headers um jeweils ein kleines Beispiel wie man die verschiedenen Klassen einsetzt



>> 21.01.04
[CO]
- Nahm aus PLList, PLHashTable und PLStack wieder die Assertion Funktionen heraus da man durch diese selbst bei
  einfachen Templates GEZWUNGEN wurde PLGeneral ins Projekt mit einzubinden auch wenn man eigentlich 'nur' Templates
  aus PLGeneral verwendete. PLMath ist somit wie PLGeneral komplett eigenständig - verwendet zwar z.B. Listen aus PLGeneral
  aber dies erfordert keine Einbindung von PLGeneral in das PLMath Projekt.
  In Klassen welche sowieso die Einbingung von PLGeneral erfordern kann man ja sorgenlos die Assert Funktionen verwenden. :)
- Einige von Michals änderungen an String und Error wieder angepasst - ich hoffe da kam nun nichts durcheinander da unsere
  Codes diesmal stark voneinander abwichen - Michael, passe bitte auf das du nicht auf dem Server
  bereits geänderte Dateien überschreibst. (wie dieses Tagebuch oder Codes)
  Am besten bevor du etwas hochläds zur Sicherheit prüfen ob jemand was dran geändert hat. Am FileSystem ändern wir erstmal
  nichts bis du nicht das ok gibst - sonst kommt das durcheinander. :)
  Sobald wir auf CVS umstellen wird das sicherlich besser da diese Programm dann heftig warnt wenn man Datein die man
  hochladen will auf dem Server geändert wurden.
  Ps. Es ist wirklich, wirklich wichtig das die Codes so sauber sind wie möglich und möglichst kein Buchstabe vom Style
  abweicht. Wir haben mittlerweile insgesammt weit mehr als 2 MB an Quellcodes und wenn man da anfängt mit soetwas nachlässig
  zu werden wird man sich ganz bestimmt später mal drüber ärgern. Von daher kommts schonmal vor das wir mehr Zeit in die Code
  pflege stecken als in das schreiben des Codes selbst... aber es lohnt sich da man sich dadurch später Zeit spart!



>> 20.01.04
[CO]
- PLTTokenizer::GetDataBlockInt() und PLTTokenizer::GetDataBlockFloat() -> Brechen nun ab wenn beendende Klammer ]
  gefunden wurde und füllen den Rest mit 0. Geben die Anzahl der gelesenen Elemente zurück.
  (PLModelLoad.cpp und PLTextureHandler.cpp mussten aktualisiert werden)



>> 12.01.04
[CO]
- PLTFile::GetS() -> Fehler korrigiert (sonst gibts probleme beim HDRI maps im Viewer einladen)



>> 09.01.04
[CO]
- PLGeneral.h muss nun nicht mehr inkludiert werden bevor man z.B. PLTBitset verwenden will
  (dies geschieht nun in den PLGeneral Headern automatisch)



>> 03.01.04
[CO]
- PLTDynamicList: Neue Funktion: Add() -> Fügt ein neues Element in die Liste ein und gibt einen Zeiger darauf zurück
- PLTBitset erweitert -> Prüft nun auch ob ein gegebener Bit Index korrekt ist
- PLTTokenizer: Neue Funktionen: GetNextTokenBool() und GetTokenBool() -> Machen das gleiche wie die Funktionen ohne Bool
  am Ende außer das diese den gefundenen Token als boolean Wert zurückgeben (erkennt auch 'false' und 'true')
- Überall in Formaten wo man statt einer 1 auch 'true' schreiben könnte ist dies nun dank umstellung auf GetNextTokenBool()
  auch möglich



>> 30.12.03
[CO]
- PLTString: Michales neue Änderungen wieder angepasst (bitte noch mehr drauf achten wie wir was schreiben Michael :)



>> 27.12.03
[CO]
- Passte noch ein paar kleinigkeiten von Michaels änderungen an PLTString an. Find() gibt nun direkt den Index zurück.



>> 20.12.03
[CO]
- PLTFileSystem::GetFilenameEnding() -> Wenn Datei keine Datei endung hat so wird pszFilenameEnding nun auf "" gesetzt



>> 13.12.03
[CO]
- PLTTimer: Neue Funktion: GetTickCountLow() -> Macht das gleiche wie GetTickCount() nur mit weniger genauigkeit
- PLTDataSet.Get() -> Gibt nun NULL zurück wenn ungültiger Index -> ein paar stellen in der Engine an denen Zeiger
  verglichen werden mussten angepasst werden



>> 27.11.03
[CO]
- PLString: Neue Funktion: - TStringModule::GetUsage() -> Gibt zurück wie oft ein String Module verwendet wird
  Neue Operatoren: += -> Hängt einen String an einen String an +  -> Verbindet zwei Strings zu einem neuen



>> 25.11.03
[CO]
- Mir war ein paar Minuten langweilig und da warf ich nochmal einen kurzen Blick auf PLGeneral und behob
  ein paar kleine Schönheits fehler - also absolut unnötige Änderungen. (sieht nun aber etwas universeller aus ;-)



/*********************************************************\
 *  Einträge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> älter)
\*********************************************************/



[SB] Neues Projekt PLGeneral erstellt, welches alle allgemeinen Toolklassen enthält (Listen, Strings, ...). Die
     entsprechenden Toolklassen wurden aus PLEngine entfernt, alle Projekte wuredn umgestellt (betrifft nahezu alle
     Projekte)
[CO] In PLTypes.h stehen nun auch Daten-Typ definationen wie z.B. WORD oder DWORD
[CO] PLTTimer: Portabel gemacht -> System abhängige Funktionen abgekapselt
[CO] PLTFileSystem::GetValidFilename() -> Prüft ZUERST ob eine Datei in einem Sprach Unterornder ist und somit für eine
     Sprache quasi 'überladen' wird (wichtig für Lokalisierungen :)
[CO] PLTFileSystem: Neue Funktionen: ConvertBackslashsToSlashs() und ConvertSlashsToBackslashs()
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] PLTModule::IsHandler() war mittlerweile veraltet und musste daher aktualisiert werden
[CO] PLTList & PLTDynamicList um ein paar hilfreiche weitere Funktionen erweitert - auch in PLGui2
[CO] PLTLog: GetSystemMetrics herausgenommen, somit ist diese Klasse Windows unabhängig :)
[CO] PLTLanguageHandler: Strings werden nun anstatt mit Get() mit [] angefordert, etwas kürzere und angenehmere
     Schreibweise :) CustomUpdate-Funktionen entfernt da wechseln der Sprache während das Programm läuft nicht mehr
     möglich ist. *nur probleme mach* -> API Doku um Language System erweitert
[CO] Ordnungs-Wahn: Alle Dateien nochmal durchgegangen um sicherzustellen das alle das gleiche Layout haben... also die
     Beschreibung der Dateien, #idndef usw.   Den Code durchgegangen um sicherzustellen das immer zuerst Get und danach
     erst Set funktionen kommen. (damit alles einem einheitlichen Schema folgt ;-)
[CO] File System um Ordner für 2D Guis erweitert, der Gui2D Loaded setzt nun wie alle anderen Loader den Dateinamen
     selbstständig dynamisch zusammen
[CO] PLTPluginManager: Alle Entity Plugins befinden sich in einem Module (internal, dll, entities) dessen name nun im
     Plugin selbst gespeichert wird. Mit GetModulePluginList() kann man eine Liste aller Plugins in einem Module
     anfordern. GetNumberOfModules() und GetModuleName() um Module Namen zu erhalten.
[CO] PLTTimer: Neue Funktion: Delay() -> Hält die ausführung des Programms für eine gewisse zeit an
[CO] PLTDataSet: Neue Funktionen: GetTotalSize() of den gesammten speicherbedarf in Bytes abzufragen GetElementSize() ->
     Liefert die größe eines grund Elements in Bytes zurück GetAllocated() -> Liefert die Anzahl der belegten grund
     Elements zurück. Desweiteren oben eine kurze Beschreibung des Data-Sets hinzugefügt.
[CO] PLTModuleManager: Behob einen (mehr oder weniger) kleinen fehler beim Laden von Modulen... bei SetName() wird das
     Module in den Module Handler eingetragen, kann das Module nicht geladen werden so wird es nun wieder korrekt vom
     Manager entfernt (ansonnsten crash beim Laden von nicht vorhandenen Resourcen :)
[CO] PLTTools: Neue Funktionen: FlipRB3() & FlipRB4() -> Optimierte Assembler Funktionen welche die RB komponenten in
     einem RGB bzw. RGBA Buffer vertauschen... ist bei diversen Bild Formaten notwendig... und so kann man die
     Ladezeiten etwas verkürzen :)
[CO] PLTLog: Neue Funktion: GetActive()
[CO] PLTFile um Funktionen zum Schreiben in Dateien erweitert
[CO] PLTModuleHandler: Neue Lade Funktion welche den Handler direkt mit einem Objekt läd
[CO] Stil der Friend deklarationen in den Klassen vereinheitlicht (über all nun friend class, so machts auch weniger
     probleme mit den Predefinationen :)
[CO] PLTTimer: mit GetFPSLimit() & SetFPSLimit() kann man nun eine FPS limitierung einbauen, diese FPS wird dann nicht
     überschritten... die Engine wird entsprechend aktualisiert, dadurch bleiben dem System mehr Resourcen für andere
     Dinge -> in fertigen Anwendungen sollte es keine FPS limitierung geben, zum Debuggen usw. könnte es aber nütlich
     sein :)
[CO] PLTModelHandler: GetStaticBoundingBox() & GetCollisionBoundingBox() entfernt. Wird ein Modell geladen so übergibt
     dieses all seine Bounding Boxes an sein Entity. Wird ein Modell entladen so verliert auch das Entity automatisch
     ALLE Bounding Boxes. Im Modell Handler selbst ist nun nur noch eine Bounding Box welche für die Sichtbarkeits
     bestimmung verwendet wird! (diese wird beim Modell Laden automatisch erzeugt)
[CO] PLTTools: Neue Funktionen: GetVarType() & GetVarTypeString() -> Tool-Funktionen welche einen Variable Typen in
     einen String konvertieren oder umgekehrt
[CO] Änderte bei den Pfadangaben die Backslashs zu Slashs damit alles einheitlich ist (es sind ja zwei verschiedene
     Schreibweisen im Umlauf :)
[CO] Alle PL-Tools in PLTools verschoben (ME, WE & Max plugin)
[CO] Die PLEBitField Flags waren falsch... das führte zu einem ganz erheblichen Performance verlust (da die Clear flags
     somit schrott waren :)
[CO] PLTTools: Neue Funktionen: SetFlagsString() und GetFlagsFromString() zum setzen und auslesen eines Flag-Strings
[CO] Ist der Timer 'eingefrohren' so werden nun auch keine Eingaben usw. akzeptiert, alles steht still ;-)
[CO] PLTModuleManager & PLTModule geändert. Nun hat PLTModule einen zeiger zurück auf PLTModuleManager denn wenn der
     Name von PLTModule geändert wird, so muss der Module Manager aktualisiert werden! Wichtig da die Module meist mit
     ihrem Namen angesprochen werden, daher darf es keine doppelten Module Namen geben! :)  ('Hey DU!... wer ich? NEIN
     du!' ;-)
[CO] PLTTokenizer: Einige Funktionen wie z.B. FindToken() und GetDataBlockInt() setzten am Ende automatisch auf den
     nächsten Token, dies erwies sich als ziemlich unpraktisch, daher ist dies nun geändert. (Funktionen welche den
     Parser verwenden wurden angepasst)
[CO] PLTModuleManager: Instance Check vorherst herausgestrichen da es ansonnsten unmöglich ist den Module Manager von
     einer Anwendung aus zu verwenden (da durch Template Problem Instance dort immer NULL), desweiteren nahm ich
     m_lstIDHashList heraus womit die Get(ID) funktion nun besser zum durchlaufen einer Module Schleife geeignet ist
[CO] Neue Funktion: PLTModuleManager::Create() -> Erzeugt ein neues Modul und liefert den Zeiger darauf zurück
[CO] Über PLTConfig kann man nun einstellen ob die 3 Ebenen visualisiert werden sollen oder nicht
[CO] PLTFileSystem::SetApplicationPath() fügt nun am Ende automatisch ein '\' ein wenn dieses nicht vorhanden ist
[CO] Neue Window-Klasse: PLTWindowOpenDialog -> Ein Dialog zum auswählen von Dateien -> Nam
     PLTFileSystem::GetFilenameDialog() heraus da nun überflüssig
[CO] PLTList ist nun nur noch ein 'Hilfmittel', sprich, es kann keine Zeiger mehr Löschen!
[SB] Makros geringfügig verändert und die Namen vereinheitlicht, über PL_IMPLEMENT_BASECLASS können nun auch mehrere
     Basisklassen implementiert werden
[SB] Die Makros wurden so erweitert, daß nun auch die Variablen der Entity-Klassen exportiert werden können. In einer
     VarTable werden diese Variablen dann mit ihren Namen gespeichert
[CO] PLTFileSystem: Neue Funktion: SetApplicationPath() -> Damit lässt sich der Pfad der Anwendung einstellen, im Fall
     des Modell Editos kann man diesen Pfad nun einstellen
[CO] Diverse Tool-Klassen erweitert
[CO] PLTModuleManager hatte teils gleiches problem wie das PLTGui... in den Listen wurden gelöschte Einträge nochmals
     gelöscht...
[CO] PLTTime -> Mit m_fTimeScaleFactor lässt sich nun ein universeller Zeit Faktor einstellen welcher IMMER angewannt
     wird. In der Konsole kann man diesen mit 'timescale 'f'' einstellen... beim Debuggen hilfreich :)
[CO] PLTPool -> Die Priorität eines Pool-Elements lässt sich nun verändern... praktisch wenn man ein Element vor einem
     anderen haben will (z.B. Sky layer verändern) :)
[CO] Baute eine Profiling Tool Klasse ein welche Hilfreich bei der Überwachung der verschiedenen Engine Teile sein wird,
     grob gesehen ist es nur eine Klasse welche verschiedene Gruppen von Texten verwaltet... aber mit diversen
     Hilfs-Funktionen :)
[CO] Neue Tool-Klasse: PLTPool -> Verwaltet eine Gruppe von Elementen wie z.B. Animations Informationen, Anker Punkten,
     Animation Events usw.
[CO] Copy funktionen eingebaut in: PLTMesh, PLTDataSet, PLTList, PLTDynamicList, PLTStack, PLTBitset
[CO] Neue Tool-Klasse PLTBitset zum verwalten beliebiger bits (z.B. um zu vermerken ob eine Geometry schon gerendert
     wurde oder nicht)
[CO] PLTFileSystem -> Neue Funktionen -> GetOnlyFilename() und GetDirectory()
[CO] Neue Funktion: PLTTimer::GetTickCount()
[CO] PLTTokenizer: GetNextToken() liefert nun einen Zeiger auf den gefundenen Token zurück damit man diesen z.B. sofort
     via atoi() in eine zahl umwandeln kann
[CO] PLTList & PLTDynamicList & PLTStack: Nahm Funktionen FindFirst(), FindNext() und GetCurrent() heraus da diese
     potentielle Fehlerquellen sind und der Operator [] durch die intere Zeiger optimierung mittlerweile genauso wenig
     Performance benötigt
[CO] Behob einen Fehler in der Listen-Klasse (beim Löschen... man, wie viele Fehler sind denn noch im Code!?? ;-)
[CO] Code sinnloserweise 'verschönert' ;-)
[SB] PLTTokenizer: Habe einen kleinen Fehler in den Abbruchbedingungen der Parserschleife behoben: Es ist auch möglich,
     daß sich z.B. Kommentare und ungültige Zeichen mehrfach abwechseln, diese müssen alle ignoriert werden und dürfen
     nicht als korrekte Zeichen angesehen werden
[CO] Behob einen kleinen Fehler im ModuleManager (zuerst Remove() und dann Objekt selbst entladen)
[CO] Erstellte eine einheitliche Tokenizer Klasse... benannte meine Klasse um und fügte Funktionen deiner hinzu... nun
     haben wir ein Monster Tokenizer ;-)
[SB] PLTTokenizer: Delimiters können nun auch während des Parsens ausgewechselt werden
[SB] PLTTokenizer Klasse hinzugefügt, welche zum direkten Auslesen von Tokens aus einer Textdatei dient.
[CO] PLTParser: Neue Funktionen: CompareTokens(), FindTokens(), GetTokensValueInt(), GetTokensValueStr(),
     GetDataBlockInt(), GetDataBlockFloat(), Push(), Pop()
[CO] Das Laden aus Archiven funktioniert nun endlich!! :)
[CO] Arbeitete etwas am FileSystem weiter. U.a. kann man nun auch über die Klasse PLTFile aus zip Archiven laden.
[CO] FileSystem: Dateien können nun auch außerhalb des Spieleordners liegen
     (dies sollte man aber trotzdem vermeiden :)
[CO] Baute eine Hash-Klasse ein (PLTHash) welche z.B. im Entity Manager verwendet wird
[CO] Baute PLTString Klasse ein
[SB] Module System eingebaut
[CO] PLTDataSet wurde erweitert und kann nun auch die Daten anderer Daten sets verwenden. Dies wird z.B. in PLTMesh
     verwendet um einzelne Daten mit anderen Meshs zu teilen. Ein Vorteil dieser Technik: Kommen die geteilten Daten
     'abhanden', so werden die anderen Daten Sets darüber informiert.
[CO] Erweiterte PLTDataSet um einzelene Elemente um alles noch dynamischer zu machen. Um z.B. Textur Koordinaten zu
     speichern kann man entweder PLTDataSet<PLFLOAT2> fTexCoord (1 element) oder PLTDataSet<float> fTexCoord (mit 2
     elementen) verwenden... wobei die letztere Technik mehr freiheiten lässt. ;-)
[CO] umbekannt: PLTDynamicLinkedList in PLTDynamicList
[CO] umbekannt: PLTLinkedList in PLTList
[CO] beseitigte den hässlichen Zeiger auf die delete-Funktion...  (Projekt-Einstellungen auf SE werte eingestellt :)
[CO] einen dummen Rechtschreibfehler behoben
[CO] baute dein Data Set Template ein (und erweiterte es etwas :)
[CO] viele kleine Stil anpassungen :)
[CO] Ordner strukturierung & docs
[CO] Namens Ändung
[CO] Intel-Jpg-Lib durch Independent JPEG Group's ersetzt
